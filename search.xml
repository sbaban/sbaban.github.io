<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>mac问题</title>
    <url>/mac1229.html</url>
    <content><![CDATA[<p>记录下使用mac过程中遇到的问题。</p>
<h2 id="删除残留图标">删除残留图标</h2>
<p>删除启动台 launchpad的图标</p>
<p>在launchpad界面，</p>
<p>1.长按快捷键control+option，图标会抖动</p>
<p>2.单击待删除图标，图标左上角出现问号</p>
<p>3.松开点击的这两个快捷键</p>
<p>4.再次按下这两个快捷键，这是图标左上角会出现叉叉，点击即可删除</p>
<h2 id="访达-finder-拷贝路径">访达 finder 拷贝路径</h2>
<p>option + command + c</p>
<h2 id="spotlight-打开文件夹">spotlight 打开文件夹</h2>
<p>按住command 单击</p>
<h2 id="数字键盘没反应">数字键盘没反应</h2>
<p>filco 数字键盘 小键盘 在mac上没反应</p>
<p>原因：mac开启了鼠标键，设置→关闭鼠标键就行</p>
<h2 id="path">PATH</h2>
<p>终端安装zsh后，mac会先激活</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">～/.zshrc中的环境变量</span><br></pre></td></tr></tbody></table></figure>
<p>导致每次都要输入source ～/.bash_profile注意查看环境变量是否冲突</p>
<h2 id="pycharm">pycharm</h2>
<ul>
<li><p><strong>pycharm配置anaconda的pytorch环境</strong></p>
<p>首先在anaconda上创建好pytorch 的环境，这里我的环境名字是py3。</p>
<p>选择新建项目，输入项目的位置，然后选择existing interpreter</p></li>
</ul>
<p><img src="/mac1229/20191229201348.png"></p>
<p>interpreter选择pytorch所在的环境py3所在的文件位置</p>
<p>conda executable目录选择conda所在的文件位置</p>
<p><img src="/mac1229/20191229201521.png"></p>
<p><img src="/mac1229/20191229201810.png" alt="img">)</p>
<p>完美成功</p>
<ul>
<li><p>彻底删除pycharm的项目</p>
<p>目前做法都是定位到目录，删除。</p>
<p>同时要注意是看下它的解释器的位置，如anaconda的环境，看是否需要删除</p></li>
</ul>
<h2 id="anaconda-navigator">anaconda navigator</h2>
<p>使用anaconda navigator同步环境，上传环境后就可以在其他电脑上下载和安装了。</p>
<p>登陆anaconda-navigator，假设我要上传的环境名为py3，</p>
<p>终端里输入</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">conda env export -n py3 -f py3.yml</span><br></pre></td></tr></tbody></table></figure>
<p>会在当前目录下生成你的环境文件py3.yml</p>
<p>后续操作懒得写了，看官方教程吧。</p>
<p>https://docs.anaconda.com/anaconda-cloud/user-guide/tasks/work-with-environments/</p>
]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>pycharm</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown编辑器折腾记录</title>
    <url>/markdown.html</url>
    <content><![CDATA[<p>一直以来用的Typora，也很满意，因为与坚果云同步图片的问题（一些不重要的笔记插入的图片也会被同步），需要再使用一个编辑器。</p>
<p>先说结论：如果只需要一个的话，我推荐Typora，如果需要第二个，我在推荐MarkText</p>
<p><strong>我的需求</strong>：</p>
<ul>
<li><p>能显示latex数学公式 Eg <span class="math inline">\(x^2 + y_2 = \frac{1}{4}\)</span></p></li>
<li><p>显示字体的<font color="red">颜色</font>,以下是我习惯使用的代码</p>
<p></p><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">&lt;fonr color=red&gt; 红色 &lt;/font&gt;</span><br><span class="line">&lt;span style="color:red;"&gt; 红色。&lt;/span&gt; （可以看出这个比font略麻烦）</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>能导出md文件，而不是只有这个软件自己才能使用的xx后缀（Eg印象笔记）</p></li>
<li><p>能打开自己建立的md文件</p></li>
</ul>
<p>体验过的编辑器有以下这些，找到的符合要求的只有MarkText，欢迎各位在评论区补充。</p>
<ul>
<li>语雀</li>
<li>熊掌记</li>
<li>Vnote<br>
</li>
<li>Vscode</li>
<li>WizNote-Lite</li>
<li>notion</li>
<li>MarkText</li>
</ul>
<h1 id="语雀">语雀</h1>
<ul>
<li><p>1.不能查看原始文档（doesn't matter）</p></li>
<li><p>2.如果使用富文本编辑器修改字体颜色，导出markdown文件时原始字体不作任何修改。</p></li>
<li><p>3.对于更改字体颜色，不显示<code>font</code>标签，而<code>span</code>手打起来比较麻烦</p></li>
<li><p><span style="color:red;">不能打开我自己建立的md文件</span>,即只能打开用软件自身建立的markdown文件，所以本质上并不是一个markdown编辑器 （因为这一条，我直接pass）</p></li>
</ul>
<h1 id="熊掌记">熊掌记</h1>
<p>支持打开自己建立的md文件</p>
<p>缺点：</p>
<ul>
<li>没有侧边栏目录 pass</li>
<li>字体颜色不支持<code>font</code></li>
</ul>
<p>Ps：没感觉熊掌记有什么亮点，不过好像挺多人使用的样子</p>
<h1 id="vnote-和-vscode">Vnote 和 Vscode</h1>
<ul>
<li><p>侧边栏没有像Typora的目录（或者目录不能固定），我觉得对于markdown来说，使用目录快速跳转查看编辑是很重要的</p></li>
<li><p>不是所见即所得，而是分屏预览式的编辑，个人觉得有点难受。pass</p></li>
</ul>
<p>Ps：我也一般都是用IDE写代码，感觉比Vscode效率更高，要是只为了写markdown不值得下载</p>
<h1 id="wiznote-lite">WizNote-Lite</h1>
<p>为知笔记出的markdown编辑器</p>
<ul>
<li>不能打开我自己建立的md文件 <span class="github-emoji"><span>😩</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f629.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>pass</li>
<li>不支持自定义图片缓存目录（至少我是没有找到）</li>
</ul>
<h1 id="notion">notion</h1>
<ul>
<li><p>不支持font</p></li>
<li><p>个人觉得有点臃肿，违背我的简单原则。</p></li>
</ul>
<h1 id="marktext">MarkText</h1>
<p>比较完美的Typora替代品，也支持自定义图片目录（可以随手粘贴截图），目前没发现什么缺点</p>
]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>折腾</tag>
      </tags>
  </entry>
  <entry>
    <title>优秀资源推荐</title>
    <url>/ziyuan.html</url>
    <content><![CDATA[<p>整理下个人觉得不错的软件。</p>
<p><font size="5" color="red"> <strong>如果有补充的，欢迎评论区留言</strong>。👏</font></p>
<ul>
<li><p><strong>坚果云</strong> 多平台，强烈推荐的一款多设备多平台同步软件。</p></li>
<li><p><strong>snipaste</strong> ： 多平台，截图软件，特色是可以将截图固定在桌面上，但目前不支持长截图</p></li>
<li><p><strong>滴答清单</strong>：记下待办事项，最大优点是自动并精确提取时间，不用向其他软件那样还需要手动设定时间，要体验日历功能需要付费，3天一块，个人舍不得，用其他办法解决了（若有需要请邮件联系我，联系地址见about）</p></li>
<li><p><strong>Cold Turkey Blocker</strong>：绝对锁定应用、网页，至少我是没办法绕开它。每次锁住炉石的就是它，学习时我一般把b站、v站、知乎也锁起来</p></li>
<li><p><del><strong>Notepad++</strong> windows下的一款文本编辑器，速度快，好用。</del>（软件作者反华，可用sublime代替）</p>
<p>关于sublime配置可参见<a href="https://sbaban.com/wenben.html">我的文本编辑器折腾记录</a></p></li>
<li><p><strong>listary</strong>： windows下的检索文件工具，双击ctrl就能检索，而且检索结果秒出，节省了大量时间。类似的还有<strong>everything</strong>，不过个人更喜欢listary</p></li>
<li><p><strong>Acrobat</strong> Adobe家的一款编辑pdf的软件，主要用于修改pdf内容（包括图片、文字）、删除某一页，将图片合并成pdf。</p></li>
<li><p><strong>Dexpot</strong> 虚拟桌面工具，可以让你电脑有多个桌面（相当于多台显示器，通过快捷键切换每个桌面）。不过我通常是学习一个桌面，摸鱼一个桌面，老板来了迅速切换到工作桌面。</p></li>
<li><p><strong>Typora</strong> 编写markdown文档，所见即所得，左侧大纲视图很好</p></li>
<li><p><strong>colab</strong> Google的jupyter notebook，各种环境，包都安装好了，而且还能免费使用GPU</p></li>
<li><p><strong>anaconda-navigator</strong> python环境管理工具，因为经常用到不同版本的环境切换如py2话题py3，便于管理不同环境和依赖，搭配pycharm使用更方便。</p>
<ul>
<li><a href="https://sbaban.com/mac1229.html">pycharm如何使用anaconda环境</a></li>
</ul></li>
<li><p><strong>aixcoder</strong> 代码补全插件，一补补一句话的见过吗？</p></li>
<li><p><strong>picGo</strong> 多平台，图床类软件</p></li>
<li><p><strong>Imagine</strong> 图片压缩软件</p></li>
</ul>
<p><strong>mac特有的</strong></p>
<ul>
<li><strong>zsh+item2</strong>：mac下终端优化，具体可搜索关键字。</li>
<li><strong>Hidden Bar</strong>: 免费的管理顶部图标的工具</li>
<li><strong>Finalshell</strong>:SSH工具，鼠标傻瓜式操作，支持远程编辑，文件传输看可视化窗口</li>
</ul>
]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>推荐</tag>
      </tags>
  </entry>
  <entry>
    <title>博客折腾记录</title>
    <url>/ztblog.html</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<ul>
<li><p>第一阶段：阿里云学生机+wordpress+为知笔记（为知笔记可一键发布到wordpress），因阿里云学生机非学生后价格昂贵，及早抽身；</p></li>
<li><p>第二阶段：hexo+githubpage+travis 这期间因图片问题折腾好久（图片的大小、同步、备份），图图床用的七牛云，这一阶段一度很舒服。</p></li>
<li>第三阶段：为了提速，请老司机协助改为腾讯云cos+hexo+github+travis，并采用了https。同时由于https，七牛云图床对https不免费，图床改为腾讯云。</li>
<li><p>第四阶段：因travis换域名、腾讯云换优惠政策，图片流量过大导致我开销过大等一系列问题放弃；博客图片若不压缩，导致体积较大，进而导致流量大，进而导致开销大；尚未找到能直接对截图进行压缩的截图软件或者上传图床前进行压缩的图片上传软件（ipic可以，但一年60¥入不敷出），现在只能截图保存到电脑，手动压缩再上传图床，实在有点麻烦。再加上有些事情+疫情，播客停摆了大半年。</p></li>
</ul>
<p>目前：hugo+githubpage，</p>
<p>心得：越简单越好, 遵循奥卡姆剃刀原则，<strong>若无必要，勿增实体</strong>。什么鼠标动画、背景音乐通通都不要。</p>
<h2 id="优化">优化：</h2>
<ul>
<li>加密文章
<ul>
<li>https://github.com/D0n9X1n/hexo-blog-encrypt/blob/master/ReadMe.zh.md</li>
</ul></li>
</ul>
<h2 id="测试">测试</h2>
<p>域名绑定 <span class="github-emoji"><span>🉑</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f251.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
<p>emoji显示 <span class="github-emoji"><span>🉑</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f251.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
<p>数学公式test： <span class="math inline">\(x^2 + \frac{1}{3} + \sum_1^3 =a_2\)</span> <span class="github-emoji"><span>🉑</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f251.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
<p>字体大小颜色检查 <font color="yellow" size="6">黄</font> <font color="red">红</font> <span class="github-emoji"><span>🉑</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f251.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
<p>评论检查 <span class="github-emoji"><span>🉑</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f251.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
<p>url网址优化 <span class="github-emoji"><span>🉑</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f251.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
<p>文章置顶、加密 <span class="github-emoji"><span>🉑</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f251.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
<p>文章推荐、文章搜索 <span class="github-emoji"><span>🉑</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f251.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
<h2 id="插件">插件</h2>
<p>记录下安装的插件</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">npm <span class="built_in">list</span> --depth <span class="number">0</span></span><br><span class="line">hexo-site@<span class="number">0.0</span><span class="number">.0</span> /xxx/star-mbp/xxx/finalblog</span><br><span class="line">├── hexo@<span class="number">5.4</span><span class="number">.0</span></span><br><span class="line">├── hexo-asset-image@<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">├── hexo-blog-encrypt@<span class="number">3.1</span><span class="number">.5</span></span><br><span class="line">├── hexo-deployer-git@<span class="number">3.0</span><span class="number">.0</span></span><br><span class="line">├── hexo-<span class="built_in">filter</span>-github-emojis@<span class="number">3.0</span><span class="number">.4</span></span><br><span class="line">├── hexo-generator-archive@<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">├── hexo-generator-category@<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">├── hexo-generator-index-pin-top@<span class="number">0.2</span><span class="number">.2</span></span><br><span class="line">├── hexo-generator-search@<span class="number">2.4</span><span class="number">.1</span></span><br><span class="line">├── hexo-generator-searchdb@<span class="number">1.3</span><span class="number">.3</span></span><br><span class="line">├── hexo-generator-tag@<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">├── hexo-related-popular-posts@<span class="number">5.0</span><span class="number">.1</span></span><br><span class="line">├── hexo-renderer-ejs@<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">├── hexo-renderer-markdown-it@<span class="number">5.0</span><span class="number">.0</span></span><br><span class="line">├── hexo-renderer-pandoc@<span class="number">0.3</span><span class="number">.0</span></span><br><span class="line">├── hexo-renderer-stylus@<span class="number">2.0</span><span class="number">.1</span></span><br><span class="line">├── hexo-server@<span class="number">2.0</span><span class="number">.0</span></span><br><span class="line">├── hexo-theme-landscape@<span class="number">0.0</span><span class="number">.3</span></span><br><span class="line">└── markdown-it-emoji@<span class="number">2.0</span><span class="number">.0</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="hexo命令">hexo命令</h2>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">hexo n <span class="string">"博客名称"</span> <span class="comment"># 创建一个新md文件 #我都是复制粘贴的</span></span><br><span class="line">hexo c <span class="comment">#清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</span></span><br><span class="line">hexo g <span class="comment">#生成静态文件</span></span><br><span class="line">hexo d <span class="comment">#部署网站</span></span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>折腾</tag>
      </tags>
  </entry>
  <entry>
    <title>MBP挖矿记录，以XMR为例</title>
    <url>/wakuang.html</url>
    <content><![CDATA[<p>我的装备：</p>
<p>设备：MacBook Pro 2019（由于没有显卡，只能用CPU试试挖XMR<span class="github-emoji"><span>😢</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>）</p>
<p>矿池和币种：猫池+XMR</p>
<p>钱包：币安</p>
<p>挖矿软件：Xmrig</p>
<p>有问题 或者 有什么建议 可以在评论区留言,</p>
<h2 id="挖矿">挖矿：</h2>
<h3 id="获取xmr钱包-以币安为例">获取XMR钱包: 以币安为例</h3>
<ul>
<li>1.从<a href="https://www.binance.com/zh-CN/register?ref=QKZ1VFJJ">币安</a>（里面含双方10%的返现邀请码,你好我好大家好，见下图）注册，获取钱包地址，挖到的xmr会放到这里。</li>
</ul>
<p><img src="/wakuang/返佣比例.png"></p>
<ul>
<li><p>2.选择钱包 → 现货账户 → 币种选择XMR → 选择钱包地址 → 单击复制按钮</p>
<figure>
<img src="/wakuang/biance.jpg" alt="xmr钱包地址"><figcaption>xmr钱包地址</figcaption>
</figure></li>
</ul>
<h3 id="下载挖矿软件以xmrig6.9.0为例">下载挖矿软件：以xmrig6.9.0为例</h3>
<p>从<a href="https://github.com/xmrig/xmrig/releases">github</a>选择相应的系统下载安装，不细说了，作者貌似要抽水1%，（能力强的可以自己编译，对于网上别人编译的谨慎使用吧）。</p>
<h3 id="选择矿池挖矿">选择矿池挖矿：</h3>
<p>切换到对应的xmrig所在的文件夹，以命令行启动（或者修改config.json），这里以命令行为例。</p>
<p></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">./xmrig -o mine.c3pool.cn:<span class="number">15555</span> -u 86nFbcdHDhGDZksr6t9MMhJmw42cSS2MX1hRL9PdmAFrBXgwLBnyvB754JB38sLyaZUDmY61t9bzUGMseCzJ3RH8KEUF3W2 -p <span class="number">0</span> -k</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>-o 是矿池地址,这里用的是猫池的地址。（cn不行可以试试com）</p>
<p>-u是刚刚币安的xmr钱包地址；</p>
<p>-p可以当作矿机名</p>
<figure>
<img src="/wakuang/wakuang.png" alt="运行界面"><figcaption>运行界面</figcaption>
</figure>
<p>算力很低，差不多1KH/S，(可以搜下XMR收益计算器算下收益)，大概1天1元钱的样子，人间不值得。</p>
<h3 id="查看矿池的挖矿进度">查看矿池的挖矿进度</h3>
<p>可以去矿池网站输入你的钱包地址查看待领取的XMR。</p>
<p>进入<a href="https://c3pool.com">猫池主页</a>,输入刚刚命令行里的钱包地址。</p>
<h2 id="提现">提现：</h2>
<p>当挖到一定的xmr后就可以在币安提现了。其他币种的提现也差不多。</p>
<h3 id="xmr-usdt">XMR &gt; USDT</h3>
<ul>
<li><p>登录币安 → 选择钱包 → 现货账户 → 币种选择XMR ，还是第一张图那里，选择“去交易”下方的<code>XMR/USDT</code> （或者选择其他币种，我是觉得USDT比较稳定）</p></li>
<li><p>若想立刻卖出选择<strong>市价</strong>，若想卖得贵一点选择<strong>限价</strong>，可以参考两侧的当前成交价设定合适的价格，价格到了你设定的价格便会自动出售。</p>
<figure>
<img src="/wakuang/mai.png" alt="出售xmr"><figcaption>出售xmr</figcaption>
</figure></li>
</ul>
<h3 id="usdt-人民币">USDT &gt; 人民币</h3>
<ul>
<li><p>卖出后收到USDT，登录币安 → 钱包总览 → C2C账户 → 选择USDT → 划转 → 填入合适数量</p>
<figure>
<img src="/wakuang/usdt.png" alt="划转"><figcaption>划转</figcaption>
</figure></li>
<li><p>划转后，C2C账户 → 选择USDT → 卖</p>
<p>左边可以选价格区间，有的商家嫌数额太少不交易的（比如我，手动输入50元）</p>
<p>这里不细说了，我记得好像要身份验证的。</p>
<figure>
<img src="/wakuang/出售.png" alt="出售"><figcaption>出售</figcaption>
</figure>
<p>说下道听途说的注意的几点</p>
<p>1选择合适价格，合适的卖家（成交量大的、成交率高的）.</p>
<p>2尽量不要使用银行卡，推荐支付宝或微信。</p>
<p>3其他就跟闲鱼差不多，确认收到款后再发货(就是下图的放行)</p></li>
</ul>
<p>给各位看下曾经砸锅卖铁赚的钱(里面还有我多年前伊拉克战损主机的显卡挖的其他币种兑的USDT，感觉靠XMR赚钱不行的)</p>
<figure>
<img src="/wakuang/money.png" alt="money"><figcaption>money</figcaption>
</figure>
<h1 id="一些概念">一些概念</h1>
<h3 id="effort">effort：</h3>
<p>how many hashes our pool made to find a block.找到一个block做的hash</p>
<p>简单来说，effort越低越幸运，&gt;100%说明unlucky，做的hash多了</p>
<h3 id="block-effort">block effort：</h3>
<p>一个区块的effort/池最后一个区块的平均effort</p>
<h3 id="block-height">block height：</h3>
<p>在区块链（blockchain）中该区块前面的区块数，其值是比较稳定的 re: https://www.investopedia.com/terms/b/block-height.asp</p>
<h3 id="block-maturity">block maturity：</h3>
<p>when a block was founded by a pool,pool 需要再开采x个blocks（这个x好像是程序设置的） re: https://monero.stackexchange.com/questions/2251/what-is-the-block-maturity-value-seen-in-many-pool-interfaces</p>
<h3 id="pending-balance">pending balance：</h3>
<p>只有当pool找到一个block 并且 this block is mature才会更新</p>
]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>折腾</tag>
      </tags>
  </entry>
  <entry>
    <title>karabiner 键位设置</title>
    <url>/karabiner.html</url>
    <content><![CDATA[<h2 id="实现的功能">实现的功能</h2>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">将capslock替换为fn</span><br><span class="line"></span><br><span class="line">fn + i/k/j/f  上下左右移动光标</span><br><span class="line">fn + a/e 光标移动到行首/行尾</span><br><span class="line">fn + d 退格键</span><br></pre></td></tr></tbody></table></figure>
<p>json文件（见文章末尾），将此文件放在</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">~/.config/karabiner/assets/complex_modifications 目录下</span><br></pre></td></tr></tbody></table></figure>
<p>打开karabiner-elements → complex modifications → add rule, 大功告成。</p>
<p>有问题，请在评论区留言，24小时必定回复。</p>
<h2 id="json文件">json文件</h2>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="attr">"title"</span>: <span class="string">"方向映射"</span>,</span><br><span class="line">    <span class="attr">"rules"</span>: [</span><br><span class="line">        {</span><br><span class="line">            <span class="attr">"description"</span>: <span class="string">"fn+IJKF变成方向键"</span>,</span><br><span class="line">            <span class="attr">"manipulators"</span>: [</span><br><span class="line">                {</span><br><span class="line">                    <span class="attr">"type"</span>: <span class="string">"basic"</span>,</span><br><span class="line">                    <span class="attr">"from"</span>: {</span><br><span class="line">                        <span class="attr">"key_code"</span>: <span class="string">"i"</span>,</span><br><span class="line">                        <span class="attr">"modifiers"</span>: {</span><br><span class="line">                            <span class="attr">"mandatory"</span>: [<span class="string">"fn"</span>],</span><br><span class="line">                            <span class="attr">"optional"</span>: [<span class="string">"any"</span>]</span><br><span class="line">                        }</span><br><span class="line">                    },</span><br><span class="line">                    <span class="attr">"to"</span>: [{<span class="attr">"key_code"</span>: <span class="string">"up_arrow"</span>}]</span><br><span class="line">                },</span><br><span class="line">                {</span><br><span class="line">                    <span class="attr">"type"</span>: <span class="string">"basic"</span>,</span><br><span class="line">                    <span class="attr">"from"</span>: {</span><br><span class="line">                        <span class="attr">"key_code"</span>: <span class="string">"j"</span>,</span><br><span class="line">                        <span class="attr">"modifiers"</span>: {</span><br><span class="line">                            <span class="attr">"mandatory"</span>: [<span class="string">"fn"</span>],</span><br><span class="line">                            <span class="attr">"optional"</span>: [<span class="string">"any"</span>]</span><br><span class="line">                        }</span><br><span class="line">                    },</span><br><span class="line">                    <span class="attr">"to"</span>: [{<span class="attr">"key_code"</span>: <span class="string">"left_arrow"</span>}]</span><br><span class="line">                },</span><br><span class="line">                {</span><br><span class="line">                    <span class="attr">"type"</span>: <span class="string">"basic"</span>,</span><br><span class="line">                    <span class="attr">"from"</span>: {</span><br><span class="line">                        <span class="attr">"key_code"</span>: <span class="string">"k"</span>,</span><br><span class="line">                        <span class="attr">"modifiers"</span>: {</span><br><span class="line">                            <span class="attr">"mandatory"</span>: [<span class="string">"fn"</span>],</span><br><span class="line">                            <span class="attr">"optional"</span>: [<span class="string">"any"</span>]</span><br><span class="line">                        }</span><br><span class="line">                    },</span><br><span class="line">                    <span class="attr">"to"</span>: [{<span class="attr">"key_code"</span>: <span class="string">"down_arrow"</span>}]</span><br><span class="line">                },</span><br><span class="line">                {</span><br><span class="line">                    <span class="attr">"type"</span>: <span class="string">"basic"</span>,</span><br><span class="line">                    <span class="attr">"from"</span>: {</span><br><span class="line">                        <span class="attr">"key_code"</span>: <span class="string">"f"</span>,</span><br><span class="line">                        <span class="attr">"modifiers"</span>: {</span><br><span class="line">                            <span class="attr">"mandatory"</span>: [<span class="string">"fn"</span>],</span><br><span class="line">                            <span class="attr">"optional"</span>: [<span class="string">"any"</span>]</span><br><span class="line">                        }</span><br><span class="line">                    },</span><br><span class="line">                    <span class="attr">"to"</span>: [{<span class="attr">"key_code"</span>: <span class="string">"right_arrow"</span>}]</span><br><span class="line">                },</span><br><span class="line">                {</span><br><span class="line">                    <span class="attr">"type"</span>: <span class="string">"basic"</span>,</span><br><span class="line">                    <span class="attr">"from"</span>: {</span><br><span class="line">                        <span class="attr">"key_code"</span>: <span class="string">"spacebar"</span>,</span><br><span class="line">                        <span class="attr">"modifiers"</span>: {</span><br><span class="line">                            <span class="attr">"mandatory"</span>: [<span class="string">"fn"</span>],</span><br><span class="line">                            <span class="attr">"optional"</span>: [<span class="string">"any"</span>]</span><br><span class="line">                        }</span><br><span class="line">                    },</span><br><span class="line">                    <span class="attr">"to"</span>: [{<span class="attr">"key_code"</span>: <span class="string">"caps_lock"</span>}]</span><br><span class="line">                }</span><br><span class="line">            ]</span><br><span class="line">        },</span><br><span class="line">        {</span><br><span class="line">        <span class="attr">"description"</span>: <span class="string">"fn+a 行首"</span>,</span><br><span class="line">        <span class="attr">"manipulators"</span>: [</span><br><span class="line">        {</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"basic"</span>,</span><br><span class="line">            <span class="attr">"from"</span>: {</span><br><span class="line">                <span class="attr">"key_code"</span>: <span class="string">"a"</span>,</span><br><span class="line">                <span class="attr">"modifiers"</span>: {</span><br><span class="line">                    <span class="attr">"mandatory"</span>: [<span class="string">"fn"</span>],</span><br><span class="line">                    <span class="attr">"optional"</span>: [<span class="string">"any"</span>]</span><br><span class="line">                }</span><br><span class="line">            },</span><br><span class="line">          <span class="attr">"to"</span>: [</span><br><span class="line">            {</span><br><span class="line">            <span class="attr">"key_code"</span>: <span class="string">"left_arrow"</span>,</span><br><span class="line">            <span class="attr">"modifiers"</span>: <span class="string">"command"</span></span><br><span class="line">            }</span><br><span class="line">          ]</span><br><span class="line">        }</span><br><span class="line">        ]</span><br><span class="line">        },</span><br><span class="line">        {</span><br><span class="line">        <span class="attr">"description"</span>: <span class="string">"fn+e 行尾"</span>,</span><br><span class="line">        <span class="attr">"manipulators"</span>: [</span><br><span class="line">        {</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"basic"</span>,</span><br><span class="line">            <span class="attr">"from"</span>: {</span><br><span class="line">                <span class="attr">"key_code"</span>: <span class="string">"e"</span>,</span><br><span class="line">                <span class="attr">"modifiers"</span>: {</span><br><span class="line">                    <span class="attr">"mandatory"</span>: [<span class="string">"fn"</span>],</span><br><span class="line">                    <span class="attr">"optional"</span>: [<span class="string">"any"</span>]</span><br><span class="line">                }</span><br><span class="line">            },</span><br><span class="line">          <span class="attr">"to"</span>: [</span><br><span class="line">            {</span><br><span class="line">            <span class="attr">"key_code"</span>: <span class="string">"right_arrow"</span>,</span><br><span class="line">            <span class="attr">"modifiers"</span>: <span class="string">"command"</span></span><br><span class="line">            }</span><br><span class="line">          ]</span><br><span class="line">        }</span><br><span class="line">        ]</span><br><span class="line">        },</span><br><span class="line">        {</span><br><span class="line">        <span class="attr">"description"</span>: <span class="string">"fn+d 退格"</span>,</span><br><span class="line">        <span class="attr">"manipulators"</span>: [</span><br><span class="line">        {</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"basic"</span>,</span><br><span class="line">            <span class="attr">"from"</span>: {</span><br><span class="line">                <span class="attr">"key_code"</span>: <span class="string">"d"</span>,</span><br><span class="line">                <span class="attr">"modifiers"</span>: {</span><br><span class="line">                    <span class="attr">"mandatory"</span>: [<span class="string">"fn"</span>],</span><br><span class="line">                    <span class="attr">"optional"</span>: [<span class="string">"any"</span>]</span><br><span class="line">                }</span><br><span class="line">            },</span><br><span class="line">          <span class="attr">"to"</span>: [</span><br><span class="line">            {</span><br><span class="line">            <span class="attr">"key_code"</span>: <span class="string">"delete_or_backspace"</span></span><br><span class="line">            }</span><br><span class="line">          ]</span><br><span class="line">        }</span><br><span class="line">        ]</span><br><span class="line">        }</span><br><span class="line">    ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>折腾</tag>
      </tags>
  </entry>
  <entry>
    <title>键盘鼠标折腾记录</title>
    <url>/keyboard.html</url>
    <content><![CDATA[<p>作为一名<del>程序员</del>计算机专业的人，键盘鼠标必不可少，目前在线还没有达到，只需要一根数据线，一个手机，010101便能整出一切的大神境界。</p>
<p>先说结论：<strong><font color="red">罗技master2s</font></strong>（买不起3），<strong>Filco圣手二代蓝牙双模<font color="red">104键</font>茶轴</strong></p>
<p>体验过的鼠标：罗技G302、苹果妙控鼠标2、罗技master2s</p>
<p>体验过的键盘：minila air、苹果magic妙控键盘2、HHKB hybrid type-s、Filco圣手二代<font color="red">104键</font>茶轴、Nums智能键盘、罗技K380</p>
<p>（PS：个人实在不喜欢那些花里胡哨的RGB灯，我只觉得刺激我眼睛影响我专注、消耗我家电量、还造成产品价格上涨甚至还被商家当做宣传卖点）</p>
<h2 id="鼠标">鼠标</h2>
<h3 id="罗技g302">罗技G302</h3>
<p>买的第一款100￥以上的鼠标，在合适价格内实在是找不到不带呼吸灯的电竞鼠标，买来之后便把它的呼吸灯关了。</p>
<p>有线鼠标，16年199￥购买的，用了好几年了，还是不错的，因为疫情放在学校没带，买了新的后被抛弃了。</p>
<h3 id="苹果妙控鼠标2">苹果妙控鼠标2</h3>
<p>买的时候更多是想体验下，实际上跟触控板差不多，不是很推荐。</p>
<h3 id="master2s">master2s</h3>
<p>体型很大，不过挺方便的，无阻力滚轮（甚至用来解压），几个常用功能可以绑定在鼠标上。</p>
<p>游戏体验不清楚，没用来玩过即时游戏，（毕竟我玩炉石的，在大闸蟹术士的时代也是用的MBP自带触控板配合我单身几十年的手速，顶着巨大压力在90s内一回合极限斩杀对方。）</p>
<p>master3没体验过不清楚，对2s还是挺满意的，推荐</p>
<h2 id="键盘">键盘</h2>
<h3 id="minila-air">minila air</h3>
<p>买的第一款机械键盘，而且还是67键。1058￥</p>
<p>最让我不能忍受的是右边的<code>shift</code>键盘太小了，跟字母一样大，只有一个手指的大小，经常按错，对于我来说，使用右边shift的频率远远大于左shift，实在是太不方便了。</p>
<p>使用过几天便束之高阁，不推荐。</p>
<h3 id="苹果妙控键盘2">苹果妙控键盘2</h3>
<p>因为疫情在家，笔记本放在支架上，触控板不方便，正好跟妙控鼠标一套，就买了 。</p>
<p>实际体验一般，不推荐。</p>
<h3 id="hhkb-hybrid-type-s">HHKB Hybrid type-s</h3>
<p>HHKB静电容，2699￥买的</p>
<p>久闻HHKB大名，号称一步到位的键盘。</p>
<p>实际体验下来，没有数字小键盘和上下左右方向键还是不太方便。</p>
<p>毕竟能用一个手指做的事情，为什么要用两个手指。</p>
<p>再加上可能我不太熟练，有时候要看一眼键盘才能找准右下角的方向键的位置。</p>
<p>综合来说，我不是很推荐。</p>
<h3 id="filco-圣手二代104键">filco 圣手二代104键</h3>
<p>重点是<strong><font size="11">104键</font></strong>，经过种种体验，我确定了我的目标104键，带方向键和数字小键盘。</p>
<p>实际体验：舒服啊，噼里啪啦地很顺畅，数字键也能盲敲，再也不用看键盘了， 甚至开虚拟机玩DNF都能用上数字小键盘了，感觉提升了不少战力呢。</p>
<p>以后再看到吹67键的，什么程序员神器、专为xx设计、极客风格，我都呵呵一笑，</p>
<h3 id="nums智能键盘">Nums智能键盘</h3>
<p>实际上卖的是软件，在触控板上贴一层膜，9.9￥买的。</p>
<p>当初想法是mbp没有数字小键盘不方便。</p>
<p>手感很差，眼睛要盯着看，反馈也比较差，有那功夫我直接用自带的数字键都敲完了。</p>
<p>不推荐</p>
<h3 id="logi-k380">logi K380</h3>
<p>手感一般，毕竟价格摆在那；切换设备倒是挺迅速的，给ipad用倒是挺方便的。</p>
<p>当初买来是给ipad用的，实际ipad打字次数并不多，所以使用频率也不高。</p>
]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>折腾</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-python实现-全目录</title>
    <url>/jzomulu.html</url>
    <content><![CDATA[<p>此系列为《剑指offer》第二版的python实现，</p>
<p>测试代码的网址为<a href="https://www.nowcoder.com/ta/coding-interviews">牛客网</a></p>
<h4 id="数组中重复的数字-解答">3数组中重复的数字 <a href="https://sbaban.com/jz2019num.html">解答</a></h4>
<h4 id="二维数组的查找-解答">4二维数组的查找 <a href="https://sbaban.com/jz20191205er.html">解答</a></h4>
<h4 id="替换空格-解答">5替换空格 <a href="https://sbaban.com/jzo5.html">解答</a></h4>
<h4 id="从尾到头打印链表-解答">6从尾到头打印链表 <a href="https://sbaban.com/jz20191205l.html">解答</a></h4>
<h4 id="重建二叉树-解答">7重建二叉树 <a href="https://sbaban.com/jzerchashu.html">解答</a></h4>
<h4 id="二叉树的下一个结点-解答">8二叉树的下一个结点 <a href="https://sbaban.com/jz20191227.html">解答</a></h4>
<h4 id="用两个栈实现队列-解答">9用两个栈实现队列 <a href="https://sbaban.com/jzqueue1230.html">解答</a></h4>
<h4 id="旋转数组的最小数字-解答">11旋转数组的最小数字 <a href="https://sbaban.com/jzo11.html">解答</a></h4>
<h4 id="矩阵中的路径-解答">12矩阵中的路径 <a href="https://sbaban.com/jzo12.html">解答</a></h4>
<h4 id="机器人的运动范围-解答">13机器人的运动范围 <a href="https://sbaban.com/jzo13.html">解答</a></h4>
<h4 id="剪绳子-解答">14剪绳子 <a href="https://sbaban.com/jzo14.html">解答</a></h4>
<h4 id="二进制中1的个数-解答">15二进制中1的个数 <a href="https://sbaban.com/jzo15.html">解答</a></h4>
<h4 id="数值的整数次方-解答">16数值的整数次方 <a href="https://sbaban.com/jzo16.html">解答</a></h4>
<h4 id="打印-从1到最大的n位数-解答">17打印 从1到最大的n位数 <a href="https://sbaban.com/jzo17.html">解答</a></h4>
<h4 id="o1复杂度删除链表的结点-解答">18O(1)复杂度删除链表的结点 <a href="https://sbaban.com/jzo18.html">解答</a></h4>
<h4 id="正则表达式匹配解答">19正则表达式匹配<a href="https://sbaban.com/jzo19.html">解答</a></h4>
<h4 id="表示数值的字符串-解答">20表示数值的字符串 <a href="https://sbaban.com/jzo20.html">解答</a></h4>
<h4 id="调整数组顺序使奇数位于偶数前面-解答">21调整数组顺序使奇数位于偶数前面 <a href="https://sbaban.com/jzo21.html">解答</a></h4>
<h4 id="链表中倒数第k个结点-解答">22链表中倒数第K个结点 <a href="https://sbaban.com/jzo22.html">解答</a></h4>
<h4 id="链表中环的入口节点-解答">23链表中环的入口节点 <a href="https://sbaban.com/jz20191206.html">解答</a></h4>
<h4 id="反转链表解答">24反转链表<a href="https://sbaban.com/jzo24.html">解答</a></h4>
<h4 id="合并两个排序的链表-解答">25合并两个排序的链表 <a href="https://sbaban.com/jzo25.html">解答</a></h4>
<h4 id="树的子结构解答">26树的子结构<a href="https://sbaban.com/jzo26.html">解答</a></h4>
<h4 id="二叉树的镜像-解答">27二叉树的镜像 <a href="https://sbaban.com/jzo27.html">解答</a></h4>
<h4 id="对称的二叉树-解答">28对称的二叉树 <a href="https://sbaban.com/jzo28.html">解答</a></h4>
<h4 id="顺时针打印矩阵-解答">29顺时针打印矩阵 <a href="https://sbaban.com/jzo29.html">解答</a></h4>
<h4 id="包含min函数的栈-解答">30包含min函数的栈 <a href="https://sbaban.com/jzo30.html">解答</a></h4>
<h4 id="栈的压入弹出序列-解答">31栈的压入弹出序列 <a href="https://sbaban.com/jzo31.html">解答</a></h4>
<h4 id="从上到下打印二叉树-解答">32从上到下打印二叉树 <a href="https://sbaban.com/jzo32.html">解答</a></h4>
<h4 id="二叉搜索树的后序遍历序列-解答">33二叉搜索树的后序遍历序列 <a href="https://sbaban.com/jzo33.html">解答</a></h4>
<h4 id="二叉树中和为某一值的路径-解答">34二叉树中和为某一值的路径 <a href="https://sbaban.com/jzo34.html">解答</a></h4>
<h4 id="复杂链表的复制-解答">35复杂链表的复制 <a href="https://sbaban.com/jzo35.html">解答</a></h4>
<h4 id="二叉搜索树与双向链表-解答">36二叉搜索树与双向链表 <a href="https://sbaban.com/jzo36.html">解答</a></h4>
<h4 id="序列化二叉树-解答">37序列化二叉树 <a href="https://sbaban.com/jzo37html">解答</a></h4>
<h4 id="字符串的排列-解答">38字符串的排列 <a href="https://sbaban.com/jzo38.html">解答</a></h4>
<h4 id="数组中出现次数超过一半的数字-解答">39数组中出现次数超过一半的数字 <a href="https://sbaban.com/jzo39.html">解答</a></h4>
<h4 id="最小的k个数-解答">40最小的k个数 <a href="https://sbaban.com/jzo40.html">解答</a></h4>
<h4 id="数据流中的中位数-解答">41数据流中的中位数 <a href="https://sbaban.com/jzo41.html">解答</a></h4>
<h4 id="连续子树组的最大和-解答">42连续子树组的最大和 <a href="https://sbaban.com/jzo42.html">解答</a></h4>
<h4 id="整数中1出现的次数从1到n整数中1出现的次数-解答-待更新">43整数中1出现的次数（从1到n整数中1出现的次数） <a href="https://sbaban.com/jzo43.html">解答</a> ===待更新 ==</h4>
<h4 id="数字序列中某一位的数字-解答-待更新">44数字序列中某一位的数字 <a href="https://sbaban.com/jzo44.html">解答</a> ===待更新 ==</h4>
<h4 id="把数组排成最小的数-解答">45把数组排成最小的数 <a href="https://sbaban.com/jzo45.html">解答</a></h4>
<h4 id="把数字翻译成字符串-解答">46把数字翻译成字符串 <a href="https://sbaban.com/jzo46.html">解答</a></h4>
<h4 id="礼物的最大价值-解答">47礼物的最大价值 <a href="https://sbaban.com/jzo47.html">解答</a></h4>
<h4 id="最长不含重复字符的子字符串-解答">48最长不含重复字符的子字符串 <a href="https://sbaban.com/jzo48.html">解答</a></h4>
<h4 id="丑数-解答">49丑数 <a href="https://sbaban.com/jzo49.html">解答</a></h4>
<h4 id="第一个只出现一次的字符-解答">50第一个只出现一次的字符 <a href="https://sbaban.com/jzo50.html">解答</a></h4>
<h4 id="数组中的逆序对-解答">51数组中的逆序对 <a href="https://sbaban.com/jzo51.html">解答</a></h4>
<h4 id="两个链表的第一个公共结点-解答">52两个链表的第一个公共结点 <a href="https://sbaban.com/jzo52.html">解答</a></h4>
<h4 id="在排序数组中查找数字-解答">53在排序数组中查找数字 <a href="https://sbaban.com/jzo53.html">解答</a></h4>
<h4 id="二叉搜索树的第k大节点-解答">54二叉搜索树的第k大节点 <a href="https://sbaban.com/jzo54.html">解答</a></h4>
<h4 id="二叉树的深度-解答">55二叉树的深度 <a href="https://sbaban.com/jzo55.html">解答</a></h4>
<h4 id="数组中数字出现的次数-解答">56数组中数字出现的次数 <a href="https://sbaban.com/jzo56.html">解答</a></h4>
<h4 id="和为s的数字-解答">57和为s的数字 <a href="https://sbaban.com/jzo57.html">解答</a></h4>
<h4 id="翻转字符串-解答">58翻转字符串 <a href="https://sbaban.com/jzo58.html">解答</a></h4>
<h4 id="队列的最大值-解答">59队列的最大值 <a href="https://sbaban.com/jzo59.html">解答</a></h4>
<h4 id="n个骰子的点数-解答">60n个骰子的点数 <a href="https://sbaban.com/jzo60.html">解答</a></h4>
<h4 id="扑克牌中的顺子-解答">61扑克牌中的顺子 <a href="https://sbaban.com/jzo61.html">解答</a></h4>
<h4 id="圆圈中最后剩下的数字-解答">62圆圈中最后剩下的数字 <a href="https://sbaban.com/jzo62.html">解答</a></h4>
<h4 id="股票的最大利润-解答">63股票的最大利润 <a href="https://sbaban.com/jzo63.html">解答</a></h4>
<h4 id="求12n-解答-待更新">64求1+2+n <a href="https://sbaban.com/jzo64.html">解答</a> ===待更新 ==</h4>
<h4 id="不用加减乘除做加法-解答">65不用加减乘除做加法 <a href="https://sbaban.com/jzo65.html">解答</a></h4>
<h4 id="构建乘积数组-解答">66构建乘积数组 <a href="https://sbaban.com/jzo66.html">解答</a></h4>
<h4 id="字符串转成整数-解答">67字符串转成整数 <a href="https://sbaban.com/jzo67.html">解答</a></h4>
<h4 id="删除链表中重复的结点-解答">删除链表中重复的结点 <a href="https://sbaban.com/jz20191207.html">解答</a></h4>
<h4 id="字符流中第一个不重复的字符-解答">字符流中第一个不重复的字符 <a href="https://sbaban.com/jz20191205char.html">解答</a></h4>
<hr>
<p>2020/3/24 整本书看完了，希望自己能找到一份满意的工作</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-11旋转数组的最小数字-python</title>
    <url>/jzo11.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p>旋转后分成两个递增的数组，目标是找到分界处的元素；</p>
<p>如果[low]&lt;[high]: 说明旋转了0个元素，最小值就是low；</p>
<p>如果[low]&gt;[high]:</p>
<p>​ 如果[mid]&gt;=[low]:说明最小值在【mid，high】之间，让low=mid；</p>
<p>​ 如果[mid]&lt;[low]:说明最小值在【low，mid】之间，让high=mid；</p>
<p>​ 当low和high相差1时，比较大小，return 小的值。（最终第一个指针将指向前面数组的最后一个元素，第二个指针指向后面数组中的第一个元素，即指向两个相邻的元素，而第二个指针指向的刚好是最小的元素，这就是循环的结束条件。）</p>
<p><strong>特殊情况：</strong>｛1，0，1，1，1｝ 和 ｛1，1， 1，0，1｝ 都可以看成是递增排序数组｛0，1，1，1，1｝的旋转。</p>
<p>这种情况下我们无法继续用上一道题目的解法，去解决这道题目。</p>
<p>因为在这两个数组中，第一个数字，最后一个数字，中间数字都是1。</p>
<p>第一种情况下，中间数字位于后面的子数组，第二种情况，中间数字位于前面的子数组。</p>
<p>​ 因此当两个指针指向的数字和中间数字相同的时候，我们无法确定中间数字1是属于前面的子数组还是属于后面的子数组，也就无法移动指针来缩小查找的范围。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span>(<span class="params">self, rotateArray</span>):</span></span><br><span class="line">        length = <span class="built_in">len</span>(rotateArray)</span><br><span class="line">        <span class="keyword">if</span> length == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = length -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> rotateArray[low] &gt;= rotateArray[high]:</span><br><span class="line">            <span class="comment">#保证是旋转的数组</span></span><br><span class="line">            <span class="keyword">if</span> high - low ==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> rotateArray[high]</span><br><span class="line">            mid = (low +high)//<span class="number">2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> rotateArray[low] == rotateArray[mid] \</span><br><span class="line">                    <span class="keyword">and</span> rotateArray[high] == rotateArray[mid]:</span><br><span class="line">            <span class="comment">#[low][mid][high]相等，二分查找无法判断，只能顺序比较大小</span></span><br><span class="line">                mymin = rotateArray[low]</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(low+<span class="number">1</span>, high+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> mymin &gt; rotateArray[i]:</span><br><span class="line">                        mymin = rotateArray[i]</span><br><span class="line">                <span class="keyword">return</span> mymin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> rotateArray[mid] &gt;= rotateArray[low]:</span><br><span class="line">                low = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rotateArray[<span class="number">0</span>]</span><br></pre></td></tr></tbody></table></figure>
<p><strong>最初想法：</strong></p>
<p>如果一位元素比其上一位元素小，就说明它是分界，返回它即可。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span>(<span class="params">self, rotateArray</span>):</span></span><br><span class="line">        length = <span class="built_in">len</span>(rotateArray)</span><br><span class="line">        <span class="keyword">if</span> length == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            <span class="keyword">if</span> i+<span class="number">1</span> &lt; length <span class="keyword">and</span> rotateArray[i] &gt; rotateArray[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> rotateArray[i+<span class="number">1</span>]</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> rotateArray[<span class="number">0</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>虽然用二分查找能提高效率，但在下觉得这道题使用二分查找有点绕，要考虑的情况有点多，实际应用中我可能更倾向于顺序查找。</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-12矩阵中的路径-python</title>
    <url>/jzo12.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p>考查回溯法</p>
<p>从矩阵的左上角扫描到右下角，</p>
<p>当矩阵中坐标为(row,col)的格子和路径字符中path[i]的字符一样时，</p>
<p>​ 则从上下左右四个相邻的格子(row-1.col), (row+1,col), (row,col-1), (row,col+1)中去找path[i+1]的字符，</p>
<p>​ 若这四个格子都没有path[i]的字符，则回溯到上一个字符path[i-1]和上一个格子。</p>
<p>若矩阵中坐标为(row,col)的格子和路径字符中path[i]的字符不一样，换下一个格子。</p>
<p>回溯模版方法，其实没必要用curpath记录路径，只是为了和模版统一而已。与模版不同的是要做剪枝，但剪枝后<code>#</code>无法恢复，如果不改变原数组也可以用一个辅助空间visited二维列表</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span>(<span class="params">self, board, word</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :type word: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#首先找到所有开头字符的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">i,j,curpath</span>):</span></span><br><span class="line">            <span class="comment">#结束条件</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(curpath) == <span class="built_in">len</span>(word):</span><br><span class="line">                <span class="keyword">nonlocal</span> res</span><br><span class="line">                res = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            choices = [[i-<span class="number">1</span>,j],[i+<span class="number">1</span>,j],[i,j-<span class="number">1</span>],[i,j+<span class="number">1</span>]]<span class="comment">#上下左右四个选项</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> choice <span class="keyword">in</span> choices:</span><br><span class="line">                <span class="comment">#判断这个选项能不能选，数组越界，重复访问，字符不对应</span></span><br><span class="line">                <span class="keyword">if</span> ( <span class="number">0</span>&lt;=choice[<span class="number">0</span>]&lt;=<span class="built_in">len</span>(board)-<span class="number">1</span> ) <span class="keyword">and</span> <span class="number">0</span>&lt;=choice[<span class="number">1</span>]&lt;=<span class="built_in">len</span>(board[<span class="number">0</span>])-<span class="number">1</span> \</span><br><span class="line">                        <span class="keyword">and</span> (board[choice[<span class="number">0</span>]][choice[<span class="number">1</span>]] == word[<span class="built_in">len</span>(curpath)]):</span><br><span class="line">                    temp = board[choice[<span class="number">0</span>]][choice[<span class="number">1</span>]]<span class="comment">#记录当前节点的来路</span></span><br><span class="line">                    board[choice[<span class="number">0</span>]][choice[<span class="number">1</span>]] = <span class="string">'#'</span> <span class="comment">#将来路节点设为#，防止其重复访问</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">#加入选择</span></span><br><span class="line">                    curpath.append(temp)</span><br><span class="line">                    <span class="comment">#backtrack,注意这里要剪枝，我们只要一条路径就行，没必要将上下左右四个选项都走一遍（注意区分排列子集和组合）</span></span><br><span class="line">                    <span class="keyword">if</span> backtrack(choice[<span class="number">0</span>],choice[<span class="number">1</span>],curpath.copy()):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">                    <span class="comment">#撤销选择</span></span><br><span class="line">                    curpath.pop()</span><br><span class="line">                    board[choice[<span class="number">0</span>]][choice[<span class="number">1</span>]] = temp <span class="comment">#恢复来路节点</span></span><br><span class="line"></span><br><span class="line">        res = <span class="literal">False</span></span><br><span class="line">        <span class="comment">#从左上角到右下角每个元素：</span></span><br><span class="line">        i,j  = <span class="number">0</span>,-<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(-<span class="number">1</span>,<span class="built_in">len</span>(board[<span class="number">0</span>])):<span class="comment">#因为直接是上下左右，不能包含自身，所以要特殊处理root</span></span><br><span class="line">                backtrack(i,j,curpath=[])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        backtrack(i, j, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>
<p>《剑指offer》方法，or有剪枝的作用</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPath</span>(<span class="params">self, matrix, rows, cols, path</span>):</span></span><br><span class="line">        <span class="comment"># mtrix是一维的list，表示的是矩阵</span></span><br><span class="line">        <span class="comment"># path是字符串</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> <span class="keyword">or</span> rows&lt;=<span class="number">0</span> <span class="keyword">or</span> cols&lt;=<span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(path)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        visited = [<span class="literal">False</span>] * (rows*cols) <span class="comment"># 记录已访问过的矩阵元素</span></span><br><span class="line">        pathLength = <span class="number">0</span> <span class="comment"># 当前已对应的路径长度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#从矩阵的左上角到右下角</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">                <span class="keyword">if</span> self.hasPashCore(matrix,rows,cols,row,col,path,pathLength,visited):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPashCore</span>(<span class="params">self,matrix,rows,cols,row,col,path,pathLength,visited</span>):</span></span><br><span class="line">        <span class="keyword">if</span> pathLength == <span class="built_in">len</span>(path):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        myflag = <span class="literal">False</span></span><br><span class="line">        myindex = row*cols+col</span><br><span class="line">        <span class="comment"># 当前格子与当前字符对应：</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span>&lt;=row&lt;rows <span class="keyword">and</span> <span class="number">0</span>&lt;=col&lt;cols <span class="keyword">and</span> path[pathLength]==matrix[myindex] <span class="keyword">and</span> visited[myindex]==<span class="literal">False</span>:</span><br><span class="line">            pathLength += <span class="number">1</span></span><br><span class="line">            visited[myindex] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 检查当前格子的上下左右四个格子是否与下一个字符对应</span></span><br><span class="line">            myflag = self.hasPashCore(matrix,rows,cols,row-<span class="number">1</span>,col,path,pathLength,visited)\</span><br><span class="line">                <span class="keyword">or</span> self.hasPashCore(matrix,rows,cols,row+<span class="number">1</span>,col,path,pathLength,visited)\</span><br><span class="line">                <span class="keyword">or</span> self.hasPashCore(matrix,rows,cols,row,col-<span class="number">1</span>,path,pathLength,visited)\</span><br><span class="line">                <span class="keyword">or</span> self.hasPashCore(matrix,rows,cols,row,col+<span class="number">1</span>,path,pathLength,visited)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#若上下左右不对应， 回退到上一个字符与上一个格子</span></span><br><span class="line">            <span class="keyword">if</span> myflag == <span class="literal">False</span>:</span><br><span class="line">                pathLength -= <span class="number">1</span></span><br><span class="line">                visited[myindex] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> myflag</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>这题有点难搞啊。。。</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-13机器人的运动范围-python</title>
    <url>/jzo13.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p>k=0, [0,0]</p>
<p>k=1, [0,0],[0,1],[1,0],[0,10],[10,0]...</p>
<p>最初的想法：硬算</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> m:</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> n:</span><br><span class="line">    <span class="keyword">if</span> i的数位之和+j的数位之和 &lt;= k:	则mysum++</span><br></pre></td></tr></tbody></table></figure>
<p>错误：</p>
<p>没有考虑格子的可达性，比如如果[2,3]的上下左右都不符合条件，就不能到达[2,3].</p>
<p>改正后代码：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span>(<span class="params">self, threshold, rows, cols</span>):</span></span><br><span class="line">        <span class="keyword">if</span> threshold &lt;<span class="number">0</span> <span class="keyword">or</span> rows&lt;=<span class="number">0</span> <span class="keyword">or</span> cols&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        mycount = <span class="number">0</span></span><br><span class="line">        visited = [<span class="literal">False</span>]*rows*cols</span><br><span class="line">        visited[<span class="number">0</span>]=<span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">                <span class="keyword">if</span> self.shuwei(i) + self.shuwei(j) &lt;= threshold:</span><br><span class="line">                    <span class="keyword">if</span> self.hasPath(visited, rows, cols, i, j):               </span><br><span class="line">                      <span class="comment">#检测是否能到达[i,j]这个格子</span></span><br><span class="line">                        visited[i * cols + j] = <span class="literal">True</span></span><br><span class="line">                        mycount += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> mycount+<span class="number">1</span> <span class="comment"># 一开始的[0,0]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPath</span>(<span class="params">self,visited,rows,cols,row,col</span>):</span></span><br><span class="line">        <span class="comment"># 检查上下左右格子有没有路径</span></span><br><span class="line">        <span class="keyword">if</span> (row-<span class="number">1</span>&gt;=<span class="number">0</span> <span class="keyword">and</span> visited[(row-<span class="number">1</span>)*cols+col] == <span class="literal">True</span>) \</span><br><span class="line">                <span class="keyword">or</span> (row+<span class="number">1</span>&lt;rows <span class="keyword">and</span> visited[(row+<span class="number">1</span>)*cols+col] == <span class="literal">True</span>) \</span><br><span class="line">                <span class="keyword">or</span> (col-<span class="number">1</span>&gt;=<span class="number">0</span> <span class="keyword">and</span> visited[row*cols+col-<span class="number">1</span>] == <span class="literal">True</span>) \</span><br><span class="line">                <span class="keyword">or</span> (col+<span class="number">1</span>&lt;cols <span class="keyword">and</span> visited[row*cols+col+<span class="number">1</span>] == <span class="literal">True</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shuwei</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="comment">#求x的数位之和，如123的数位之和为1+2+3=6</span></span><br><span class="line">        stringx = <span class="built_in">str</span>(x)</span><br><span class="line">        mysum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> stringx:</span><br><span class="line">             mysum += <span class="built_in">int</span>(i)</span><br><span class="line">        <span class="keyword">return</span> mysum</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-14剪绳子-python</title>
    <url>/jzo14.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p>动态规划</p>
<p><span class="math display">\[f(n) = max(f(i)*f(n-i))\]</span></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#使用动态规划模版 https://sbaban.com/dp20.html</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        dp = [<span class="number">1</span>]*(n+<span class="number">1</span>)<span class="comment">#建立dp数组</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span><span class="comment">#初始化base</span></span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span> <span class="comment">#2只能分成1和1，但实际上不分解更大</span></span><br><span class="line">        dp[<span class="number">3</span>] = <span class="number">3</span> <span class="comment">#3分成2和1最大，但实际上不分解最大，</span></span><br><span class="line">        <span class="comment">#进行状态转移</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>,n+<span class="number">1</span>):<span class="comment">#对每个状态4～n</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,i//<span class="number">2</span>+<span class="number">1</span>):<span class="comment">#对每种选择</span></span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i],dp[i-j]*dp[j])<span class="comment">#状态转移方程</span></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>找规律</p>
<p>1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 1 | 1,1 | 1,2 | 2,2 | 2,3 | 3,3 | 3,4 | 2,3,3 1 | 令f(2)=2 | 令f(3)=3 | 1·f(3) | 2·f(3) | 3·f(3) | 3·f(4) | 2·f(6)</p>
<p>由于2，3都比分后的乘积大，所以比3大的数字来说可以不拆分2和3，所以我们令f(2)=2,f(3)=3.</p>
<p><span class="math inline">\(f(4) = max(1f(3), 2f(2) , 3f(1))\)</span></p>
<p><span class="math inline">\(f(5) = max(1f(4), 2f(3) , 3f(2)) , 4f(1)\)</span></p>
<p><span class="math inline">\(f(6) = max(1f(5), 2f(4) , 3f(3) , 4f(2) , 5f(1))\)</span></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cutRope</span>(<span class="params">self, number</span>):</span></span><br><span class="line">        <span class="keyword">if</span> number == <span class="number">1</span> <span class="keyword">or</span> number == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> number == <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        scorelist = [<span class="number">1</span>]*(number+<span class="number">1</span>)</span><br><span class="line">        scorelist[<span class="number">2</span>], scorelist[<span class="number">3</span>] = <span class="number">2</span>,<span class="number">3</span> <span class="comment">#对2和3特殊处理</span></span><br><span class="line">        maxscore = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>,number+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,i):</span><br><span class="line">                temp = j * scorelist[i-j]</span><br><span class="line">                <span class="keyword">if</span> temp &gt; maxscore:</span><br><span class="line">                    maxscore = temp</span><br><span class="line">            scorelist[i] = maxscore</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> scorelist[number]</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>改进：</p>
<p>f(n) = max(f(i)·f(n-i)), 其中，0&lt;i&lt;n.</p>
<p>缩小for循环</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cutRope</span>(<span class="params">self, number</span>):</span></span><br><span class="line">        <span class="keyword">if</span> number == <span class="number">1</span> <span class="keyword">or</span> number == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> number == <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        scorelist = [<span class="number">1</span>]*(number+<span class="number">1</span>)</span><br><span class="line">        scorelist[<span class="number">2</span>], scorelist[<span class="number">3</span>] = <span class="number">2</span>,<span class="number">3</span> <span class="comment">#对2和3特殊处理</span></span><br><span class="line">        maxscore = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>,number+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,i//<span class="number">2</span>+<span class="number">1</span>):<span class="comment">#改进</span></span><br><span class="line">                temp = scorelist[j] * scorelist[i-j]<span class="comment"># 改进</span></span><br><span class="line">                <span class="keyword">if</span> temp &gt; maxscore:</span><br><span class="line">                    maxscore = temp</span><br><span class="line">            scorelist[i] = maxscore</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> scorelist[number]</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-15二进制中1的个数-python</title>
    <url>/jzo15.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p>首先介绍位运算：左移相当于乘以2，右移相当于除以2.</p>
<p>n&lt;&lt;m,n是正数或负数时，把n左移m位，最左边的m位被丢弃，最右边补m个0；</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">00001010&lt;&lt;2=00101000</span><br></pre></td></tr></tbody></table></figure>
<p>n&gt;&gt;m，n是正数时，把n右移m位，最右边的m位被丢弃，最左边补n个0。</p>
<p>​ n是负数时，把n右移m位，最右边的m位被丢弃，最左边补n个1.</p>
<p>最初想法：</p>
<p>将数字转为二进制数字，然后统计1的个数。</p>
<p>如何计算二进制？ 直接调用python函数，bin(7) = 0b111</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">除<span class="number">2</span>求余，逆序排序</span><br><span class="line">用十进制数除以<span class="number">2</span>，可以得到一个商和余数；将余数保存起来，用商再去除以二，再得到一个商和余数.</span><br><span class="line">反复进行，直到商小于<span class="number">1</span>时结束；然后将之前所得的余数逆序输出，得到的就是该十进制数的二进制</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BinaryEncode</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="comment">#将n转为二进制，n&gt;0</span></span><br><span class="line">    binarylist=[]</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>):</span><br><span class="line">        binarylist.append(n%<span class="number">2</span>)<span class="comment">#除2求余</span></span><br><span class="line">        n = n//<span class="number">2</span></span><br><span class="line">    print(binarylist[::-<span class="number">1</span>])<span class="comment">#逆序输出</span></span><br><span class="line"></span><br><span class="line">BinaryEncode(<span class="number">11</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>在计算负数的二进制表示时，先转为原码，再反码，最后补玛。</p>
<p>Eg：-9的二进制表示是11110111</p>
<p>9的原码是00001001，反码是11110110，补玛是11110111.（最后一位加1）</p>
<p>书上思路：</p>
<p>当n大于0时，将n与1做与运算（如果最右边数字是1与1与运算结果为1）</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span>(<span class="params">self, n</span>):</span></span><br><span class="line">    mycount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span>  n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            <span class="keyword">if</span> n &amp; <span class="number">1</span>:<span class="comment">#与1做与运算</span></span><br><span class="line">                mycount+=<span class="number">1</span></span><br><span class="line">            n = n&gt;&gt;<span class="number">1</span> <span class="comment">#n右移1位，再进行与运算</span></span><br><span class="line">    <span class="keyword">return</span> mycount</span><br></pre></td></tr></tbody></table></figure>
<p>这个只能解决n大于0的情况，因为n为负数右移m位时，要在最左边补m个1，导致无限循环。</p>
<p>另一种思路：</p>
<p>为避免死循环，不右移数字n，先把n和1与运算，判断最低位是不是1。接着把1左移一位得到2，再和n与运算，判断次低位是不是1…反复将1左移，判断n的其中一位是不是1</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span>(<span class="params">self, n</span>):</span></span><br><span class="line">    mycount = <span class="number">0</span></span><br><span class="line">    flag = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> flag:<span class="comment"># 改成 for _ in range(32):</span></span><br><span class="line">        <span class="keyword">if</span> n&amp;flag:</span><br><span class="line">            mycount+=<span class="number">1</span></span><br><span class="line">        flag = flag&lt;&lt;<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mycount</span><br></pre></td></tr></tbody></table></figure>
<p>在 C/C++ 实现时，负整数溢出后为最大整数，但 Python 数值类型（Numeric Type）不会出现溢出的情况，所以，此时，还需要对边界值进行限定。</p>
<p>第三种思路：</p>
<p>有个规律：整数n减去1后，再和原整数n与运算，会将n最右边的1变成0，那么n的二进制表示有多少个1就可以进行多少次操作。</p>
<p>比如1100，减去1为1011，1100与运算1011得到1000，即1100最右边的1变成了0。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span>(<span class="params">self, n</span>):</span></span><br><span class="line">    mycount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n&lt;<span class="number">0</span>:</span><br><span class="line">        n = n&amp;<span class="number">0xffffffff</span></span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        n = n&amp;(n-<span class="number">1</span>)</span><br><span class="line">        mycount+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> mycount</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">python要使用n &amp; 0xffffffff得到一个负数的补码??这个不太清楚,反正是python的一种机制</span><br></pre></td></tr></tbody></table></figure>
<p>第四种方法：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span>(<span class="params">self, n</span>):</span></span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">        n = n &amp; <span class="number">0xffffffff</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bin</span>(n).count(<span class="string">'1'</span>)</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-16数值的整数次方-python</title>
    <url>/jzo16.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p>考虑要全面，底数和指数大于小于等于0的情况</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Power</span>(<span class="params">self, base, exponent</span>):</span></span><br><span class="line">        result = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> base == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">        <span class="keyword">elif</span> exponent == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> exponent &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(exponent):</span><br><span class="line">                result = result * base</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment">#指数小于0的情况</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">abs</span>(exponent)):</span><br><span class="line">                result = result * base</span><br><span class="line">            result = <span class="number">1</span>/ result</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></tbody></table></figure>
<p>改进：对于大数的<strong>快速幂运算</strong></p>
<p>计算<span class="math inline">\(2^{32}\)</span>时，使用for循环要31次乘法。</p>
<p>转换思路</p>
<p><span class="math inline">\(2^{32}=2^{16}×2^{16}\)</span>,而<span class="math inline">\(2^{16}=2^8×2^8\)</span>，而<span class="math inline">\(2^{8}=2^4×2^4\)</span>，</p>
<p>而<span class="math inline">\(2^{4}=2^2×2^2\)</span>，而<span class="math inline">\(2^{2}=2^1×2^1\)</span>。</p>
<p>​ <span class="math inline">\(a^n=a^{n/2}×a^{n/2}\)</span>,n为偶数</p>
<p>​ <span class="math inline">\(a^n=a^{(n-1)}×a\)</span>,n为奇数</p>
<p><strong>n与1做位与运算判断n的奇偶性</strong>，（n不论正负，n&amp;1==1,n是奇数）</p>
<p><strong>n&gt;&gt;1位右移运算来表示n除以2</strong>，（*4&gt;&gt;1=2）</p>
<p>递归版本</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span>(<span class="params">self, x, n</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: float</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">base,exponent</span>):</span></span><br><span class="line">            <span class="keyword">if</span> base==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> exponent == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> exponent%<span class="number">2</span> ==<span class="number">1</span>:<span class="comment">#是奇数</span></span><br><span class="line">                <span class="keyword">return</span> base*helper(base,exponent-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> exponent%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">                temp = helper(base,exponent/<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">return</span>  temp*temp</span><br><span class="line">        temp = n</span><br><span class="line">        res = helper(x,<span class="built_in">abs</span>(n))</span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> temp &gt;<span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span>/res</span><br></pre></td></tr></tbody></table></figure>
<p><strong>不使用递归:</strong></p>
<p>比如求a的10次方，</p>
<p>10的二进制（1010）的每一位分别看作<span class="math inline">\(a^8,a^4,a^2,a^1\)</span>，那么计算二进制位置为1的数值，即<span class="math inline">\(a^{10} =a^8 · a^2\)</span></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span>(<span class="params">self, x, n</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: float</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> x==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        temp = n</span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        n = <span class="built_in">abs</span>(n)</span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            <span class="keyword">if</span> n&amp;<span class="number">1</span>:<span class="comment">#只有当二进制位末尾是1的时候才计算结果</span></span><br><span class="line">                res = res*x</span><br><span class="line">            x = x*x <span class="comment">#底数的幂次加一</span></span><br><span class="line">            n = n &gt;&gt; <span class="number">1</span> <span class="comment">#n的二进制向右移动一位</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> temp &gt;<span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span>/res</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-17打印从1到最大的n位数-python</title>
    <url>/jzo17.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p>输入数字n,按顺序打印出从1到最大的n位十进制数，比如输入3，则打印出1、2、3一直到最大的3位数999.</p>
<p>这一题主要考虑大数，用字符串模拟加法。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printOneToMaxOfNDigits</span>(<span class="params">self,n</span>):</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        number=[<span class="string">'0'</span>]*(n+<span class="number">1</span>)</span><br><span class="line">        number[-<span class="number">1</span>] = <span class="number">1</span> <span class="comment">#为了让第一次输出1</span></span><br><span class="line">        <span class="keyword">while</span> number[<span class="number">0</span>]!=<span class="string">'1'</span>:<span class="comment">#若首位为1，说明溢出了。我们只要1.,9..9</span></span><br><span class="line">            self.printNumber(number)</span><br><span class="line">            print(<span class="string">","</span>)</span><br><span class="line">            self.increment(number)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment</span>(<span class="params">self,number</span>):</span></span><br><span class="line">        <span class="comment">#实现字符串加1</span></span><br><span class="line">        n = <span class="built_in">len</span>(number)-<span class="number">1</span> <span class="comment">#从最后一位开始</span></span><br><span class="line">        <span class="keyword">while</span> n &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="comment">#非进位的情况下加1</span></span><br><span class="line">            nsum = <span class="built_in">int</span>(number[n])+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nsum == <span class="number">10</span>:<span class="comment">#要进位</span></span><br><span class="line">                number[n] = <span class="string">'0'</span> <span class="comment">#当前位归零</span></span><br><span class="line">                n -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#不进位</span></span><br><span class="line">                number[n] = <span class="built_in">str</span>(nsum)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printNumber</span>(<span class="params">self,number</span>):</span></span><br><span class="line">        <span class="comment">#输出当前number[],而且前面的0不输出</span></span><br><span class="line">        <span class="comment">#如['0','6']输出6</span></span><br><span class="line">        beginIsZero = <span class="literal">True</span><span class="comment">#前面是0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(number)):</span><br><span class="line">            <span class="keyword">if</span> number[i] != <span class="string">'0'</span>:</span><br><span class="line">                beginIsZero = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> beginIsZero == <span class="literal">False</span>:</span><br><span class="line">                print(number[i],end=<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">sol = Solution()</span><br><span class="line">sol.printOneToMaxOfNDigits(<span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure>
<p><strong>方法二</strong>，换种思路，到最大的n位数字，就是一个全排列</p>
<p>以n为3为例，</p>
<p>百分位排0，十分位排0，个位数排0；</p>
<p>百分位排0，十分位排0，个位数排1；输出1</p>
<p>百分位排0，十分位排0，个位数排2，输出2。。。</p>
<p>可以采用递归</p>
<p>百分位全排列0-9</p>
<p>​ 十分位全排列0-9</p>
<p>​ 个分位全排列0-9，每排一次print一次</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printOneToMaxOfNDigits</span>(<span class="params">self,n</span>):</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">pailie</span>(<span class="params">curpath,choices</span>):</span></span><br><span class="line">            <span class="comment">#结束条件</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(curpath) == <span class="number">2</span>:</span><br><span class="line">                res.append(curpath)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment">#for 选择 in 选择列表：</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(choices)):</span><br><span class="line">                <span class="comment">#有放回的排列，不必判断choice是否已经选择过</span></span><br><span class="line">                <span class="comment">#加入选择</span></span><br><span class="line">                curpath.append(choices[i])</span><br><span class="line">                <span class="comment">#backtrack（）</span></span><br><span class="line">                pailie(curpath.copy(),choices)</span><br><span class="line">                <span class="comment">#撤销选择</span></span><br><span class="line">                curpath.pop()</span><br><span class="line">        pailie([],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>])</span><br><span class="line">        <span class="keyword">for</span> elem <span class="keyword">in</span> res:</span><br><span class="line">            self.printNumber(elem)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printNumber</span>(<span class="params">self,number</span>):</span></span><br><span class="line">        <span class="comment">#输出当前number[],而且前面的0不输出</span></span><br><span class="line">        <span class="comment">#如['0','6']输出6</span></span><br><span class="line">        beginIsZero = <span class="literal">True</span><span class="comment">#前面是0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(number)):</span><br><span class="line">            <span class="keyword">if</span> number[i] != <span class="number">0</span>:</span><br><span class="line">                beginIsZero = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> beginIsZero == <span class="literal">False</span>:</span><br><span class="line">                print(number[i],end=<span class="string">""</span>)</span><br><span class="line">        print(<span class="string">","</span>)</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-18O(1)复杂度删除链表的结点-python</title>
    <url>/jzo18.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p>重点是要求在O(1)的时间复杂度内。</p>
<p>a,b,c,d,i,j,k,None 假如要删除i，</p>
<p>方法一：</p>
<p>单向链表常规的做法是从头结点顺序遍历查找要删除的结点，同时记录它的前一个的节点，然后让d-next=j来删除i，O（n）</p>
<p>方法二：不需要得到被删除结点的前一个结点</p>
<p>先将j（i的下一个结点）的内容复制到i（就是把i.elem=j.elem），再把i的指针指向k，这样就达到了删除节点i的目的。</p>
<p>但是这个方法基于一个假设，要删除的结点不是最后一个非None的结点。若要删除的结点是最后一个非None结点，那只能用方法一了。</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-19正则表达式匹配-python</title>
    <url>/jzo19.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">请实现一个函数用来匹配包括<span class="string">'.'</span>和<span class="string">'*'</span>的正则表达式。</span><br><span class="line"></span><br><span class="line">模式中的字符<span class="string">'.'</span>表示任意一个字符，</span><br><span class="line">而<span class="string">'*'</span>表示它前面的字符可以出现任意次（包含<span class="number">0</span>次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。</span><br><span class="line"></span><br><span class="line">例如，字符串<span class="string">"aaa"</span>与模式<span class="string">"a.a"</span>和<span class="string">"ab*ac*a"</span>匹配，但是与<span class="string">"aa.a"</span>和<span class="string">"ab*a"</span>均不匹配。</span><br></pre></td></tr></tbody></table></figure>
<p>脑壳疼</p>
<ul>
<li><p>1当模式中的下一个字符不是星时，pattern[i+1] != 星​： 1.1、如果字符串第一个字符和模式中的第一个字符相匹配，包括str[i]=pattern[i] or pattern[i]=点。那么字符串和模式都后移一个字符，然后匹配剩余的。</p>
<p>1.2、如果 字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。</p></li>
<li><p>2当模式中的下一个字符是*时，pattern[i+1]==星，比较复杂</p>
<p>2.1若当前字符匹配，</p>
<p>字符串向后移动一个字符，模式两种选择</p>
<p>​ 2.1.1模式向后移动两个字符，比较<strong>str[i+1]</strong>和<strong>pattern[i+2]</strong></p>
<p>​ 2.1.2 模式保持不变，比较<strong>str[i+1]</strong>和<strong>pattern[i]</strong></p>
<p>字符串不动，模式向后移动两个字符，比较断<strong>str[i]</strong>和<strong>pattern[i+2]</strong></p>
<p>2.2若当前字符不匹配，则星只能表示pattern[i]出现了0次，等价于判断<strong>str[i]</strong>和<strong>pattern[i+2]</strong></p></li>
</ul>
<p>注：python切片不会越界</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s, pattern都是字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">match</span>(<span class="params">self, s, pattern</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s)==<span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(pattern)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s)&gt;<span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(pattern)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#模式的下一个字符是*</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(pattern)&gt;<span class="number">1</span> <span class="keyword">and</span> pattern[<span class="number">1</span>]==<span class="string">'*'</span>:</span><br><span class="line">            <span class="comment">#若字符串第一个字符跟模式第一个字符匹配(相等或匹配到".")，可以有3种匹配方式：</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(s)&gt;<span class="number">0</span> <span class="keyword">and</span> (s[<span class="number">0</span>]==pattern[<span class="number">0</span>] <span class="keyword">or</span> pattern[<span class="number">0</span>]==<span class="string">'.'</span>):</span><br><span class="line">                <span class="keyword">return</span> self.match(s[<span class="number">1</span>:],pattern[<span class="number">2</span>:]) <span class="keyword">or</span> self.match(s[<span class="number">1</span>:],pattern) <span class="keyword">or</span> self.match(s,pattern[<span class="number">2</span>:])</span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#不匹配</span></span><br><span class="line">                <span class="keyword">return</span> self.match(s,pattern[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line">        <span class="comment">#模式的下一个字符不是*</span></span><br><span class="line">        <span class="comment">#1、如果字符串第一个字符和模式中的第一个字符匹配(相等或匹配到".")，</span></span><br><span class="line">        <span class="comment">#那么字符串和模式都后移一个字符，然后匹配剩余的</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s)&gt;<span class="number">0</span> <span class="keyword">and</span> (s[<span class="number">0</span>]==pattern[<span class="number">0</span>] <span class="keyword">or</span> pattern[<span class="number">0</span>]==<span class="string">'.'</span>):</span><br><span class="line">            <span class="keyword">return</span> self.match(s[<span class="number">1</span>:],pattern[<span class="number">1</span>:])</span><br><span class="line">        <span class="comment">#2、如果字符串第一个字符和模拟中的第一个字符相不匹配，直接返回false</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-20表示数值的字符串-python</title>
    <url>/jzo20.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。</span><br><span class="line"></span><br><span class="line">例如，字符串<span class="string">"+100"</span>,<span class="string">"5e2"</span>,<span class="string">"-123"</span>,<span class="string">"3.1416"</span>，<span class="string">"2.e3"</span>,<span class="string">".123”,"</span><span class="number">233.</span><span class="string">"和"</span>-<span class="number">1E-16</span><span class="string">"都表示数值。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> 但"</span>12e<span class="string">","</span>e12<span class="string">","</span>.e12<span class="string">","</span>1a3<span class="number">.14</span><span class="string">","</span><span class="number">1.2</span><span class="number">.3</span><span class="string">","</span>+-<span class="number">5</span><span class="string">"和"</span><span class="number">12e+4</span><span class="number">.3</span><span class="string">"都不是。</span></span><br></pre></td></tr></tbody></table></figure>
<p>表示数值的字符串遵循模式：</p>
<p>A【.【B】】【e|EC】 或者 .B【e|EC】 即<code>+数字.数字e+数字</code></p>
<p>A表示小数点前的数字，B是小数点后的数字，C为e或E的指数【】表示可选,|表示或</p>
<p>A和C都可能是以正负号开头的0-9的数位串，B也是0-9的数位串，但不能有正负号。</p>
<p>以<span class="math inline">\(123.45e+6\)</span>为例，A是123，B是45，C是+6</p>
<p>判断一个字符串是否符合上述模式，尽可能多地扫描0-9数位（有可能在起始处含正负号），即表示A的部分。若遇到小数点，则开始扫描表示B的部分。若遇到e或E，则开始扫描表示C的部分。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.index = <span class="number">0</span> <span class="comment">#用来同步索引</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumeric</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        length = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">if</span> length == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        isNumericFlag = self.scanInteger(s)<span class="comment">#首先是否存在A部分</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.index &lt; length:</span><br><span class="line">            <span class="comment">#若出现小数点，则接下来是小数部分</span></span><br><span class="line">            <span class="keyword">if</span> s[self.index] == <span class="string">'.'</span>:</span><br><span class="line">                <span class="keyword">if</span> self.index &lt; length-<span class="number">1</span>:<span class="comment">#考虑12.的情况</span></span><br><span class="line">                    self.index += <span class="number">1</span></span><br><span class="line">                    isNumericFlag = self.scanUnsignedInteger(s) <span class="keyword">or</span> isNumericFlag</span><br><span class="line">                    <span class="comment">#用or的原因是小数点前后可以无整数部分，如.12或12.或12.12</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.index &lt; length:</span><br><span class="line">            <span class="comment">#若出现e或者E，则接下来是指数部分</span></span><br><span class="line">            <span class="comment"># print("dd",self.index)</span></span><br><span class="line">            <span class="keyword">if</span> s[self.index]==<span class="string">'e'</span> <span class="keyword">or</span> s[self.index]==<span class="string">'E'</span>:</span><br><span class="line">                <span class="keyword">if</span> self.index &lt; length-<span class="number">1</span>:<span class="comment">#考虑12e的情况</span></span><br><span class="line">                    self.index += <span class="number">1</span></span><br><span class="line">                    isNumericFlag = self.scanInteger(s) <span class="keyword">and</span> isNumericFlag</span><br><span class="line">                    <span class="comment">#用and的原因是e前后必须有数字，可以带正负号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> isNumericFlag <span class="keyword">and</span> self.index==length:</span><br><span class="line">            <span class="comment">#整个字符串扫描完毕并且到目前为止是正确的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">scanUnsignedInteger</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="comment">#扫描字符串中0-9的位数，直到遇到非数字,用于找B</span></span><br><span class="line">        temp = self.index</span><br><span class="line">        length = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">while</span>(self.index&lt;length <span class="keyword">and</span> s[self.index]&gt;=<span class="string">'0'</span> <span class="keyword">and</span> s[self.index]&lt;=<span class="string">'9'</span>):</span><br><span class="line">            self.index += <span class="number">1</span></span><br><span class="line">        <span class="comment">#s中存在数字就返回true</span></span><br><span class="line">        <span class="keyword">return</span> self.index &gt; temp</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">scanInteger</span>(<span class="params">self,s</span>):</span></span><br><span class="line">        <span class="comment">#扫描字符串中可能以正负号开始的0-9的位数，直到遇到非数字</span></span><br><span class="line">        <span class="comment">#用于找A或C</span></span><br><span class="line">        <span class="keyword">if</span> s[self.index]==<span class="string">'+'</span> <span class="keyword">or</span> s[self.index]==<span class="string">'-'</span>:</span><br><span class="line">            self.index += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.scanUnsignedInteger(s)</span><br></pre></td></tr></tbody></table></figure>
<p><strong>方法二：</strong></p>
<p>利用Python中的float强转，如果可以那么它是一个合法的数值的字符串，否则不是。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumeric</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">float</span>(s)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>方法三：</strong></p>
<p>有限状态机</p>
<p>RE：https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution/que-ding-you-xian-zi-dong-ji-dfa-by-justyou/</p>
<p>自己图漏了一个状态，懒得改了，待补充。</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-21调整数组顺序使奇数位于偶数前面-python</title>
    <url>/jzo21.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
<p>第一想法遍历数组，第一次取出奇数放入新数组，并将原数组的奇数删除，然后将剩下的原数组接到新数组后。</p>
<p>书上的最笨思路是遍历数组，遇到偶数将其之后的元素往前移动，在末尾会留出一空位来，将这个偶数放在末尾。</p>
<p>方法一：</p>
<p>题目要求奇数在偶数前面，也就是说，在扫描整个数组的时候，若发现偶数在技术前面，就交换顺序，交换之后就符合题目要求了。</p>
<p>可以设立两个游标，第一个游标从头开始向后移动指向偶数，第二个游标初始指向奇数从末尾开始向前移动，交换奇偶位置。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span>(<span class="params">self, array</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(array) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        startPos,endPos = <span class="number">0</span>,<span class="built_in">len</span>(array)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> startPos &lt; endPos:</span><br><span class="line">            print(array)</span><br><span class="line">            <span class="keyword">if</span> array[startPos]&amp;<span class="number">1</span>==<span class="number">0</span> <span class="keyword">and</span> array[endPos]&amp;<span class="number">1</span>==<span class="number">1</span>:</span><br><span class="line">                array[startPos],array[endPos] = array[endPos],array[startPos]</span><br><span class="line">            <span class="keyword">elif</span> array[startPos]&amp;<span class="number">1</span>==<span class="number">1</span>:<span class="comment">#是奇数</span></span><br><span class="line">                startPos += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> array[endPos]&amp;<span class="number">1</span>==<span class="number">0</span>:</span><br><span class="line">                endPos -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> array</span><br></pre></td></tr></tbody></table></figure>
<p>但是这个方法不能保证相对位置不变。</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-22链表中倒数第K个结点-python</title>
    <url>/jzo22.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p>第一想法:</p>
<p>走两遍，第一次统计链表中结点的个数，第二次找到第n-k+1个结点</p>
<p>要求只遍历一次怎么做？</p>
<p>两个指针，保持k-1的距离。第一个指针先向前走k-1个结点，第二个指针再走。当第一个指针到达尾结点的时候，第二个指针指向倒数第K个结点</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindKthToTail</span>(<span class="params">self, head, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> k&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        firstPos = head</span><br><span class="line">        secondPos = head</span><br><span class="line">        length = <span class="number">1</span></span><br><span class="line">        firstKFlag = <span class="literal">False</span> <span class="comment">#firstpos已经先走了k-1的标志</span></span><br><span class="line">        <span class="keyword">while</span> firstPos.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># K取值合理</span></span><br><span class="line">            <span class="keyword">if</span> firstKFlag == <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>):<span class="comment">#firstPos先走k-1个结点</span></span><br><span class="line">                    <span class="keyword">if</span> firstPos.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                        firstPos = firstPos.<span class="built_in">next</span></span><br><span class="line">                        length += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:<span class="comment">#k大了</span></span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                firstKFlag = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            firstPos = firstPos.<span class="built_in">next</span></span><br><span class="line">            secondPos = secondPos.<span class="built_in">next</span></span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> length &lt; k:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">return</span> secondPos</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-23链表中环的入口节点-python</title>
    <url>/jz20191206.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p>最初思路：遍历，对已访问的结点做个标记，但不知道在不改变原链表的情况下怎么做标记. 书上的思路：例子见P139 step1：判断是否有环； 设立两个游标，一个移动两步，一个一次移动一步，若走的慢的追上走的快的，则有环。若直到末尾也没追上，则无环。</p>
<p>step2：确定环中的结点个数 在stepo1中，两个游标相遇的位置一定在环内，从该位置出发，记录走过的结点数，再次回到该位置就是环中结点的个数。</p>
<p>step3：判断入口结点的位置 假定环中结点的个数为N，设立两个游标，让一个从N处出发，一个从头结点出发，两个游标相遇的结点就是入口结点。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">EntryNodeOfLoop</span>(<span class="params">self, pHead</span>):</span></span><br><span class="line">     <span class="comment">#step1 判断是否有环</span></span><br><span class="line">     p1 = pHead <span class="comment">##两个游标,p1一次一步，p2一次两步</span></span><br><span class="line">     p2 = pHead</span><br><span class="line">     flag = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span> p2 != <span class="literal">None</span> <span class="keyword">and</span> p2.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">         p1 = p1.<span class="built_in">next</span></span><br><span class="line">         p2 = p2.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">         <span class="keyword">if</span> p1 == p2:<span class="comment">#相遇了，有环</span></span><br><span class="line">             temp = p1 <span class="comment">#temp表示相遇的结点</span></span><br><span class="line">             <span class="keyword">while</span> p1.<span class="built_in">next</span> != temp:</span><br><span class="line">                 p1 = p1.<span class="built_in">next</span></span><br><span class="line">                 flag += <span class="number">1</span> <span class="comment">#统计环中结点个数</span></span><br><span class="line">             flag += <span class="number">1</span></span><br><span class="line">             <span class="keyword">break</span></span><br><span class="line">     <span class="keyword">if</span> flag == <span class="number">0</span>:</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">     <span class="keyword">else</span>:</span><br><span class="line">         <span class="comment">#step2确定环中结点的个数</span></span><br><span class="line">         <span class="comment">#step3确定入口位置</span></span><br><span class="line">         p1=pHead</span><br><span class="line">         p2=pHead</span><br><span class="line">         <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(flag):<span class="comment">#让p2先走N个结点</span></span><br><span class="line">             p2 = p2.<span class="built_in">next</span></span><br><span class="line">         <span class="keyword">while</span> p1 != p2:</span><br><span class="line">             p1 = p1.<span class="built_in">next</span></span><br><span class="line">             p2 = p2.<span class="built_in">next</span></span><br><span class="line">         <span class="keyword">return</span> p1</span><br></pre></td></tr></tbody></table></figure>
<p>其他方法： 用一个辅助列表保存已经遍历过的结点 </p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">EntryNodeOfLoop</span>(<span class="params">self, pHead</span>):</span></span><br><span class="line">    saved = []</span><br><span class="line">    <span class="keyword">while</span> pHead != <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> pHead <span class="keyword">in</span> saved:</span><br><span class="line">            <span class="keyword">return</span> pHead</span><br><span class="line">        saved.append(pHead)</span><br><span class="line">        pHead = pHead.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></tbody></table></figure><p></p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-24反转链表-python</title>
    <url>/jzo24.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p>输入一个链表，反转链表并输出反转后链表的头节点。</p>
<p>第一想法:</p>
<p>假设链表位abcdefg</p>
<p>设立三个游标，firstpos，secondpos，curpos，分别指向abc，然后往前走，每往前走一个，secondpos.next=firstpos,直到secondpos走到尾结点。</p>
<p>超时</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ReverseList</span>(<span class="params">self, pHead</span>):</span></span><br><span class="line">     <span class="keyword">if</span> pHead <span class="keyword">is</span> <span class="literal">None</span> :</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">     firstpos,secondpos,curpos = pHead,pHead,pHead</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> curpos.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">         curpos = curpos.<span class="built_in">next</span></span><br><span class="line">     <span class="keyword">if</span> curpos.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">         secondpos = curpos</span><br><span class="line">         curpos = curpos.<span class="built_in">next</span></span><br><span class="line">     firstpos.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span> curpos.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">         secondpos.<span class="built_in">next</span> = firstpos</span><br><span class="line">         firstpos = secondpos</span><br><span class="line">         secondpos = curpos</span><br><span class="line">         curpos = curpos.<span class="built_in">next</span></span><br><span class="line">     </span><br><span class="line">     secondpos.<span class="built_in">next</span> = firstpos</span><br><span class="line">     firstpos = secondpos</span><br><span class="line">     secondpos = curpos</span><br><span class="line">     secondpos.<span class="built_in">next</span> = firstpos</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> secondpos</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>超时了，改进下</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseList</span>(<span class="params">self, pHead</span>):</span></span><br><span class="line">        <span class="keyword">if</span> pHead <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> pHead.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> pHead</span><br><span class="line"></span><br><span class="line">        curpos = pHead</span><br><span class="line">        </span><br><span class="line">        prepos = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> curpos <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            temp = curpos</span><br><span class="line">            curpos = curpos.<span class="built_in">next</span></span><br><span class="line">            temp.<span class="built_in">next</span> = prepos</span><br><span class="line">            prepos = temp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prepos</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-25合并两个排序的链表-python</title>
    <url>/jzo25.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p>第一想法:</p>
<p>新建第3个链表，</p>
<p>选择起始数值小的链表做p1，</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回合并后列表头头节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Merge</span>(<span class="params">self, pHead1, pHead2</span>):</span></span><br><span class="line">        p1pos,p2pos = pHead1,pHead2</span><br><span class="line">        <span class="keyword">if</span> p1pos <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> pHead2</span><br><span class="line">        <span class="keyword">if</span> p2pos <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> pHead1</span><br><span class="line">		<span class="comment">#选择起始值小的作为result的头结点</span></span><br><span class="line">        <span class="keyword">if</span> p1pos.val &lt;= p2pos.val:</span><br><span class="line">            result = p1pos</span><br><span class="line">            p1pos = p1pos.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result = p2pos</span><br><span class="line">            p2pos = p2pos.<span class="built_in">next</span></span><br><span class="line">        resulthead = result</span><br><span class="line">        <span class="keyword">while</span> p1pos <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> p2pos <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> p1pos.val &lt;= p2pos.val:</span><br><span class="line">                result.<span class="built_in">next</span> = p1pos</span><br><span class="line">                p1pos = p1pos.<span class="built_in">next</span></span><br><span class="line">                result = result.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">elif</span> p1pos.val &gt; p2pos.val:</span><br><span class="line">                result.<span class="built_in">next</span> = p2pos</span><br><span class="line">                p2pos = p2pos.<span class="built_in">next</span></span><br><span class="line">                result = result.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p1pos <span class="keyword">is</span> <span class="literal">None</span>:<span class="comment">#连接剩余的结点</span></span><br><span class="line">            result.<span class="built_in">next</span> = p2pos</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.<span class="built_in">next</span> = p1pos</span><br><span class="line">        <span class="keyword">return</span> resulthead</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-26树的子结构-python</title>
    <url>/jzo26.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p>第一想法:</p>
<p>比较两棵树的遍历方法，看B的遍历序列是否包含在A中，（<strong>错误</strong>,跟遍历没关系，思路有问题）</p>
<p><strong>方法：</strong></p>
<p>第一步：在树A中找到和树B的根节点值一样的结点R。</p>
<p>第二步，判断A中以R位根节点的子树是不是和B一样。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">HasSubtree</span>(<span class="params">self, pRoot1, pRoot2</span>):</span></span><br><span class="line">       </span><br><span class="line">        result = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> pRoot1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> pRoot2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment">#用递归的方法遍历，这里用先序遍历。寻找结点R</span></span><br><span class="line">            <span class="keyword">if</span> pRoot1.val == pRoot2.val:</span><br><span class="line">                result = self.doesTree1HasTree2(pRoot1,pRoot2) <span class="comment">#进行第二部判断</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> result == <span class="literal">False</span>: <span class="comment">#继续寻找结点R</span></span><br><span class="line">                result = self.doesTree1HasTree2(pRoot1.left,pRoot2)</span><br><span class="line">            <span class="keyword">if</span> result == <span class="literal">False</span>:</span><br><span class="line">                result = self.doesTree1HasTree2(pRoot1.right,pRoot2)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">doesTree1HasTree2</span>(<span class="params">self,pRoot1, pRoot2</span>):</span></span><br><span class="line">        <span class="comment">#判断以R为结点的子树是不是和树B相同,递归</span></span><br><span class="line">        <span class="keyword">if</span> pRoot2 <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment">#将树B的结点都比较完了，才返回True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">        <span class="keyword">if</span> pRoot1 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> pRoot2.val != pRoot1.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment">#根节点值相等，递归判断各自左右节点的值是否相同</span></span><br><span class="line">        <span class="keyword">return</span> self.doesTree1HasTree2(pRoot1.left,pRoot2.left) <span class="keyword">and</span> self.doesTree1HasTree2(pRoot1.right,pRoot2.right)</span><br><span class="line">        </span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-27二叉树的镜像-python</title>
    <url>/jzo27.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p>第一想法：</p>
<p>遍历树的每个节点，交换左右子树。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Mirror</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="comment">#用递归的方法先序遍历每个结点，交换该结点的左右子树</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        self.swapSubTree(root)</span><br><span class="line">        self.Mirror(root.left)</span><br><span class="line">        self.Mirror(root.right)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapSubTree</span>(<span class="params">self,proot</span>):</span></span><br><span class="line">        <span class="comment">#交换此节点下的左右子树</span></span><br><span class="line">        <span class="keyword">if</span> proot <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        temp = proot.left</span><br><span class="line">        proot.left = proot.right</span><br><span class="line">        proot.right = temp</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-28对称的二叉树-python</title>
    <url>/jzo28.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p>第一想法:</p>
<p>创建原二叉树的镜像二叉树，与原二叉树比较是否相同</p>
<p><strong>方法一：</strong></p>
<p>从根节点递归比较每个节点是否相同</p>
<p>首先判断根节点是否为空，如果为空，那么是对称的。否则，判断左子树和右子树是否互为镜像：</p>
<p>1.两个空树是对称的；</p>
<p>2.非空树和空树无法镜像对称。</p>
<p>3.两个树根节点不同，不能对称。</p>
<p><strong>4.递归判断前者的左子树与后者的右子树是否对称 且 前者的右子树与后者的左子树是否对称；</strong></p>
<p>如果都对称，则两者对称。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetrical</span>(<span class="params">self, pRoot</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.isMirror(pRoot, pRoot)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMirror</span>(<span class="params">self,pleft,pright</span>):</span></span><br><span class="line">        <span class="keyword">if</span> pleft <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> pright <span class="keyword">is</span> <span class="literal">None</span> :</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span> <span class="comment">#两个都空，是对称的</span></span><br><span class="line">        <span class="keyword">elif</span> pleft <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> pright <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span> <span class="comment">#只有一个不是空，是非对称的</span></span><br><span class="line">        <span class="keyword">if</span> pleft.val != pright.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment">#若当前节点相同，则再对称比较左右子树    </span></span><br><span class="line">        <span class="keyword">return</span> self.isMirror(pleft.left,pright.right) <span class="keyword">and</span> self.isMirror(pleft.right,pright.left)</span><br><span class="line">        <span class="comment">#主要是这句没想到啊！</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong>方法二：</strong></p>
<p>自定义一种与先序遍历的对称的遍历方法（即根右左），如果两种遍历得到的序列结果是一样的，那二叉树就是对称的。</p>
<p><img src="https://myimg-1301063374.cos.ap-beijing.myqcloud.com/Snipaste_2020-03-14_19-42-16.png"></p>
<p>比如对第一棵二叉树，其先序遍历为【8,6,5,7,6,7,5】，针对先序遍历的对称遍历为【8,6,5,7,6,7,5】,相同，所以第一棵树是对称的二叉树。</p>
<p>对第二棵二叉树， 其先序遍历为【8,6,5,7,9,7,5】，针对先序遍历的对称遍历为【8,9,5,7,6,7,5】,不相同，所以第二棵树是对称的二叉树。</p>
<p>注意，对第三棵二叉树， 其先序遍历为【777777】，针对先序遍历的对称遍历为【777777】,相同，但第三棵树是对称的二叉树。</p>
<p>如何解决第三种情况？</p>
<p>遍历时，将null也算进去</p>
<p>对第三棵二叉树， 其先序遍历为【7,7,7,N,N,7,N,N,7,7,N,N,N】，针对先序遍历的对称遍历为【7,7,N,7,N,N,7,7,N,N,7,N,N】,相同，但第三棵树是对称的二叉树。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.mylist = []<span class="comment">#存遍历的序列</span></span><br><span class="line">        self.root = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">self, proot</span>):</span></span><br><span class="line">        <span class="comment">#先序遍历,根左右</span></span><br><span class="line">        <span class="keyword">if</span> proot <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.mylist.append(<span class="string">'#'</span>)</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        self.mylist.append(proot.val)</span><br><span class="line">        self.inorder(proot.left)</span><br><span class="line">        self.inorder(proot.right)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderSymetry</span>(<span class="params">self, proot</span>):</span></span><br><span class="line">        <span class="comment">#先序遍历的对称遍历,根右左</span></span><br><span class="line">        <span class="keyword">if</span> proot <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.mylist.append(<span class="string">'#'</span>)</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        self.mylist.append(proot.val)</span><br><span class="line">        self.inorderSymetry(proot.right)</span><br><span class="line">        self.inorderSymetry(proot.left)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetrical</span>(<span class="params">self, pRoot</span>):</span></span><br><span class="line">        self.inorder(pRoot)</span><br><span class="line">        inorderlist = self.mylist</span><br><span class="line">        self.mylist = []</span><br><span class="line">        self.inorderSymetry(pRoot)</span><br><span class="line">        inorderSymetrylist = self.mylist</span><br><span class="line">        <span class="keyword">if</span> inorderlist == inorderSymetrylist:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-29顺时针打印矩阵-python</title>
    <url>/jzo29.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，如【【1,2,3】【4,5,6】【7,8,9】】打印出123698745</p>
<p>第一想法: 没思路</p>
<p><strong>方法：</strong></p>
<p><img src="https://myimg-1301063374.cos.ap-beijing.myqcloud.com/Snipaste_2020-03-14_22-14-43.png"></p>
<p>按照如图4.4,用一个循环来打印矩阵，每次打印矩阵的一个圈。但最后一圈可能退化成只有一行、只有一列，甚至只有一个数字，因此打印这样的一圈就不再需要四步。图4。5是几个退化的例子，打印一圈分别只需要三步、两步甚至一步。</p>
<ul>
<li><p>首先分析外层循环（几圈）结束的条件。</p>
<p>假设这个矩阵的行数是rows，列数是columns，打印第一圈的左上角的坐标是（0,0），第二圈的左上角的坐标是（1,1），以此类推。</p>
<p>我们注意到，左上角的坐标中行标和列标总是相同的。于是可以在矩阵中选取左上角为(start,start)的一圈作为我们分析的目标。</p>
<p>对于一个5×5的矩阵而言，最后一圈只有一个数字，对应的坐标为(2,2).我们发现5&gt;2×2.对于一个6×6的矩阵而言，最后一圈有4个数字，其左上角的坐标仍然为（2,2）。我们发现6&gt;2×2依然成立。于是可以得出，让循环继续的条件是 <strong>columns&gt; startX×2并且rows&gt; startY×2</strong>.所以我们可以用如下的循环来打印矩阵：</p></li>
<li><p>接下来分析如何打印一圈的功能</p>
<p>要仔细分析打印时每一步的前提条件。第一步总是需要的因为打印一圈至少有一步。如果只有一行，那就不用第二步了。也就是需要第二步的前提条件是终止行号大于起始行号。需要第三步打印的前提条件是圈内至少有两行两列，也就是说，除了要求终止行号大于起始行号，还要求终止列号大于起始列号。同理，需要打印第四步的前提条件是至少有三行两列，要求终止行号减去起始行号要大于等于2，同时终止列号大于起始列号。</p></li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># matrix类型为二维列表，需要返回列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printMatrix</span>(<span class="params">self, matrix</span>):</span></span><br><span class="line">        rows, columns = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])<span class="comment">#矩阵的行和列</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> rows&lt;=<span class="number">0</span> <span class="keyword">or</span> columns&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        result = [] <span class="comment">#记录结果</span></span><br><span class="line">        <span class="comment">#控制外层循环的圈数</span></span><br><span class="line">        <span class="keyword">while</span> columns &gt; start*<span class="number">2</span> <span class="keyword">and</span> rows &gt; start*<span class="number">2</span>:</span><br><span class="line">            <span class="comment">#打印最外层矩阵</span></span><br><span class="line">            self.printMatrixInCircle(matrix,columns,rows,start,result)</span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printMatrixInCircle</span>(<span class="params">self,matrix,columns,rows,start,result</span>):</span></span><br><span class="line">        endx,endy = columns-start-<span class="number">1</span>, rows-start-<span class="number">1</span> <span class="comment">#一圈右下角点的坐标</span></span><br><span class="line">        <span class="comment"># 从左到右打印一行</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, endx+<span class="number">1</span>):</span><br><span class="line">            result.append(matrix[start][i])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从上到下打印一列</span></span><br><span class="line">        <span class="keyword">if</span> endy &gt; start: <span class="comment">#终止行号要大于起始行号</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start+<span class="number">1</span>,endy+<span class="number">1</span>):</span><br><span class="line">                result.append(matrix[i][endx])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从右到左打印一行</span></span><br><span class="line">        <span class="comment">#终止行号大于起始行号，还要求终止列号大于起始列号</span></span><br><span class="line">        <span class="keyword">if</span> endy&gt;start <span class="keyword">and</span> endx&gt;start:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(endx-<span class="number">1</span>,start-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">                result.append(matrix[endy][i])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从下到上打印一列</span></span><br><span class="line">        <span class="comment">#终止行号减去起始行号要大于等于2，同时终止列号大于起始列号</span></span><br><span class="line">        <span class="keyword">if</span> endy&gt;=start+<span class="number">2</span> <span class="keyword">and</span> endx&gt;start:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(endy-<span class="number">1</span>,start,-<span class="number">1</span>):</span><br><span class="line">                result.append(matrix[i][start])</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-30包含min函数的栈-python</title>
    <url>/jzo30.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p>题：定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。在该栈中，调用min、push、pop的时间复杂度都是O(1)</p>
<p>第一想法：</p>
<p>没思路，不知道怎么让MIN PUSH POP的复杂度都是O(1)，只能将最小元素其放在栈顶，但push时候就不是O(1)了</p>
<p>方法：</p>
<p>建立一个辅助栈（每次push时，用于存储最小的元素，这样栈顶依然是最小元素），干！</p>
<p>push 3 主栈【3】 辅助栈【3】</p>
<p>push 4 主栈【3 4】 辅助栈【3 3】</p>
<p>push 5 主栈【3 4 5】 辅助栈【3 3 3】</p>
<p>pop 主栈【3 4】 辅助栈【3 3】</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.mainstack = []</span><br><span class="line">        self.helpstack = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.helpstack) == <span class="number">0</span>:</span><br><span class="line">            self.helpstack.append(node)</span><br><span class="line">            self.mainstack.append(node)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        minvalue = self.top()</span><br><span class="line">        <span class="keyword">if</span> minvalue &lt;= node: <span class="comment">#比当前最小值大</span></span><br><span class="line">            self.helpstack.append(minvalue)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.helpstack.append(node)</span><br><span class="line">        self.mainstack.append(node)</span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.mainstack.pop()</span><br><span class="line">        <span class="keyword">return</span> self.helpstack.pop()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.helpstack[-<span class="number">1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.top()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-31栈的压入弹出序列-python</title>
    <url>/jzo31.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<p>第一想法：没看懂【45321】为什么是【12345】的弹出序列</p>
<p>push 1 【1】 push 2 【12】 push3 【123】push4 【1234】 pop【123】push5 pop 【123】pop pop pop</p>
<p>看懂了，没思路，唉</p>
<p>方法：</p>
<p>如果下一个弹出的数字刚好是栈顶数字，那么直接弹出；</p>
<p>如果下一个弹出的数字不在栈顶，则把压栈序列中还没有入栈的数字压入辅助栈，直到把下一个需要弹出的数字压入栈顶为止；</p>
<p>如果所有数字都压入栈后仍然没有找到下一个弹出的数字，那么该序列不可能是一个弹出序列。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.helpstack = []</span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsPopOrder</span>(<span class="params">self, pushV, popV</span>):</span></span><br><span class="line">        <span class="keyword">for</span> elem <span class="keyword">in</span> popV:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(self.helpstack) &gt;<span class="number">0</span> :</span><br><span class="line">                <span class="keyword">if</span> self.helpstack[-<span class="number">1</span>] == elem:<span class="comment">#下一个弹出的数字刚好是栈顶数字</span></span><br><span class="line">                    self.helpstack.pop()</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">            <span class="comment">#将pushV序列elem之前的元素压入辅助栈</span></span><br><span class="line">            <span class="keyword">if</span> elem <span class="keyword">in</span> pushV:</span><br><span class="line">                index = pushV.index(elem)</span><br><span class="line">                self.helpstack.extend(pushV[:index+<span class="number">1</span>])</span><br><span class="line">                pushV = pushV[index+<span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">if</span> self.helpstack[-<span class="number">1</span>] == elem:<span class="comment">#下一个弹出的数字刚好是栈顶数字</span></span><br><span class="line">                    self.helpstack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-32从上到下打印二叉树-python</title>
    <url>/jzo32.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p>第一想法：二叉树的广度优先遍历</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintFromTopToBottom</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        elemlist = []</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> elemlist</span><br><span class="line">        queue = [root] <span class="comment">#使用队列</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur = queue.pop(<span class="number">0</span>)</span><br><span class="line">            elemlist.append(cur.val)</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                queue.append(cur.left)</span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                queue.append(cur.right)</span><br><span class="line">        <span class="keyword">return</span> elemlist</span><br></pre></td></tr></tbody></table></figure>
<h2 id="升级版题目二要求分行打印二叉树">升级版题目二：要求分行打印二叉树</h2>
<p>​ 8 8</p>
<p>6 10 分行打印 ==》 6 10</p>
<p>5 7 9 11 5 7 9 11</p>
<p>方法：添加两个辅助变量，记录当前行待打印的节点数目<strong>toBePrintNum</strong>和下一行的节点个数<strong>nextLevelNum</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回二维列表[[1,2],[4,5]]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span>(<span class="params">self, pRoot</span>):</span></span><br><span class="line">        <span class="keyword">if</span> pRoot <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        elemlist = []</span><br><span class="line">        levelElem = [] <span class="comment">#一行的结点值</span></span><br><span class="line">        queue = [pRoot]<span class="comment">#队列存储待处理结点</span></span><br><span class="line">        toBePrintNum = <span class="number">1</span> <span class="comment">#当前行待打印的节点数目</span></span><br><span class="line">        nextLevelNum = <span class="number">0</span> <span class="comment">#下一行节点数目</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            curNode = queue.pop(<span class="number">0</span>)</span><br><span class="line">            levelElem.append(curNode.val)</span><br><span class="line">            toBePrintNum -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#若左存在，下一行节点数目+1，右孩子存在，下一行节点数目+1</span></span><br><span class="line">            <span class="keyword">if</span> curNode.left:</span><br><span class="line">                queue.append(curNode.left)</span><br><span class="line">                nextLevelNum += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> curNode.right:</span><br><span class="line">                queue.append(curNode.right)</span><br><span class="line">                nextLevelNum += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> toBePrintNum == <span class="number">0</span>: <span class="comment">#这一层的结点打印完了</span></span><br><span class="line">                elemlist.append(levelElem)</span><br><span class="line">                levelElem = [] <span class="comment">#清空 </span></span><br><span class="line">                toBePrintNum = nextLevelNum<span class="comment">#更新为下一层节点数</span></span><br><span class="line">                nextLevelNum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elemlist</span><br></pre></td></tr></tbody></table></figure>
<h2 id="升级版题目三之字形打印二叉树">升级版题目三：之字形打印二叉树</h2>
<p>第一行按从左到右，第二行按从右到左，第三行按从左到右</p>
<p>​ 8 8</p>
<p>6 10 分行打印 ==》 10 6</p>
<p>5 7 9 11 11 9 7 5</p>
<p>第一想法：在题目二的基础上，加一个<strong>reverseFlag</strong>，用于判断是否将levelElem进行reverse操作。</p>
<p>奇数行不reverse，偶数行reverse</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span>(<span class="params">self, pRoot</span>):</span></span><br><span class="line">        <span class="keyword">if</span> pRoot <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        reverseFlag = <span class="number">1</span> <span class="comment">#levlelElem[]是否需要reverse的flag,大于0表示不翻转</span></span><br><span class="line"></span><br><span class="line">        elemlist = []</span><br><span class="line">        levelElem = [] <span class="comment">#一行的结点值</span></span><br><span class="line">        queue = [pRoot]<span class="comment">#队列存储待处理结点</span></span><br><span class="line">        toBePrintNum = <span class="number">1</span> <span class="comment">#当前行待打印的节点数目</span></span><br><span class="line">        nextLevelNum = <span class="number">0</span> <span class="comment">#下一行节点数目</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            curNode = queue.pop(<span class="number">0</span>)</span><br><span class="line">            levelElem.append(curNode.val)</span><br><span class="line">            toBePrintNum -= <span class="number">1</span></span><br><span class="line">			</span><br><span class="line">            <span class="comment">#若左存在，下一行节点数目+1，右孩子存在，下一行节点数目+1</span></span><br><span class="line">            <span class="keyword">if</span> curNode.left:</span><br><span class="line">                queue.append(curNode.left)</span><br><span class="line">                nextLevelNum += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> curNode.right:</span><br><span class="line">                queue.append(curNode.right)</span><br><span class="line">                nextLevelNum += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> toBePrintNum == <span class="number">0</span>: <span class="comment">#这一层的结点打印完了</span></span><br><span class="line">                <span class="keyword">if</span> reverseFlag &lt; <span class="number">0</span>:</span><br><span class="line">                    levelElem.reverse()</span><br><span class="line">                reverseFlag *= (-<span class="number">1</span>) <span class="comment">#每处理完一行就更新</span></span><br><span class="line">                elemlist.append(levelElem)</span><br><span class="line">                levelElem = [] <span class="comment">#清空 </span></span><br><span class="line">                toBePrintNum = nextLevelNum<span class="comment">#更新为下一层节点数</span></span><br><span class="line">                nextLevelNum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elemlist</span><br></pre></td></tr></tbody></table></figure>
<p><strong>剑指offer方法:</strong>感觉不如我的</p>
<p>​ 1</p>
<p>​ 2 3 【1.l 1.r 】</p>
<p>4 5 6 7 【3.r 3.l 2.r 2.l】</p>
<p>8 9 10 11 12 13 14 15 【4.l 4.r 5.l 5.r 6.l 6.r 7.l 7.r】</p>
<p><strong>curNodeList</strong>记录当前层结点</p>
<p>利用栈的后进先出，添加一个辅助栈<strong>nextNodeStack</strong>，保存当前层每个结点的下一层的结点。</p>
<ul>
<li><p>若待保存的是奇数层的子节点，先保存左孩再保存右孩子到<strong>nextStack</strong>栈里；</p></li>
<li><p>若打印的是偶数层的子节点，先保存右孩子再保存左孩子到<strong>nextStack</strong>栈里；</p></li>
</ul>
<p>赋予<strong>curNodeList</strong>，<strong>nextStack</strong>清空，继续处理下一层。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span>(<span class="params">self, pRoot</span>):</span></span><br><span class="line">        <span class="keyword">if</span> pRoot <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        isOddFlag = <span class="number">1</span> <span class="comment">#当前行是否是奇数行</span></span><br><span class="line">        curNodeList = [pRoot]</span><br><span class="line">        elemlist = []</span><br><span class="line">        <span class="keyword">while</span> curNodeList:<span class="comment">#每个while循环处理完当前行</span></span><br><span class="line">            nextNodeStack = [] <span class="comment">#记录下一行的结点</span></span><br><span class="line">            levelElemlist = [] <span class="comment">#存储当前行的结点值</span></span><br><span class="line">            <span class="keyword">if</span> isOddFlag&gt;<span class="number">0</span>:<span class="comment">#当前行是奇数行</span></span><br><span class="line">                <span class="keyword">for</span> node <span class="keyword">in</span> curNodeList:</span><br><span class="line">                    levelElemlist.append(node.val)</span><br><span class="line">                    <span class="comment">#处理此行的子节点，先push左孩子再push右孩子</span></span><br><span class="line">                    <span class="keyword">if</span> node.left:</span><br><span class="line">                        nextNodeStack.append(node.left)</span><br><span class="line">                    <span class="keyword">if</span> node.right:</span><br><span class="line">                        nextNodeStack.append(node.right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> node <span class="keyword">in</span> curNodeList:</span><br><span class="line">                    levelElemlist.append(node.val)</span><br><span class="line">                    <span class="comment">#处理此行的子节点，先push右孩子再push左孩子</span></span><br><span class="line">                    <span class="keyword">if</span> node.right:</span><br><span class="line">                        nextNodeStack.append(node.right)</span><br><span class="line">                    <span class="keyword">if</span> node.left:</span><br><span class="line">                        nextNodeStack.append(node.left)</span><br><span class="line">            </span><br><span class="line">            elemlist.append(levelElemlist)</span><br><span class="line">            levelElemlist = []</span><br><span class="line">            isOddFlag *= -<span class="number">1</span></span><br><span class="line">            nextNodeStack.reverse() <span class="comment">#模拟栈先进后出，将list翻转就是先进后出了</span></span><br><span class="line">            curNodeList = nextNodeStack</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elemlist</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-33二叉搜索树的后序遍历序列-python</title>
    <url>/jzo33.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p>二叉查找树/二叉排序树/二叉搜索树：左子树&lt;根结点&lt;右子树</p>
<p>最后一个元素是根节点。</p>
<p>第一想法：根据二叉搜索树的特点找规律，根据根节点分成左右两部分</p>
<p><strong>根节点的左子树的后序遍历序列是连续的，右子树后续遍历序列也是连续的</strong>。</p>
<p>通过递归检测左子树和右子树是否符合这种特点。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">VerifySquenceOfBST</span>(<span class="params">self, sequence</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> sequence <span class="keyword">or</span> <span class="built_in">len</span>(sequence)&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        root = sequence[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="comment">#找到划分左右子树的index，此index属于root的右子树</span></span><br><span class="line">        <span class="keyword">for</span> elem <span class="keyword">in</span> sequence[:-<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">if</span> elem &gt; root:</span><br><span class="line">                <span class="keyword">break</span> <span class="comment">#找到了，跳出循环，</span></span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#检测右子树序列是否有比root小的值，若有直接就false</span></span><br><span class="line">        <span class="keyword">for</span> elem <span class="keyword">in</span> sequence[index:-<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">if</span> elem &lt; root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#递归检测左子树和右子树</span></span><br><span class="line">        left = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> index &gt; <span class="number">0</span>: <span class="comment">#index大于0说明有左子树</span></span><br><span class="line">            left = self.VerifySquenceOfBST(sequence[:index])</span><br><span class="line">        </span><br><span class="line">        right = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="built_in">len</span>(sequence)-<span class="number">1</span>:<span class="comment">#注意len-1时是最后的根节点，不是右子树</span></span><br><span class="line">            right = self.VerifySquenceOfBST(sequence[index:-<span class="number">1</span>]) </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left <span class="keyword">and</span> right</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-34二叉树中和为某一值的路径-python</title>
    <url>/jzo34.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p>题：输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<p><strong>第一想法：</strong></p>
<p>笨方法：输出到叶节点所有路径，计算和。</p>
<p><strong>方法一：</strong></p>
<p>路径中肯定要经过根节点，在左右子树中找和为（sum-root）的路径，</p>
<p>再在左子树的左右子树中找和为（sum-root-root.left）的路径，</p>
<p>在右子树的左右子树中找和为（sum-root-root.right）的路径，</p>
<p>递归...</p>
<p>第一次竟然写不出以二维列表形式返回二叉树所有路径</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allPath</span>(<span class="params">self,root</span>):</span></span><br><span class="line">	<span class="comment">#返回根节点到叶子结点的所有路径，以二维列表形式</span></span><br><span class="line">       <span class="string">"""</span></span><br><span class="line"><span class="string">       思路，两个list，curpatlist记录树的根节点当前结点的路径;</span></span><br><span class="line"><span class="string">       pathlist记录根节点到叶节点的所有路径。</span></span><br><span class="line"><span class="string">       通过递归形式走到叶子节点，若到了叶节点，则将pathlist.append(curpathlist)</span></span><br><span class="line"><span class="string">       而且curpathlist要pop，返回上一层</span></span><br><span class="line"><span class="string">       """</span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">get_paths</span>(<span class="params">root, curpathlist, pathlist</span>):</span></span><br><span class="line">           <span class="comment"># 当前节点，当前路径（树根节点到当前结点的路径），所有的路径结果</span></span><br><span class="line">           <span class="keyword">if</span> root:</span><br><span class="line">               curpathlist.append(root.elem)</span><br><span class="line"></span><br><span class="line">               left = get_paths(root.lchild, curpathlist, pathlist)</span><br><span class="line">               right = get_paths(root.rchild, curpathlist, pathlist)</span><br><span class="line">               <span class="comment">#如果到达叶子结点，则将当前结果添加到所有结果列表中；</span></span><br><span class="line">               <span class="keyword">if</span> left==<span class="literal">False</span> <span class="keyword">and</span> right==<span class="literal">False</span>: </span><br><span class="line">                   pathlist.append(curpathlist.copy())<span class="comment">#把当前路径加入到结果列表中</span></span><br><span class="line">                   <span class="comment">#注意要copy下，若不copy，curpathlist.pop会改变pathlist</span></span><br><span class="line">               curpathlist.pop()<span class="comment">#返回上一层递归时，弹出路径中的当前结点元素</span></span><br><span class="line">               <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">           <span class="keyword">return</span> []</span><br><span class="line">       pathlist = []</span><br><span class="line">       get_paths(root, [], pathlist)</span><br><span class="line">       <span class="keyword">return</span> pathlist</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>在这个代码基础上进行修改。</p>
<p>用前序遍历的方式访问到某一节点时，我们把该节点添加到路径上，并累加该节点的值。</p>
<p>如果该节点为叶节点，并且路径中节点值的和刚好等于输入的整数，则当前路径符合要求，将它打印出来。</p>
<p>如果当前节点不是叶节点，则继续访问它的子节点。</p>
<p>当前节点访问结束后，递归函数将自动回到它的父节点。因此，我们在函数退出之前要在路径上删除当前节点并减去当前节点的值，以确保返回父节点时路径刚好是从根节点到父节点。</p>
<p>我们不难看出保存路径的数据结构实际上是一个栈，因为路径要与递归调用状态一致，而递归调用的本质就是一个压栈和出栈的过程。</p>
<p><strong>此题代码</strong></p>
<p>```PYTHON class Solution: # 返回二维列表，内部每个列表表示找到的路径 def FindPath(self, root, expectNumber): def getPath(root,curpathlist,pathlist,newExpectNum): #curpathlist:树的根节点到当前节点路径 #pathlist：[[]]根节点到叶节点的所有路径</p>
<pre><code>        if root:
            if root.val &gt; newExpectNum:#剪枝
                return True
            curpathlist.append(root.val)
            newExpectNum -= root.val
            
            left = getPath(root.left,curpathlist,pathlist,newExpectNum)
            right = getPath(root.right,curpathlist,pathlist,newExpectNum)
            if left==False and right==False:
                if newExpectNum == 0:
                    pathlist.append(curpathlist[:])
            curpathlist.pop()
            newExpectNum += root.val #不符合回退newExpectNum
            return True
        return False
        
    if root is None:
        return []

    pathlist = []
    curpathlist = []
    getPath(root,curpathlist,pathlist,expectNumber)
    return pathlist</code></pre>
<p>···</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-35复杂链表的复制-python</title>
    <url>/jzo35.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p><strong>题目描述：</strong></p>
<p>复制一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点或NULL），返回结果为复制后复杂链表的head。</p>
<p><strong>第一想法：</strong>错误</p>
<p>我想的是随着原链表的next给往下走，用val去生成nextNode和randomNode赋给cloneNonde，但这样做randomNode没有连起来。</p>
<p><img src="https://myimg-1301063374.cos.ap-beijing.myqcloud.com/20200317185906.png"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">## 错误代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Clone</span>(<span class="params">self, pHead</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pHead <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> pHead</span><br><span class="line">        cur = pHead</span><br><span class="line">        cloneHeadFlag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            cloneCur= RandomListNode(cur.label)</span><br><span class="line">            cloneNext,cloneRandom = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> cur.<span class="built_in">next</span>:</span><br><span class="line">                cloneNext = RandomListNode(cur.<span class="built_in">next</span>.label)</span><br><span class="line">            <span class="keyword">if</span> cur.random:</span><br><span class="line">                cloneRandom = RandomListNode(cur.random.label)</span><br><span class="line">            </span><br><span class="line">            cloneCur.<span class="built_in">next</span>, cloneCur.random = cloneNext,cloneRandom </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cloneHeadFlag:<span class="comment">#只在第一次复制头节点</span></span><br><span class="line">                cloneHead = cloneCur</span><br><span class="line">                cloneHeadFlag = <span class="literal">True</span></span><br><span class="line">            cur=cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> cloneHead       </span><br></pre></td></tr></tbody></table></figure>
<p>如何让random连接起来？</p>
<p><strong>剑指offer方法一：</strong>非最佳</p>
<p>第一步是复制原始链表上的每个节点，并用<strong>next</strong>链接起来：</p>
<p>第二步是设置每个节点的 <strong>random</strong>指针。假设原始链表中的某个节点N的<strong>random</strong>指向节点S，由于S在链表中可能在N的前面也可能在N的后面，所以要定位S的位置需要从原始链表的头节点沿着<strong>next</strong>开始找。</p>
<p>若从原链表的头节点开始沿<strong>next</strong>经过s步找到节点S，那么在复制链表上节点N的<strong>random</strong>（记为S’）离复制链表的头节点的距离也是沿着<strong>next</strong>指针s步。用这种办法就可以为复制链表上的每个节点设置 <strong>random</strong>指针。</p>
<p>（那还得统计s，太麻烦了）</p>
<p>对于一个含有n个节点的链表，由于定位每个节点的<strong>random</strong>都需要从链表头节点开始经过<span class="math inline">\(O(n)\)</span>步才能找到，因此这种方法总的时间复杂度是<span class="math inline">\(O(n^2)\)</span>.</p>
<p><strong>剑指offer方法二：</strong>提升方法一</p>
<p><strong>以空间换时间</strong></p>
<p>由于上述方法的时间主要花费在定位节点的<strong>random</strong>上，试着在这方面去进行优化。</p>
<p>我们还是分为两步：</p>
<p>第一步仍然是复制原始链表上的每个节点N创建Nclone，然后把这些创建出来的节点用<strong>next</strong>链接起来。同时我们把<span class="math inline">\(&lt;N, Nclone&gt;\)</span>的配对信息放到一个哈希表中：</p>
<p>第二步还是设置复制链表上每个节点的<strong>random</strong>。如果在原始链表中节点N的<strong>random</strong>指向节点S，那么在复制链表中，对应的Nclone的<strong>random</strong>应该指向Sclone。由于有了哈希表，我们可以用<span class="math inline">\(O(1)\)</span>的时间根据S找到S′。</p>
<p>第二种方法相当于用空间换时间。对于有n个节点的链表，我们需要个大小为<span class="math inline">\(O(n)\)</span> 的哈希表，也就是说我们以<span class="math inline">\(O(n)\)</span>的空间消耗把时间复杂度由<span class="math inline">\(O(n^2)\)</span>降低到<span class="math inline">\(O(n)\)</span>。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Clone</span>(<span class="params">self, pHead</span>):</span></span><br><span class="line">    <span class="keyword">if</span> pHead <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> pHead</span><br><span class="line">    cloneDict = <span class="built_in">dict</span>() <span class="comment">#存储{N:Nclone}</span></span><br><span class="line">    cur = pHead</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#构造哈希</span></span><br><span class="line">    <span class="keyword">while</span> cur <span class="keyword">and</span> cur <span class="keyword">not</span> <span class="keyword">in</span> cloneDict:<span class="comment">#注意循环链表的可能</span></span><br><span class="line">        cloneCur= RandomListNode(cur.label)</span><br><span class="line">        cloneDict[cur] = cloneCur</span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    cur = pHead</span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        <span class="keyword">if</span> cur.<span class="built_in">next</span>:</span><br><span class="line">            cloneDict[cur].<span class="built_in">next</span> = cloneDict[cur.<span class="built_in">next</span>]</span><br><span class="line">        <span class="keyword">if</span> cur.random:</span><br><span class="line">            cloneDict[cur].random = cloneDict[cur.random]</span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> cloneDict[pHead]</span><br></pre></td></tr></tbody></table></figure>
<p><strong>剑指offer方法三：</strong></p>
<p>不使用辅助空间，实现<span class="math inline">\(O(n)\)</span></p>
<p>第一步，根据原链表的每个结点N，创建其复制Nclone，并接在N的后面。</p>
<p><img src="https://myimg-1301063374.cos.ap-beijing.myqcloud.com/Snipaste_2020-03-17_21-11-01.png"></p>
<p>第二步，设置<strong>random</strong>，假设N的<strong>random</strong>指向S，则Nclone的<strong>random</strong>指向Sclone，设置好<strong>random</strong>后如图</p>
<p><img src="https://myimg-1301063374.cos.ap-beijing.myqcloud.com/Snipaste_2020-03-17_21-15-59.png"></p>
<p>第三步，把这个长链表拆分成两个链表：把奇数位置的节点用<strong>next</strong>链接起来就是原始链表，把偶数位置的节点用<strong>next</strong>链接起来就是复制出来的链表。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cloneNodes</span>(<span class="params">self,pHead</span>):</span><span class="comment">#第一步</span></span><br><span class="line">        cur = pHead</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            curClone = RandomListNode(cur.label)</span><br><span class="line">            curClone.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = curClone</span><br><span class="line"></span><br><span class="line">            cur = curClone.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connectRandom</span>(<span class="params">self,pHead</span>):</span><span class="comment">#第二步</span></span><br><span class="line">        cur = pHead</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="comment">#注意考虑random是None的情况</span></span><br><span class="line">            curClone = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> cur.random <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                curClone.random = cur.random.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            cur = curClone.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reConnectNodes</span>(<span class="params">self,pHead</span>):</span><span class="comment">#第三步</span></span><br><span class="line">        cur = pHead</span><br><span class="line">        cloneHead = cur.<span class="built_in">next</span></span><br><span class="line">        cloneCur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            cur.<span class="built_in">next</span> = cloneCur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> cloneCur.<span class="built_in">next</span>: <span class="comment">#注意cloneCur是不是最后一个非None结点</span></span><br><span class="line">                cloneCur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cloneCur.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">            cloneCur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> cloneHead</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Clone</span>(<span class="params">self, pHead</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pHead <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        self.cloneNodes(pHead)</span><br><span class="line">        self.connectRandom(pHead)</span><br><span class="line">        <span class="keyword">return</span> self.reConnectNodes(pHead)</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-36二叉搜索树与双向链表-python</title>
    <url>/jzo35.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p><strong>题目描述：</strong></p>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<p><img src="https://myimg-1301063374.cos.ap-beijing.myqcloud.com/Snipaste_2020-03-17_22-18-40.png"></p>
<p><strong>第一想法</strong></p>
<p>二叉搜索树的中序遍历就是升序输出，可惜没思路</p>
<p>网上的一种思路，这么简单都想不到（惭愧啊）</p>
<p>只需要中序遍历，将所有的节点保存到一个列表。对这个list进行遍历，每个节点的right设为下一个节点，下一个节点的left设为上一个节点。</p>
<p>https://www.cnblogs.com/yanmk/p/9220765.html</p>
<p><strong>剑指offer方法：</strong></p>
<p>中序遍历树中的每个节点，当遍历到根节点的时候，我们把树看成3部分：值为10的节点根节点值为6的左子树：根节点值为14的右子树。</p>
<p>根据排序链表的定义值为10的节点将和它的左子树的最大一个节点（值为8的节点）链接起来，同时它还将和右子树最小的节点（值为12的节点）链接起来，如图所示</p>
<p><img src="https://myimg-1301063374.cos.ap-beijing.myqcloud.com/Snipaste_2020-03-17_23-17-25.png"></p>
<p>按照中序遍历的顺序，当我们遍历转换到根节点（值为10的节点）时<strong>，它的左子树已经转换成一个排序的链表了(要从底部向根转换，不能从根向底部转)，</strong>并且处在链表中的最后一个节点是当前值最大的节点。我们把值为8的节点和根节点链接起来，此时链表中的最后一个节点就是10了。接着我们去遍历转换右子树，并把根节点和右子树中最小的节点链接起来。至于怎么去转换它的左子树和右子树，由于遍历和转换过程是一样的，我们很自然地想到可以用递归。</p>
<p>在中序遍历的基础上修改，定义preNode指向已转换好的链表的最后一结点，</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">Convert</span>(<span class="params">self, pRootOfTree</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">convertCore</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="comment">#在中序遍历的基础上修改</span></span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            convertCore(root.left)</span><br><span class="line">            </span><br><span class="line">            root.left = preNode[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> preNode[<span class="number">0</span>]:</span><br><span class="line">                preNode[<span class="number">0</span>].right = root</span><br><span class="line">            preNode[<span class="number">0</span>] = root</span><br><span class="line">            </span><br><span class="line">            convertCore(root.right)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> pRootOfTree <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        pHead = pRootOfTree</span><br><span class="line">        <span class="keyword">while</span> pHead.left: <span class="comment">#找转换后的头节点</span></span><br><span class="line">            pHead = pHead.left</span><br><span class="line">        preNode = [<span class="literal">None</span>] <span class="comment">#注意使用list做参数</span></span><br><span class="line">        convertCore(pRootOfTree)</span><br><span class="line">        <span class="keyword">return</span> pHead</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>关于做函数参数，是否会修改原身。涉及到可变对象，不可变对象。是否在函数内重新赋值问题，比较复杂，建议看下<strong>可变对象</strong>一节的例子</p>
<p>https://sbaban.com/pylearning.html</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-37序列化二叉树-python</title>
    <url>/jzo37.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p><strong>题目描述：</strong></p>
<p>实现两个函数，分别用来序列化和反序列化二叉树</p>
<p>二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！表示一个结点值的结束（value!）。</p>
<p>二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p>
<p>以前序遍历序列化为例,这棵树序列化为【1!2!4!N!N!3!N!N】</p>
<p>​ 1</p>
<p>​ /<br>
</p>
<p>​ 2 3</p>
<p>​ /</p>
<p>4</p>
<p>反序列化：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">第一想法：两个<span class="string">'#'</span><span class="string">'#'</span> 表示是叶子结点，</span><br><span class="line"></span><br><span class="line">通过<span class="keyword">for</span>循环处理每个字符串，没有写出来</span><br><span class="line"></span><br><span class="line">看了网上的代码，可以用<span class="built_in">list</span>.pop（）形式处理每个结点，并<span class="keyword">return</span> Node递归来处理左右结点</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Serialize</span>(<span class="params">self, root</span>):</span><span class="comment">#以前序遍历序列化</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'#'</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(root.val)+<span class="string">'!'</span>+ \</span><br><span class="line">          self.Serialize(root.left)+<span class="string">'!'</span>+ \</span><br><span class="line">          self.Serialize(root.right)</span><br><span class="line">                <span class="comment"># write code here</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Deserialize</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">buildNode</span>(<span class="params">elemlist</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(elemlist)&lt;<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            val = elemlist.pop(<span class="number">0</span>)</span><br><span class="line">            newnode = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> val != <span class="string">'#'</span>:</span><br><span class="line">                newnode = TreeNode(<span class="built_in">int</span>(val))</span><br><span class="line">                newnode.left = buildNode(elemlist)</span><br><span class="line">                newnode.right = buildNode(elemlist)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> newnode</span><br><span class="line">        elemlist = s.split(<span class="string">'!'</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> buildNode(elemlist)</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-38字符串的排列-python</title>
    <url>/jzo38.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p><strong>题目描述：</strong></p>
<p>输入一个字符串，长度不超过9(可能有字符重复),字符只包括大小写字母。,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
<p><strong>第一想法：</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> s.repalce(i,<span class="string">''</span>,<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> s.replace(i, <span class="string">''</span> ,<span class="number">1</span>).replace(j,<span class="string">''</span>,<span class="number">1</span>):</span><br><span class="line">            i+j+k</span><br><span class="line">再<span class="built_in">set</span>（）下去除重复元素</span><br></pre></td></tr></tbody></table></figure>
<p><strong>剑指offer方法：</strong></p>
<p>求整个字符串的排列，可看成两步。以【abc】为例</p>
<p>第一步求所有可能出现在第一个位置的字符，即把第一个字符和后面所有的字符交换。下图是分别把第一个字符a和后面的b、c等字符交换的情形。</p>
<p>第二步固定第一个字符，求后面所有字符的排列。这时候我们仍把后面的所有字符分成两部分：后面字符的第一个字符，以及这个字符之后的所有字符。然后把后面字符的第一个字符逐一和它后面的字符交换。</p>
<p><strong>无论给定的字符串长度多少，其排列出来的组合样式均可以分解为“第一个字符+剩下的字符”的样式，递归实现</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Permutation</span>(<span class="params">self, ss</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">ss,resultlist,curpath=<span class="string">''</span></span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ss:<span class="comment">#到了最后一个字符</span></span><br><span class="line">                resultlist.append(curpath)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ss)):</span><br><span class="line">                helper(ss[:i]+ss[i+<span class="number">1</span>:],resultlist,curpath+ss[i])</span><br><span class="line">                <span class="comment">#ss[:i]+ss[i+1:]是为例取出当前字符ss[i]，因为是不放回采样</span></span><br><span class="line">                <span class="comment">#path+ss[i]是将当前字符保留到curpath中</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ss:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        resultlist = []</span><br><span class="line">        helper(ss, resultlist, <span class="string">""</span>)<span class="comment">#list是可变对象，不必return</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sorted</span>(<span class="built_in">list</span>(<span class="built_in">set</span>(resultlist))) </span><br><span class="line">    	<span class="comment">#sorted是因为判题程序按字符串顺序比较的</span></span><br><span class="line">        <span class="comment">#set（）是为了去重</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong>代码解释</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">固定第一个字符a，Core(bc, res=[], path=a) :</span><br><span class="line">	固定第二个字符b，Core(c,[],path=ab) :</span><br><span class="line">		固定第三个字符c，Core(Null,[],path=abc): res= [abc]</span><br><span class="line">    固定第二个字符c，Core(b,[],path=ac) :</span><br><span class="line">		固定第三个字符b，Core(Null,[],path=acb): res= [abc,acb]</span><br><span class="line"></span><br><span class="line">固定第一个字符b，Core(ac, res=[], path=b) :</span><br><span class="line"></span><br><span class="line">固定第一个字符c，Core(ab, res=[], path=c) :</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-39数组中出现次数超过一半的数字-python</title>
    <url>/jzo39.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p><strong>题目描述：</strong></p>
<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<p><strong>第一想法：</strong></p>
<p>建立一个hash表，统计每个数字出现的次数，如果超过了数组长度的一半就return</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum_Solution</span>(<span class="params">self, numbers</span>):</span></span><br><span class="line">        threshold = <span class="built_in">len</span>(numbers)/<span class="number">2.0</span></span><br><span class="line">        mydict = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> numbers:</span><br><span class="line">            mydict[i] = mydict.get(i,<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> mydict[i]&gt;threshold:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>剑指offer方法一：</strong>排序</p>
<p>如果把这个数组排序，那么排序之后位于数组中间的数字一定就是那个出现次数超过数组长度一半的数字。</p>
<p>缺点：改变原数组</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum_Solution</span>(<span class="params">self, numbers</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers <span class="keyword">or</span> <span class="built_in">len</span>(numbers)&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        numbers.sort()</span><br><span class="line">        candidate = numbers[<span class="built_in">len</span>(numbers)//<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.check(candidate, numbers)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">self,candidate,numbers</span>):</span></span><br><span class="line">        <span class="comment">#检测是不是复核结果，防止没有众数的情况出现</span></span><br><span class="line">        mycount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> i == candidate:</span><br><span class="line">                mycount += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">2</span>*mycount &gt; <span class="built_in">len</span>(numbers):</span><br><span class="line">            <span class="keyword">return</span> candidate</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>剑指offer方法二：</strong></p>
<p>Boyer-Moore 投票算法</p>
<p>数组中有一个数字出现的次数超过数组长度的一半，即它出现的次数比其他所有数字出现次数的和还要多。因此，我们可以考虑在遍历数组的时候保存两个值：一个是数组中的一个数字作为候选值；另一个是次数。</p>
<p>当我们遍历到下一个数字的时候如果下一个数字和我们之前保存的数字相同，则次数加1：</p>
<p>如果下一个数字和我们之前保存的数字不同，则次数减1.</p>
<p>如果次数为零，那么我们需要保存下一个数字，并把次数设为1.</p>
<p>由于要找的数字出现的次数比其他所有数字出现的次数之和还要多，那么要找的数字肯定是最后设置的数字</p>
<p><strong>注意，如果众数不存在？设置一个检测函数</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum_Solution</span>(<span class="params">self, numbers</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers <span class="keyword">or</span> <span class="built_in">len</span>(numbers)&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        candidate, score = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> score == <span class="number">0</span>:</span><br><span class="line">                candidate = i</span><br><span class="line">            <span class="keyword">if</span> i == candidate:</span><br><span class="line">                score += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                score -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.check(candidate, numbers)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">self,candidate,numbers</span>):</span></span><br><span class="line">        <span class="comment">#检测是不是符合结果，防止没有众数的情况出现</span></span><br><span class="line">        mycount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> i == candidate:</span><br><span class="line">                mycount += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">2</span>*mycount &gt; <span class="built_in">len</span>(numbers):</span><br><span class="line">            <span class="keyword">return</span> candidate</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>这个之前leetcode做过了，竟然又忘了。</p>
<p><a href="https://sbaban.com/lc169.html">leetcode-169多数元素</a></p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-3数组中重复的数字-python</title>
    <url>/jz2019num.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<h2 id="题目一">题目一</h2>
<p>在一个长度为 n 的数组里的所有数字都在 0~m-1 的范围内。数组中某</p>
<p>些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了</p>
<p>几次。请找出数组中任意一个重复的数字。例如，如果输入长度为 7 的数组{2,3,1,0,2,5,3｝，那么对应的输出是重复的数字 2 或者 3。</p>
<p><strong>最初想法</strong></p>
<p>最简单的方法是遍历数组， 优化：创建一个长度为n的辅助数组temp，读取原数组值x，令temp[x]=1，再读入新元素检测是否为1即可。</p>
<details>
<summary>使用辅助数组</summary> <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">duplicate</span>(<span class="params"> numbers, duplication</span>):</span></span><br><span class="line">    temp = [<span class="number">0</span>]*<span class="built_in">len</span>(numbers)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> numbers:</span><br><span class="line">        <span class="keyword">if</span> temp[i] == <span class="number">1</span>:</span><br><span class="line">            duplication[<span class="number">0</span>] = i</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        temp[i] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></tbody></table></figure>
</details>
<p>不使用辅助数组：【官方】 直接在原数组上交换元素，确保元素与其下标相等。 详细思路：看书上的例子p39</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">duplicate</span>(<span class="params"> numbers, duplication</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(numbers)):</span><br><span class="line">        <span class="keyword">while</span> i != numbers[i]:<span class="comment">#保证元素与下标i对应</span></span><br><span class="line">            <span class="keyword">if</span> numbers[numbers[i]] == numbers[i]: <span class="comment">#如果已经有元素</span></span><br><span class="line">                duplication[<span class="number">0</span>] = numbers[i]</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                numbers[numbers[i]], numbers[i] = numbers[i], numbers[numbers[i]] <span class="comment">#交换位置</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>我的方法</p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#还是利用下标，将nums[i]位置的元素乘以-1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span>        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            temp = <span class="built_in">abs</span>(nums[i])</span><br><span class="line">            <span class="keyword">if</span> nums[temp] &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> temp</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[temp] = -nums[temp]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span><span class="comment">#如果到底也没return，那一定是0乘-1了</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="题目二">题目二</h2>
<p>不修改数组，不利于辅助空间，找出重复数字</p>
<p>在一个长度为 n+1 的数组里的所有数字都在 1～ n 的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为 8 的数组（2,3,5,4,3,2,67）, 那么对应的输出是重复的数字 2 或者 3</p>
<p>利用二分查找</p>
<p>我们以长度为 8 的数组{2,3,5,4,3,2,6,7}为例分析查找的过程。根据题目要求，这个长度为 8 的所有数字都在 1~7 的范围内。中间的数字 4 把 1~7 的范围分为两段，一段是 1~4, 另一段是 5~7。接下来我们统计 1 -4 这 4 个数字在数组中出现的次数，它们一共出现了 5 次，因此这 4 个数字中一定有重复的数字。</p>
<p>接下来我们再把 1~4 的范围一分为二，一段是 1、2 两个数字，另一段是 3、4 两个数字。数字 1 或者 2 在数组中一共出现了两次。我们再统计数字 3 或者 4 在数组中出现的次数，它们一共出现了三次。这意味着 3、4 两个数字中一定有一个重复了。我们再分别统计这两个数字在数组中出现的次数。接着我们发现数字 3 出现了两次，是一个重复的数字。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        start =<span class="number">1</span></span><br><span class="line">        end = n-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> start&lt;=end:</span><br><span class="line">            mid = (start+end)//<span class="number">2</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> elem <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> start &lt;= elem &lt;= mid:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> end == start:</span><br><span class="line">                <span class="keyword">if</span> count &gt;<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> start</span><br><span class="line">            <span class="keyword">if</span> count &gt; (mid-start)+<span class="number">1</span>:<span class="comment">#重复元素在【start与mid区间】</span></span><br><span class="line">                end = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> mid</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-40最小的k个数-python</title>
    <url>/jzo40.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p><strong>题目描述：</strong></p>
<p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p>
<p>第一想法:</p>
<p>sort，</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetLeastNumbers_Solution</span>(<span class="params">self, tinput, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> tinput <span class="keyword">or</span> <span class="built_in">len</span>(tinput)&lt;k:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        tinput.sort()</span><br><span class="line">        <span class="keyword">return</span> tinput[:k]</span><br></pre></td></tr></tbody></table></figure>
<p><strong>剑指offer方法一:</strong></p>
<p>由于不要求最小的k个数按序输出，参考快排中partition函数思想：</p>
<p>因为快排每次都能得到基于分界点的数组，分界点左边的元素一定小于分界点上的元素。如果此分界点正好是k，则得到了最小的k个数，而不必整体排序。</p>
<p>最坏情况是，一直没有得到这个点，得到了一个部分排序的数组。但时间复杂度仍小于快排<strong>O(nlogn)</strong></p>
<p>通过调整midValueIndex的位置，让它=K</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetLeastNumbers_Solution</span>(<span class="params">self, tinput, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> tinput <span class="keyword">or</span> <span class="built_in">len</span>(tinput)&lt;k <span class="keyword">or</span> k&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        low, high = <span class="number">0</span>, <span class="built_in">len</span>(tinput)-<span class="number">1</span></span><br><span class="line">        midValueIndex = self.partition(tinput,low,high)</span><br><span class="line">        targetIndex = k-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> targetIndex != midValueIndex:</span><br><span class="line">            <span class="keyword">if</span> midValueIndex &gt; targetIndex:</span><br><span class="line">                high = midValueIndex-<span class="number">1</span></span><br><span class="line">                midValueIndex = self.partition(tinput,low,high)</span><br><span class="line">            <span class="keyword">elif</span> midValueIndex &lt; targetIndex:</span><br><span class="line">                low = midValueIndex+<span class="number">1</span></span><br><span class="line">                midValueIndex = self.partition(tinput,low,high)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sorted</span>(tinput[:k])<span class="comment">#判题程序需要sort</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">self,mylist,low,high</span>):</span></span><br><span class="line">    <span class="comment">#选择mylist[low]元素作为分界点，low和high是mylist的下标</span></span><br><span class="line">    <span class="comment">#此函数将比分界点小的放左边，比分界点大的放右边，</span></span><br><span class="line">    <span class="comment">#返回分界点的位置索引low</span></span><br><span class="line">        midValue = mylist[low]</span><br><span class="line">        <span class="keyword">while</span> low&lt;high:<span class="comment">#high左移和low右移交替进行</span></span><br><span class="line">            <span class="keyword">while</span> low&lt;high <span class="keyword">and</span> mylist[high]&gt;= midValue: </span><br><span class="line">                <span class="comment">#mylist[high]&gt;midvalue,high就一直左移</span></span><br><span class="line">                high -= <span class="number">1</span></span><br><span class="line">            mylist[low] = mylist[high]</span><br><span class="line">            <span class="comment">#high处元素小于midValue，赋给low所在位置,赋值后high处的元素就没意义了，虚位以待</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> low&lt;high <span class="keyword">and</span> mylist[low] &lt; midValue: <span class="comment">#low一直右移</span></span><br><span class="line">                low += <span class="number">1</span></span><br><span class="line">            mylist[high] = mylist[low] <span class="comment"># 赋给high所在位置，</span></span><br><span class="line"></span><br><span class="line">        mylist[low] = midValue</span><br><span class="line">        <span class="keyword">return</span> low <span class="comment">#返回分界点索引</span></span><br><span class="line">    </span><br><span class="line">      </span><br></pre></td></tr></tbody></table></figure>
<p><strong>剑指offer方法二:</strong>适合海量数据此操作</p>
<p>建立一个k维容器，存储k个最小值。</p>
<p>如果容器中已有的数字少于k个，则直接把这次读入的整数放入容器之中；</p>
<p>如果容器中已有k个数字了，也就是容器已满，此时我们不能只能替换已有的数字。找出这已有的k个数中的最大值，然后拿这次待插入的整数和最大值进行比较。若比当前已有的最大值小，则用这个数替换当前已有的最大值；如果待插入的值比当前已有的最大值还要大，就抛弃这个整数。</p>
<p>可以基于堆或者红黑树实现这个k维容器，奈何还未学到，先跳过这里</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-41数据流中的中位数-python</title>
    <url>/jzo41.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p><strong>题目描述：</strong></p>
<p>寻找中位数，奇数长度的数组是中间的那个数，偶数长度的数组是中间两个数的平均值。</p>
<p>第一想法:</p>
<p>快速排序，但实际上只要排到中间就行了，如何改进?</p>
<p><strong>剑指offer方法一：</strong></p>
<p>用数组，链表，二叉搜索树，AVL树来存储数据，并实现排序</p>
<p><strong>剑指offer方法二：</strong></p>
<p>整个数据容器可被分隔成两部分。位于容器左边部分的数据比右边的数据小。</p>
<p>另外，设立P1指针指向的数据左边最大的数，P2指向的右边数据最小的数。</p>
<p>如果能够保证数据容器左边的数据都小于右边的数据，那<strong>么即使左、右两边内部的数据没有排序，也可以根据左边最大的数及右边最小的数得到中位数</strong>。</p>
<p>如何快速从一个数据容器中找出最大数？用最大堆实现这个数据容器，因为位于堆顶的就是最大的数据。同样，也可以快速从最小堆中找出最小数。</p>
<p>因此，可以用如下思路来解决这个问题：用一个最大堆实现左边的数据容器，用一个最小堆实现右边的数据容器。往堆中插入一个数据的时间效率是 <strong>O（logn） </strong>。由于只需要<strong>O(1) </strong>时间就可以得到位于堆顶的数据.</p>
<p>接下来考虑用最大堆和最小堆实现的一些细节。</p>
<p><strong>首先要保证数据平均分配到两个堆中</strong>，因此两个堆中数据的数目之差不能超过1.为了实现平均分配，可以在数据的总数目是偶数时把新数据插入最小堆，否则插入最大堆。</p>
<p><strong>还要保证最大堆中的所有数据都要小于最小堆中的数据。</strong>当数据的总数目是偶数时，按照前面的分配规则会把新的数据插入最小堆。如果此时这个新的数据比最大堆中的一些数据要小，那该怎么办呢？ 可以先把这个新的数据插入最大堆，接着把最大堆中最大的数字拿出来插入最小堆。由于最终插入最小堆的数字是原最大堆中最大的数字，这样就保证了最小堆中所有数字都大于最大堆中的数字。 当需要把一个数据插入最大堆，但这个数据大于最小堆里的一些数据时，这个情形和前面类似.</p>
<p>最大堆，最小堆实现</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">        self.minHeap = []</span><br><span class="line">        self.maxHeap = [] <span class="comment">#通过相反数实现最大堆</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span>(<span class="params">self, num</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.count &amp; <span class="number">1</span> == <span class="number">0</span>:<span class="comment">#数据总数是偶数，放入最小堆</span></span><br><span class="line">          <span class="comment">#把新数据插入最小堆，要保证此数据大于最大堆里的数据</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(self.maxHeap)&gt;<span class="number">0</span> <span class="keyword">and</span> num&lt; -self.maxHeap[<span class="number">0</span>]:</span><br><span class="line">              <span class="comment">#将新数据插入最大堆，然后从最大堆中取最大的数字放入最小堆</span></span><br><span class="line">              popnum = -heapq.heappushpop(self.maxHeap, -num)</span><br><span class="line">              heapq.heappush(self.minHeap,popnum)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                heapq.heappush(self.minHeap,num)</span><br><span class="line">        <span class="keyword">else</span>:<span class="comment">#数据总数是奇数，放入最大堆</span></span><br><span class="line">            <span class="comment">#把新数据插入最大堆，要保证此数据小于最小堆里的数据</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(self.minHeap)&gt;<span class="number">0</span> <span class="keyword">and</span> num&gt; self.minHeap[<span class="number">0</span>]:</span><br><span class="line">                <span class="comment">#将新数据插入最小堆，然后从最小堆中取最小的数字放入最大堆</span></span><br><span class="line">                popnum = -heapq.heappushpop(self.minHeap, num)</span><br><span class="line">                heapq.heappush(self.maxHeap,popnum)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                heapq.heappush(self.maxHeap,-num)</span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line">        <span class="comment"># print("max",self.maxHeap,"min",self.minHeap )</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetMedian</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.count == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> self.count &amp; <span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.minHeap[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (-self.maxHeap[<span class="number">0</span>]+self.minHeap[<span class="number">0</span>])/<span class="number">2.0</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-42连续子数组的最大和-python</title>
    <url>/jzo42.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p><strong>题目描述：</strong></p>
<p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为<strong>O（n）</strong> 例如，输入的数组为{1, -2, 3, 10, -4, 7, 2, -5}，和最大的子数组为{3, 10, 4, 7, 2}，因此输出为该子数组的和18。</p>
<p>第一想法:</p>
<p>贪心，不行，贪心适合从头开始的</p>
<p>动态规划，最大子序和问题</p>
<p><strong>剑指offer方法一：</strong></p>
<p>考虑数组的规律</p>
<p><strong>剑指offer方法二：</strong></p>
<p>具体讲解见<a href="https://sbaban.com/dp20.html">最大子序和</a></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindGreatestSumOfSubArray</span>(<span class="params">self, array</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> array <span class="keyword">or</span> <span class="built_in">len</span>(array)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        curmax = <span class="number">0</span> <span class="comment">#以当前元素结尾的子序和最大值</span></span><br><span class="line">        maxsum = -<span class="number">9999</span> <span class="comment">#sum[]中的最大值</span></span><br><span class="line">        <span class="keyword">for</span> elem <span class="keyword">in</span> array:</span><br><span class="line">            curmax = <span class="built_in">max</span>(curmax+elem,elem)</span><br><span class="line">            maxsum = <span class="built_in">max</span>(curmax, maxsum)</span><br><span class="line">        <span class="keyword">return</span> maxsum</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-43整数中1出现的次数-python</title>
    <url>/jzo43.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p><strong>题目描述：</strong></p>
<p>求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。比如1~13中包含1的数字有1、10、11、12、13因此共出现6次。</p>
<p>第一想法:</p>
<p>从1至n遍历，统计每个数字中1出现的次数，最后求和。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1Between1AndN_Solution</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">numberOf1</span>(<span class="params">n</span>):</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> n:</span><br><span class="line">                <span class="keyword">if</span> n%<span class="number">10</span> == <span class="number">1</span>: </span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                n = n//<span class="number">10</span></span><br><span class="line">            <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        count =<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">            count += numberOf1(i)</span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></tbody></table></figure>
<p><strong>剑指offer方法：</strong></p>
<p>从数字规律出发，（个人觉得没泛化性，待更新）</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-44数字序列中某一位的数字-python</title>
    <url>/jzo44.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p><strong>题目描述：</strong></p>
<p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从0开始计数）是5，第13位是1，第19位是4，等等。请写一个函数，求任意第n位对应的数字。</p>
<p><strong>第一想法:</strong></p>
<p>从1至n的字符串，访问第n个</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nstNum</span>(<span class="params">n</span>):</span></span><br><span class="line">    mystr = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">        mystr += (<span class="built_in">str</span>(i))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(mystr)[n-<span class="number">1</span>]</span><br></pre></td></tr></tbody></table></figure>
<p><strong>剑指offer方法：</strong></p>
<p>从数字规律出发，（个人觉得缺少泛化性，待更新）</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-45把数组排成最小的数-python</title>
    <url>/jzo45.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p><strong>题目描述：</strong></p>
<p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<p><strong>第一想法:</strong></p>
<p>转成字符串后，按字符串排序，再拼接，不行啊</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">不能安装字符串比较规则进行排序</span><br><span class="line">'52'&gt;'5' #true</span><br><span class="line">52和5组成的数字552&gt;525</span><br></pre></td></tr></tbody></table></figure>
<p><strong>剑指offer方法：</strong></p>
<p>(干，就是按字符串排序，我没想出来是因为没设计好排序规则，不知道3和321比怎么比较)</p>
<p>定义一种排序规则，数字<code>m</code> 和 <code>n</code> 能拼成数字 <code>mn</code> 和 <code>nm</code>， 比较<code>mn</code> 和 <code>nm</code> 的大小，由于位数相同的，比较大小考可以按照字符串大小的比较规则。</p>
<p>如果拼接后的数字<code>mn</code> 大于 <code>nm</code>，则m&gt;n; 否则m &lt; n.</p>
<p>按照这种排序规则，将字符串数组从小到大排序，排序后的就是最小数字。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintMinNumber</span>(<span class="params">self, numbers</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quickSort</span>(<span class="params">mylist</span>):</span><span class="comment">#快速排序比较</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(mylist) &lt;<span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> mylist</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                less,greater = [], []</span><br><span class="line">                midValue = mylist[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">for</span> elem <span class="keyword">in</span> mylist[<span class="number">1</span>:]:</span><br><span class="line">                    <span class="keyword">if</span> midValue+elem &gt;elem+midValue:</span><br><span class="line">                        <span class="comment">#elem小于midValue</span></span><br><span class="line">                        less.append(elem)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        greater.append(elem)</span><br><span class="line">            <span class="keyword">return</span> quickSort(less) + [midValue] + quickSort(greater)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers <span class="keyword">or</span> <span class="built_in">len</span>(numbers)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        strnumbers = [<span class="built_in">str</span>(elem) <span class="keyword">for</span> elem <span class="keyword">in</span> numbers] <span class="comment">#将intlist转为strlist</span></span><br><span class="line">        res = quickSort(strnumbers)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(<span class="string">''</span>.join(res))</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-46把数字翻译成字符串-python</title>
    <url>/jzo46.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p><strong>题目描述：</strong></p>
<p>给定一个数字，我们按照如下规则把它翻译为字符串：0翻译成“a”，1翻译成“b”,……，25翻译成“z”。</p>
<p>一个数字可能有多个翻译。例如：12258有5种不同的翻译，分别是“bccfi”、“bwfi”、“bczi”、“mcfi”和“mzi”。</p>
<p>请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<p><strong>第一想法:</strong></p>
<p>一个数字能分割成个0~25之间的数字有多少种分法。</p>
<p>整不出来</p>
<p><strong>剑指offer方法：</strong></p>
<p>走一步或两步，属于青蛙跳台阶/爬楼梯/斐波那契数列问题，不过此题加了限制2个数字组合要在0-25之间，需要做个判断。</p>
<p>if 第 i 位和第 i+1 两位数字拼接起来的数字在0-25之间时</p>
<p>$F(i) = F(i+1) + F(i+2) $</p>
<p>else</p>
<p>$F(i) = F(i + 1) $</p>
<p>$F(i) $ 表示从左到右从第 i 位开始翻译的分法。</p>
<p>为了便于理解，贴近斐波那契额数列公式，从右边开始编号0。</p>
<p>举例来说，ABCD表示四个数字，ABCD下标是3210.要分解ABCD，可以</p>
<p>[AB，CD]，AB是一种，CD有F（1）种分法，（若AB在0-25之间，否则就没有这种分法）</p>
<p>[A，BCD]，A是一种，BCD有F（2）种分法</p>
<p>所以：</p>
<p>if 第 i 位和第 i-1 两位数字拼接起来的数字在0-25之间时</p>
<p>$F(i) = F(i-1) + F(i-2) $</p>
<p>else</p>
<p>$F(i) = F(i - 1) $</p>
<p>$F(i) $ 表示从右到左到第 i 位(从右边数)结束的分法。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">translate</span>(<span class="params">self, num</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span>(<span class="params">numbers</span>):</span></span><br><span class="line">            <span class="comment">#计算此题的斐波那契额数列</span></span><br><span class="line">            length = <span class="built_in">len</span>(numbers)</span><br><span class="line">            <span class="keyword">if</span> length==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> [<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> length == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> [<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                flist = [<span class="number">0</span>]*length <span class="comment">#用于存储斐波那契额数列结果</span></span><br><span class="line">                flist[<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="number">10</span>&lt;=numbers[-<span class="number">2</span>]*<span class="number">10</span>+numbers[-<span class="number">1</span>] &lt;=<span class="number">25</span>:</span><br><span class="line">                    flist[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                     flist[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(numbers)):</span><br><span class="line">                    <span class="keyword">if</span> <span class="number">10</span>&lt;=<span class="number">10</span>*numbers[-i-<span class="number">1</span>]+numbers[-i] &lt;=<span class="number">25</span>:</span><br><span class="line">                        flist[i] = flist[i-<span class="number">1</span>]+flist[i-<span class="number">2</span>]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        flist[i] = flist[i-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">return</span> flist</span><br><span class="line">        <span class="keyword">if</span> num&lt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        numlist = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">str</span>(num))) <span class="comment">#将int转为list</span></span><br><span class="line">        <span class="keyword">return</span> Fibonacci(numlist)[-<span class="number">1</span>]</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-47礼物的最大价值-python</title>
    <url>/jzo47.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<h2 id="题目描述">题目描述：</h2>
<p>在一个mxn的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于0），你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格，直到到达棋盘的右下角。给定一个棋盘及其上面的礼物，请计算你最多能拿多少价值的礼物？</p>
<p>1 10 3 8 12 2 9 6 5 7 4 11 3 7 16 5</p>
<p>1，12，5，7，7，16，5可以拿到最大价值位53的礼物。</p>
<h2 id="第一想法">第一想法:</h2>
<p>动态规划</p>
<h2 id="剑指offer方法">剑指offer方法：</h2>
<p>动态规划</p>
<p>$f( i, j ) $ 表示到达坐标为(i, j) 的格子时，礼物总和的最大值，而只有两种途径没那功能到达(i, j) ,通过格子（i-1， j）或（i，j - 1 ）.所以</p>
<p><span class="math inline">\(f(i, j ) = max(f(i-1, j) , f(i, j - 1)) + gift[i,j]\)</span></p>
<p>还需要一个辅助的二维数组缓存中甲的计算结果，数组中坐标为（i，j）的元素表示到达坐标为（i，j）的格子时能拿到的礼物价值总和的最大值。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_max_value</span>(<span class="params">self, values, rows, cols</span>):</span></span><br><span class="line">        <span class="comment">#矩阵左上角按00算</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> values <span class="keyword">or</span> rows &lt;= <span class="number">0</span> <span class="keyword">or</span> cols &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        maxValues = [[<span class="number">0</span>]*cols]*rows <span class="comment">#辅助数组，保存中间结果</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">                left = <span class="number">0</span> <span class="comment">#来自左边的礼物最大值</span></span><br><span class="line">                up = <span class="number">0</span> <span class="comment">#来自上边的礼物最大值</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span>:<span class="comment">#i&gt;0说明可以来自上边</span></span><br><span class="line">                    up = maxValues[i-<span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">if</span> j &gt; <span class="number">0</span>:<span class="comment">#说明可以来自左边</span></span><br><span class="line">                    left = maxValues[i][j-<span class="number">1</span>]</span><br><span class="line">                <span class="comment">#状态转移方程</span></span><br><span class="line">                maxValues[i][j] = <span class="built_in">max</span>(up,left)+values[i*cols+j]</span><br><span class="line">        <span class="keyword">return</span> maxValues[rows-<span class="number">1</span>][cols-<span class="number">1</span>] <span class="comment">#返回右下角元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(Solution().get_max_value([<span class="number">1</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">16</span>, <span class="number">5</span>], <span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="优化">优化</h2>
<p><strong>将二位辅助矩阵 改为 一维数组</strong></p>
<p>拿到礼物的最大价值只依赖于<code>（i-1，j）</code>和 <code>（i，j-1）</code>的两个格子，因此可<code>i-2</code>行及更上面的所有格子以及<code>j-2</code>列及更左边的所有各自礼物的最大价值实际上没有必要保存下来。</p>
<p>可以用一个一维数组来替代前面代码中的二维矩阵 <code>max Values</code>。</p>
<p>该一维数组的长度为棋盘的列数n。当我们计算到达坐标为<code>（i,j）</code>的格子时能够拿到</p>
<p>该数组前面<code>j</code>个数字分别是当前第<code>i</code>行前面<code>j</code>个格子礼物的最大价值，而之后的数字分别保存前面第<code>i-1</code>行<code>n-j</code>个格子礼物的最大价值。就是此数组以j位分界线分成两部分，前半部分是当前行前j个元素的最大价值，后半部分是上一行后面(n-j)个元素的最大价值。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_max_value</span>(<span class="params">self, values, rows, cols</span>):</span></span><br><span class="line">        <span class="comment">#矩阵左上角按00算</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> values <span class="keyword">or</span> rows &lt;= <span class="number">0</span> <span class="keyword">or</span> cols &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        maxValues = [<span class="number">0</span>]*cols</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">                left = <span class="number">0</span> <span class="comment">#来自左边的礼物最大值</span></span><br><span class="line">                up = <span class="number">0</span> <span class="comment">#来自上边的礼物最大值</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span>:<span class="comment">#i&gt;0说明可以来自上边</span></span><br><span class="line">                    up = maxValues[j]</span><br><span class="line">                <span class="keyword">if</span> j &gt; <span class="number">0</span>:<span class="comment">#说明可以来自左边</span></span><br><span class="line">                    left = maxValues[j-<span class="number">1</span>]</span><br><span class="line">                <span class="comment">#状态转移方程</span></span><br><span class="line">                maxValues[j] = <span class="built_in">max</span>(up,left)+values[i*cols+j]</span><br><span class="line">        <span class="keyword">return</span> maxValues[-<span class="number">1</span>] <span class="comment">#返回右下角元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(Solution().get_max_value([<span class="number">1</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">16</span>, <span class="number">5</span>], <span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-48最长不含重复字符的子字符串-python</title>
    <url>/jzo48.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<h2 id="题目描述">题目描述：</h2>
<p>题目：最长不含重复字符的子字符串</p>
<p>题：请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长字符串的长度。假设字符串中只包含‘a’-‘z’的字符。例如，在字符串“arabcacfr”中，最长的不含重复字符的子字符串是“acfr”，长度为4。</p>
<h2 id="第一想法">第一想法:</h2>
<p>动态规划</p>
<h2 id="剑指offer方法">剑指offer方法：</h2>
<p>动态规划，从左到右扫描</p>
<p><span class="math inline">\(F(i )\)</span> 表示以第 <code>i</code> 个字符结尾的不包含重复字符的子字符串的最大长度。</p>
<ul>
<li><p>1.若第 <code>i</code> 个字符 之前没有出现过，那么 <span class="math inline">\(F(i) = F(i-1) + 1\)</span></p></li>
<li><p>2.若第 <code>i</code> 个字符之前出现过，先计算第 <code>i</code> 个字符和其上次出现 的位置的距离<code>d</code></p>
<ul>
<li><p><span class="math inline">\(d &lt;= F（i-1 ）\)</span> : <span class="math inline">\(F(i ) = d\)</span></p>
<p>Eg 【a，i，b|i】，第 <code>i</code> 个字符是i（下标为3），$ F（i-1 ）=3<span class="math inline">\(, 因为\)</span>d &lt;= F（i-1 ）$ ，所以此时第 <code>i</code> 个字符上次出现在<span class="math inline">\(F(i-1 )\)</span>对应的最长子串中(下标位1)，同时这也意味着在第<code>i</code>个字符出现两次所夹的子字符串中再也没有其他重复的字符了,因此<span class="math inline">\(F(i ) = d\)</span> .</p></li>
<li><p><span class="math inline">\(d &gt; F（i-1 ）\)</span> : <span class="math inline">\(F(i ) = F(i-1) + 1\)</span></p>
<p>Eg 【i，a，c， a，b|i】，第 <code>i</code> 个字符是i（下标为5），$ F（i-1 ）=3$, <span class="math inline">\(d &gt; F（i-1 ）\)</span> ，所以此时第 <code>i</code> 个字符上次出现在<span class="math inline">\(F(i-1 )\)</span>对应的最长子串之前。 <span class="math inline">\(F(i ) = F(i-1) + 1\)</span></p></li>
</ul></li>
</ul>
<p>所以需要创建于给长度为26的数组<strong>poslist</strong>来记录每个字符上次出现在字符串中的下标，该数组所有元素的值都初始化为-1，负数表示该元素对应的字符在字符串中还没有出现过。我们在扫描字符串时遇到某个字符，就把该字符在字符串中的位置存储到数组对应的元素中。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> <span class="built_in">len</span>(s)&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        poslist = [-<span class="number">1</span>]*<span class="number">26</span></span><br><span class="line">        length = <span class="built_in">len</span>(s)</span><br><span class="line">        curlength = <span class="number">0</span> <span class="comment">#F(i-1)的值</span></span><br><span class="line">        maxlength = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length): <span class="comment">#i是下标</span></span><br><span class="line">            <span class="comment">#ord()获得ASCII码，实现字符相减</span></span><br><span class="line">            prevIndex = poslist[<span class="built_in">ord</span>(s[i])-<span class="built_in">ord</span>(<span class="string">'a'</span>)]</span><br><span class="line">      </span><br><span class="line">            <span class="keyword">if</span> (prevIndex &lt; <span class="number">0</span>) <span class="keyword">or</span> (i-prevIndex &gt; curlength):</span><br><span class="line">                <span class="comment">#字符【i】没有出现过或d&gt;F(i-1)</span></span><br><span class="line">                curlength = curlength + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curlength = i-prevIndex</span><br><span class="line">            <span class="keyword">if</span> curlength &gt; maxlength:</span><br><span class="line">                maxlength = curlength</span><br><span class="line">            poslist[<span class="built_in">ord</span>(s[i])-<span class="built_in">ord</span>(<span class="string">'a'</span>)] = i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxlength</span><br><span class="line"></span><br><span class="line">Solution().lengthOfLongestSubstring(<span class="string">'ancad'</span>)</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-49丑数-python</title>
    <url>/jzo49.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<h2 id="题目描述">题目描述：</h2>
<p>把只包含质因子2或3或5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<h2 id="第一想法">第一想法:</h2>
<ul>
<li>从头遍历，找出每一个丑数 如何判断是不是丑数</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetUglyNumber_Solution</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isUgly</span>(<span class="params">num</span>):</span></span><br><span class="line">            <span class="comment">#判断一个数是不是丑数</span></span><br><span class="line">            <span class="keyword">while</span> num%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                num = num//<span class="number">2</span></span><br><span class="line">            <span class="keyword">while</span> num%<span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">                num = num//<span class="number">3</span></span><br><span class="line">            <span class="keyword">while</span> num%<span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">                num = num//<span class="number">5</span></span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> index&lt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        uglyindex = <span class="number">0</span></span><br><span class="line">        number = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> uglyindex&lt;index:</span><br><span class="line">            number+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> isUgly(number):</span><br><span class="line">                uglyindex+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> number</span><br><span class="line"></span><br><span class="line">Solution().GetUglyNumber_Solution(<span class="number">7</span>)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="剑指offer方法">剑指offer方法：</h2>
<p><strong>生成丑数</strong>，以空间换时间</p>
<p>试着找到一种只计算丑数的方法，而不在非丑数的整数上花费时间。根据丑数的定义，丑数应该是另一个丑数乘以2、3或者5的结果（1除外）。</p>
<p>创建一个数组，里面是排好序的丑数，每个丑数都是前面的丑数乘以2、3或者5得到的。</p>
<p>假设此数组中已有的最大丑数是<strong>M</strong>，将数组里的每个丑数乘以2，直到得到第一个大于<strong>M</strong>的值<strong>M2</strong>，同理每个丑数乘以3或5得到<strong>M3</strong>，<strong>M5</strong>，那么<strong>M</strong>之后的下一个丑数就在<strong>M2</strong>,<strong>M3</strong>,<strong>M5</strong>之中的最小者。</p>
<p><strong>优化</strong></p>
<p>在前面分析的时候提到把已有的每个丑数分别乘以2、3和5.事实上这不是必需的，因为已有的丑数是按顺序存放在数组中的。对于乘以2而言，肯定存在某一个丑数<strong>T2</strong>，排在它之前的每个丑数乘以2得到的结果都会小于<strong>M</strong>，在它之后的每个丑数乘以2得到的结果都会大于<strong>M</strong>。</p>
<p>我们只需记下这个丑数的位置，同时每次生成新的丑数的时候去更新这个<strong>T2</strong>，下次乘以2就从<strong>T2</strong>开始。对于3和5而言，也存在同样的<strong>T3</strong>和<strong>T5</strong>。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetUglyNumber_Solution</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="keyword">if</span> index&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ugly_numbers = [<span class="number">1</span>]*index <span class="comment">#存储丑数的数组</span></span><br><span class="line">        next_ugly_index = <span class="number">1</span></span><br><span class="line">        t2index = t3index = t5index = <span class="number">0</span><span class="comment">#T2的索引，T3的索引，T5的索引</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> next_ugly_index &lt; index:</span><br><span class="line">            <span class="comment">#选择M2M3M5之中最小的作为下一个丑数</span></span><br><span class="line">            ugly_numbers[next_ugly_index] = <span class="built_in">min</span>(ugly_numbers[t2index]*<span class="number">2</span>, \</span><br><span class="line">            ugly_numbers[t3index]*<span class="number">3</span>, ugly_numbers[t5index]*<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#更新T2，T3，T5的位置索引</span></span><br><span class="line">            <span class="keyword">while</span> ugly_numbers[t2index] * <span class="number">2</span> &lt;= ugly_numbers[next_ugly_index]:</span><br><span class="line">                t2index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> ugly_numbers[t3index] * <span class="number">3</span> &lt;= ugly_numbers[next_ugly_index]:</span><br><span class="line">                t3index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> ugly_numbers[t5index] * <span class="number">5</span> &lt;= ugly_numbers[next_ugly_index]:</span><br><span class="line">                t5index += <span class="number">1</span></span><br><span class="line">            next_ugly_index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ugly_numbers[-<span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-4二维数组的查找-python</title>
    <url>/jz20191205er.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Find</span>(<span class="params">target, array</span>):</span></span><br><span class="line">    <span class="comment">#从左下角元素开始，target比当前元素小，向上找；比当前元素大，向右找。</span></span><br><span class="line">    rowNum = <span class="built_in">len</span>(array) <span class="comment">#行数</span></span><br><span class="line">    columnNum = <span class="built_in">len</span>(array[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> rowNum==<span class="number">0</span> <span class="keyword">or</span> columnNum==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    i = rowNum-<span class="number">1</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">and</span> j &lt; columnNum:</span><br><span class="line">        <span class="keyword">if</span> target == array[i][j]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> target &gt; array[i][j]:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></tbody></table></figure>
旧版本
<details>
<summary>第一个版本 运行时间：440ms 占用内存：6128k</summary> <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Find</span>(<span class="params">target, array</span>):</span></span><br><span class="line">    <span class="comment">#从左上角元素开始，有两种情况。</span></span><br><span class="line">    <span class="comment">#对每一行，比较行尾元素，确定在哪一行，再按列找</span></span><br><span class="line">    rowNum = <span class="built_in">len</span>(array)</span><br><span class="line">    columnNum = <span class="built_in">len</span>(array[<span class="number">0</span>])</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rowNum):</span><br><span class="line">        <span class="keyword">if</span> target &gt; array[i][columnNum-<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> target == array[i][columnNum-<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(columnNum):</span><br><span class="line">                <span class="keyword">if</span> target == array[i][j]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 比较每一行的行首，确定在哪一行，再按列找</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i, rowNum):</span><br><span class="line">        <span class="keyword">if</span> target &gt; array[i][<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> target == array[i][<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(columnNum):</span><br><span class="line">                <span class="keyword">if</span> target == array[i][j]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></tbody></table></figure>
</details>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-50第一个只出现一次的字符-python</title>
    <url>/jzo50.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<h2 id="题目描述">题目描述：</h2>
<p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.如“abaccdeff” ，则输出1.</p>
<h2 id="第一想法">第一想法:</h2>
<p>用一个hash表记录每个字符出现的次数，遍历hash表，如果次数是1，返回索引。但是python的dict是无序的。</p>
<h2 id="剑指offer方法">剑指offer方法：</h2>
<p>建立hash表后，不用遍历hahs表，遍历原字符串。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstNotRepeatingChar</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> <span class="built_in">len</span>(s)&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        elemNum = <span class="built_in">dict</span>() <span class="comment"># 统计每个字符出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> elem <span class="keyword">in</span> s:</span><br><span class="line">            elemNum[elem] = elemNum.get(elem,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> elemNum[s[i]] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="python方法">Python方法</h2>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstNotRepeatingChar</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> <span class="built_in">len</span>(s)&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s.count(s[i]) == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-51数组中的逆序对-python</title>
    <url>/jzo51.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<h2 id="题目描述">题目描述：</h2>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。如数组【7，6，5，4】中，一共有5个逆序对，分别是（7，6）（7，5）（7，4）（6，4）（5，4）</p>
<p>输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p>
<h2 id="第一想法">第一想法:</h2>
<p>遍历每个元素，，如果已经遍历过，就跳过。</p>
<p>将这个元素与它之前的所有元素比较，统计比它大的元素个数。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#暴力法,复杂度O(n^2)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">InversePairs</span>(<span class="params">self, data</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data)&lt;=<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    count=<span class="number">0</span></span><br><span class="line">    length=<span class="built_in">len</span>(data)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,length):</span><br><span class="line">            <span class="keyword">if</span> data[i]&gt;data[j]:</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count % <span class="number">1000000007</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="剑指offer方法">剑指offer方法：</h2>
<p>基于归并排序，递归，只是在排序过程中要统计逆序对个数</p>
<p>以【7，5，6，4】为例，设逆序对个数为N。</p>
<p><img src="https://myimg-1301063374.cos.ap-beijing.myqcloud.com/Snipaste_2020-03-22_17-03-21.png"></p>
<p>先把它分解成两个长度为2的子数组（如a），再把这两个子数组分别拆分成两个长度为1的子数组（如b）。</p>
<p>接下来边合并相邻的子数组，一边统计逆序对的数目。在第一对长度为1的子数组{7}、{5}中，7大于5，因此（7,5）组成一个逆序对，N=1。</p>
<p>同样，在第二对长度为1的子数组{6}、{4}中，也有逆序对（6,4），N+1=2。</p>
<p>由于我们已经统计了这两对子数组内部的逆序对，因此需要把这两对子数组排序（如c），以免在以后的统计过程中再重复统计。</p>
<p><strong>如何对两对子数组排序并再排序过程中更新N?</strong></p>
<ol type="1">
<li>设置两个指针分别指向两个子数组中的最大值，p1指向7，p2指向6</li>
<li>比较p1和p2指向的值，如果p1大于p2，因为p2指向的是最大值，所以第二个子数组中有几个元素就有几对逆序对(第二个子数组当前有两个元素，逆序对加2,N=N+2=4)，7&gt;6,比较完之后将p1指向的值放入辅助数组里，辅助数组里现在有一个数字7，然后将p1向前移动一位指向5</li>
<li>再次判断p1和p2指向的值，p1小于p2，因为p1指向的是第一个子数组中最大值，所以子数组中没有能和当前p2指向的6构成逆序对的数，将p2指向的值放入辅助数组，并向前移动一位指向4，此时辅助数组内为6,7</li>
<li>继续判断p1(指向5)和p2(指向4)，5&gt;4,第二个子数组中只有一个数字，逆序对加1，4+1=5。然后将5放入辅助数组，第一个子数组遍历完毕，只剩下第二个子数组，当前只有一个4，将4也放入辅助数组，函数结束。辅助数组此时为4,5,6,7.逆序对为5.</li>
</ol>
<p><strong>辅助数组有啥用？</strong>我们只要N就行了啊</p>
<p>答：用于保存排序好的结果，在递归排序的时候要用到上一步归并的结果</p>
<p>就比归并排序多了一步</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">InversePairs</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(data)&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        self.mergeSort(data)</span><br><span class="line">        <span class="keyword">return</span> self.count % <span class="number">1000000007</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span>(<span class="params">self,data</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(data) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line">        midIndex = <span class="built_in">len</span>(data)&gt;&gt;<span class="number">1</span></span><br><span class="line">        leftlist = self.mergeSort(data[:midIndex])</span><br><span class="line">        rightlist = self.mergeSort(data[midIndex:])</span><br><span class="line">        <span class="keyword">return</span> self.merge(leftlist,rightlist)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self,leftlist,rightlist</span>):</span></span><br><span class="line">        resultlist = [] <span class="comment">#辅助数组记录排序后的结果</span></span><br><span class="line">        i,j =<span class="built_in">len</span>(leftlist)-<span class="number">1</span>,<span class="built_in">len</span>(rightlist)-<span class="number">1</span> </span><br><span class="line">        <span class="comment">#注意这里ij初始化为最后一个元素，因为是从后往前比较，便于计算count</span></span><br><span class="line">        <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> leftlist[i] &gt; rightlist[j]:</span><br><span class="line">                self.count += (j+<span class="number">1</span>)<span class="comment">#就是比归并排序多了这一步</span></span><br><span class="line">                resultlist.append(leftlist[i]) <span class="comment">#按从大到小排</span></span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                resultlist.append(rightlist[j])</span><br><span class="line">                j -= <span class="number">1</span> </span><br><span class="line">        <span class="comment">#接上剩余的元素</span></span><br><span class="line">        resultlist = resultlist[::-<span class="number">1</span>] <span class="comment">#注意做个翻转</span></span><br><span class="line">        resultlist = leftlist[:i+<span class="number">1</span>] + resultlist</span><br><span class="line">        resultlist = rightlist[:j+<span class="number">1</span>] + resultlist</span><br><span class="line">        <span class="keyword">return</span> resultlist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Solution().InversePairs([<span class="number">7</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong>原超时代码</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#超时了，可能是list.insert（idnex，num）要比list.append（）复杂度高</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">InversePairs</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(data)&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        self.mergeSort(data)</span><br><span class="line">        <span class="keyword">return</span> self.count % <span class="number">1000000007</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span>(<span class="params">self,data</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(data) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line">        midIndex = <span class="built_in">len</span>(data)&gt;&gt;<span class="number">1</span></span><br><span class="line">        leftlist = self.mergeSort(data[:midIndex])</span><br><span class="line">        rightlist = self.mergeSort(data[midIndex:])</span><br><span class="line">        <span class="keyword">return</span> self.merge(leftlist,rightlist)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self,leftlist,rightlist</span>):</span></span><br><span class="line">        resultlist = [] <span class="comment">#辅助数组记录排序后的结果</span></span><br><span class="line">        i,j =<span class="built_in">len</span>(leftlist)-<span class="number">1</span>,<span class="built_in">len</span>(rightlist)-<span class="number">1</span> </span><br><span class="line">        <span class="comment">#注意这里ij初始化为最后一个元素，因为是从后往前比较，便于计算count</span></span><br><span class="line">        <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> leftlist[i] &gt; rightlist[j]:</span><br><span class="line">                self.count += (j+<span class="number">1</span>) <span class="comment">#就是比归并排序多了这一步</span></span><br><span class="line">                resultlist.insert(<span class="number">0</span>,leftlist[i]) <span class="comment">#头插法</span></span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                resultlist.insert(<span class="number">0</span>,rightlist[j])</span><br><span class="line">                j -= <span class="number">1</span> </span><br><span class="line">        <span class="comment">#接上剩余的元素</span></span><br><span class="line">        resultlist = leftlist[:i+<span class="number">1</span>] + resultlist</span><br><span class="line">        resultlist = rightlist[:j+<span class="number">1</span>] + resultlist</span><br><span class="line">        <span class="keyword">return</span> resultlist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Solution().InversePairs([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>])</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-52两个链表的第一个公共结点-python</title>
    <url>/jzo52.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<h2 id="题目描述">题目描述：</h2>
<p>输入两个链表，找出它们的第一个公共结点。</p>
<h2 id="第一想法">第一想法:</h2>
<p>a-&gt;b-&gt;c-&gt;d , h-&gt;b-&gt;c-&gt;d , 那么b是公共结点?</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#暴力法 O(mn)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> listA:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> listB:</span><br><span class="line">        <span class="keyword">if</span> i == j <span class="keyword">and</span> i.<span class="built_in">next</span> ==j.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="剑指offer方法一">剑指offer方法一：</h2>
<p>有公共结点，因为是单链表，只有一个next，说明尾部是相同的。</p>
<p>可以从尾部开始往前比较。那么最后一个相同的结点就是第一个公共结点。</p>
<p>但单链表只能从前往后比较，<strong>先进后出</strong></p>
<p>建立两个长度为m和n的辅助栈，mn分别是两个链表的长度。</p>
<h2 id="剑指offer方法二">剑指offer方法二：</h2>
<p>不需要辅助空间</p>
<p>首先遍历两个链表得到它们的长度，就能知道哪个链表比较长，以及长的链表比短的链表多几个节点。</p>
<p>在第二次遍历的时候，在较长的链表上先走若干步，接着同时在两个链表上遍历，找到的第一个相同的节点就是它们的第一个公共节点。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindFirstCommonNode</span>(<span class="params">self, pHead1, pHead2</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pHead1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> pHead2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        length1,length2=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        cur1,cur2 = pHead1,pHead2</span><br><span class="line">        <span class="comment">#计算两个链表的长度</span></span><br><span class="line">        <span class="keyword">while</span> cur1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: </span><br><span class="line">            length1 += <span class="number">1</span></span><br><span class="line">            cur1 = cur1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> cur2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            length2 += <span class="number">1</span></span><br><span class="line">            cur2 = cur2.<span class="built_in">next</span>  </span><br><span class="line">        </span><br><span class="line">        <span class="comment">#让长的链表先走</span></span><br><span class="line">        cur1,cur2 = pHead1,pHead2</span><br><span class="line">        <span class="keyword">if</span> length2 &gt; length1:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length2-length1):</span><br><span class="line">                cur2 = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">elif</span> length1 &gt; length2:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length1-length2):</span><br><span class="line">                cur1 = cur1.<span class="built_in">next</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">while</span> cur1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur1 == cur2:</span><br><span class="line">                <span class="keyword">return</span> cur1</span><br><span class="line">            cur1 = cur1.<span class="built_in">next</span></span><br><span class="line">            cur2 = cur2.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></tbody></table></figure>
<p>一次AC,好久没有过的感觉了</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-53在排序数组中查找数字-python</title>
    <url>/jzo53.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<h1 id="题目一">题目一：</h1>
<h2 id="数字在排序数组中出现的次数">数字在排序数组中出现的次数</h2>
<p>统计一个数字在排序数组中出现的次数。</p>
<p>统计一个数字在排序数组中出现的次数。例如，输入排序数组{1,2,3,3,3,3,4,5}和数字3，由于3在这个数组中出现了4次，因此输出4</p>
<h2 id="第一想法">第一想法:</h2>
<p><code>list.count</code></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNumberOfK</span>(<span class="params">self, data, k</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data  <span class="keyword">or</span> <span class="built_in">len</span>(data)&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> data.count(k)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="剑指offer方法">剑指offer方法：</h2>
<p>注意数组是有序的</p>
<p>二分查找，找到k，由于k出现多次，找到的k左右两边可能都有k，所以要在左右两边扫描，分别找出第一个和最后一个k。</p>
<p>但这种方法在长度为n的数组中有可能出现<strong>O（n）</strong>次，所以顺序扫描的时间复杂度是<strong>O（n）</strong>因此，这种算法的效率和直接从头到尾顺序扫描整个数组统计k出现的次数的方法是一样的。显然，面试官不会满意这个算法，他会提示我们还有更快的算法。</p>
<p><strong>改进</strong></p>
<p><strong>二分查找法，分别用二分查找法找到k在排序数组中第一次和最后一次出现的位置，然后次数等于两个位置之差加1。</strong></p>
<p>我们先分析如何用二分查找在数组中找到第一个k。二分查找总是先拿数组中间的数字和k作比较。</p>
<p>如果中间的数字比k大，那么k只出现在数组的前半段，下一轮我们只在数组的前半段查找就可以了。</p>
<p>如果中间的数字比k小，那么k只出现在数组的后半段，下一轮我们只在数组的后半段查找就可以了。</p>
<p>如果中间的数字和k相等呢？我们先判断这个数字是不是第一个k。如果中间数字的前面一个数字不是k，那么此时中间的数字刚好就是第一个k；如果中间数字的前面一个数字也是k，那么第一个k肯定在数组的前半段，下一轮我们仍然需要在数组的前半段查找。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNumberOfK</span>(<span class="params">self, data, k</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data  <span class="keyword">or</span> <span class="built_in">len</span>(data)&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        firstPos = self.getFirstKPos(data,k,<span class="number">0</span>,<span class="built_in">len</span>(data)-<span class="number">1</span>)</span><br><span class="line">        lastPos = self.getLastKPos(data,k,<span class="number">0</span>,<span class="built_in">len</span>(data)-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> firstPos&gt;-<span class="number">1</span> <span class="keyword">and</span> lastPos&gt;-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> lastPos-firstPos+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getFirstKPos</span>(<span class="params">self,data,k,start,end</span>):</span></span><br><span class="line">        <span class="comment"># 返回第一个k的下标</span></span><br><span class="line">        <span class="keyword">if</span> start &gt; end:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        midIndex = (start+end)&gt;&gt;<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> k == data[midIndex]:</span><br><span class="line">            <span class="keyword">if</span> (midIndex &gt;<span class="number">0</span> <span class="keyword">and</span> data[midIndex-<span class="number">1</span>]!=k) <span class="keyword">or</span> midIndex==<span class="number">0</span>:</span><br><span class="line">                <span class="comment">#前一个不是k，说明midk是第一个</span></span><br><span class="line">                <span class="keyword">return</span> midIndex</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = midIndex - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> k &gt; data[midIndex]:</span><br><span class="line">            start = midIndex + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            end = midIndex - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.getFirstKPos(data,k,start,end)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLastKPos</span>(<span class="params">self,data,k,start,end</span>):</span></span><br><span class="line">        <span class="keyword">if</span> start &gt; end:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        midIndex = (start+end)&gt;&gt;<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> k == data[midIndex]:</span><br><span class="line">            <span class="keyword">if</span> (midIndex &lt; end  <span class="keyword">and</span> data[midIndex+<span class="number">1</span>]!=k) <span class="keyword">or</span> midIndex==end:</span><br><span class="line">                <span class="comment">#后一个不是k，说明midk是最后一个</span></span><br><span class="line">                <span class="keyword">return</span> midIndex</span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#midK不是最右边的，后面还有，继续在右边找k的最后一次出现的位置</span></span><br><span class="line">                start = midIndex + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> k &gt; data[midIndex]:</span><br><span class="line">            start = midIndex + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            end = midIndex - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.getLastKPos(data,k,start,end)</span><br><span class="line"></span><br><span class="line">Solution().GetNumberOfK([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],<span class="number">3</span>)</span><br></pre></td></tr></tbody></table></figure>
<h1 id="题目二">题目二：</h1>
<h2 id="n-1中缺失的数字-一长度为n-1的递增排序数组中的所有数字都是唯一的并且每个数字都在范围0n-1之内在范围0n-1内的n个数字中有且只有一个数字不在该数组中请找出这个数字">0<sub>n-1中缺失的数字 一长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0</sub>n-1之内。在范围0~n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字</h2>
<h2 id="第一想法-1">第一想法:</h2>
<p>由题意知，元素和下标是相同的。</p>
<p>二分查找，如果下标比元素小，说明缺失的数字在前面，在前面找到第一个下标与数字不相同的下标就是缺失的元素。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetMissingNumber</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data  <span class="keyword">or</span> <span class="built_in">len</span>(data)&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        start,end = <span class="number">0</span>,<span class="built_in">len</span>(data)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">            midIndex = (start+end)&gt;&gt;<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> data[midIndex] != midIndex:</span><br><span class="line">                <span class="comment">#下标比元素小，说明缺失的数字在前面</span></span><br><span class="line">                <span class="keyword">if</span> midIndex == <span class="number">0</span> <span class="keyword">or</span> data[midIndex-<span class="number">1</span>] == midIndex-<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> midIndex</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    end = midIndex -<span class="number">1</span>    </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start = midIndex+<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br></pre></td></tr></tbody></table></figure>
<h1 id="题目三">题目三：</h1>
<h2 id="数组中数值和下标相等的元素">数组中数值和下标相等的元素</h2>
<p>假设一个单调递增的数组里的每个元素都是整数并且是唯一的。请编程实现一个函数，找出数组中任意一个数值等于其下标的元素。例如，在数组{-3，-1,1,3,5}中，数字3和它的下标相等。</p>
<h2 id="第一想法-2">第一想法:</h2>
<p>遍历</p>
<p>利用排序特点，二分查找</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetMissingNumber</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data  <span class="keyword">or</span> <span class="built_in">len</span>(data)&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        start,end = <span class="number">0</span>,<span class="built_in">len</span>(data)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">            midIndex = (start+end)&gt;&gt;<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> data[midIndex] == midIndex:</span><br><span class="line">                <span class="keyword">return</span> midIndex</span><br><span class="line">            <span class="keyword">elif</span> data[midIndex] &gt; midIndex:</span><br><span class="line">                <span class="comment">#下标比元素小，说明目标在前面</span></span><br><span class="line">                end = midIndex - <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#下标比元素大</span></span><br><span class="line">                start = midIndex + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-54二叉搜索树的第k大节点-python</title>
    <url>/jzo54.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<h2 id="题目描述">题目描述：</h2>
<p>给定一棵二叉搜索树，请找出其中的第k大的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值从小到大顺序第三大结点的值为4。</p>
<h2 id="第一想法">第一想法:</h2>
<p>先获得此二叉搜索树的中序遍历，然后返回第k个元素</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>   </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">KthNode</span>(<span class="params">self, pRoot, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot <span class="keyword">or</span> k&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        res=[]</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">pRoot</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">            inorder(pRoot.left)</span><br><span class="line">            res.append(pRoot)</span><br><span class="line">            inorder(pRoot.right)</span><br><span class="line">        inorder(pRoot)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(res)&lt;k:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> res[k-<span class="number">1</span>]</span><br></pre></td></tr></tbody></table></figure>
<h2 id="第二想法">第二想法:</h2>
<p>在进行遍历的时候，记录输出的节点数，到k时，return</p>
<p><strong>问题</strong>，如何跳出深层递归，使用return返回的是上一层</p>
<h2 id="剑指offer方法">剑指offer方法：</h2>
<p>跟我一样</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-55二叉树的深度-python</title>
    <url>/jzo55.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<h1 id="题目一">题目一：</h1>
<h2 id="二叉树的深度">二叉树的深度</h2>
<p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<h2 id="第一想法">第一想法:</h2>
<p>计算每条路径的长度，选择其中最大的</p>
<h2 id="剑指offer方法">剑指offer方法：</h2>
<p>递归</p>
<p>如果一棵树只有一个节点，那么它的深度为1.</p>
<p>如果根节点只有左子树而没有右子树，那么树的深度应该是其左子树的深度加1：</p>
<p>如果根节点只有右子树而没有左子树，那么树的深度应该是其右子树的深度加1</p>
<p>如果既有右子树又有左子树，那么该树的深度就是其左、右子树深度的较大值再加1.</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">TreeDepth</span>(<span class="params">self, pRoot</span>):</span></span><br><span class="line">        <span class="keyword">if</span> pRoot <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        leftdepth = self.TreeDepth(pRoot.left)</span><br><span class="line">        rightdepth = self.TreeDepth(pRoot.right)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(leftdepth,rightdepth) + <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="题目二">题目二：</h1>
<h2 id="平衡二叉树">平衡二叉树</h2>
<p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
<p>如果某二叉树中任意节点的左、右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>
<h2 id="剑指offer方法一">剑指offer方法一：</h2>
<p>遍历每个结点，计算左右子树的深度</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsBalanced</span>(<span class="params">self, pRoot</span>):</span></span><br><span class="line">        <span class="keyword">if</span> pRoot <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        leftdepth = self.TreeDepth(pRoot.left)</span><br><span class="line">        rightdepth = self.TreeDepth(pRoot.right)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(leftdepth-rightdepth) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.IsBalanced(pRoot.left) <span class="keyword">and</span> self.IsBalanced(pRoot.right)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">TreeDepth</span>(<span class="params">self, pRoot</span>):</span></span><br><span class="line">        <span class="comment">#返回当前节点的深度</span></span><br><span class="line">        <span class="keyword">if</span> pRoot <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        leftdepth = self.TreeDepth(pRoot.left)</span><br><span class="line">        rightdepth = self.TreeDepth(pRoot.right)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(leftdepth,rightdepth) + <span class="number">1</span>    </span><br></pre></td></tr></tbody></table></figure>
<h2 id="剑指offer方法二">剑指offer方法二：</h2>
<p>方法一的问题在于，自顶向下计算每个结点的深度，底层节点会被遍历很多次，</p>
<p>计算1的左子树深度时，depth(1.L)-&gt; depth(2.L) -&gt; depth(4.L)</p>
<p>计算2的左子树深度时，depth(2.L)-&gt; depth(4.L)</p>
<p><strong>因为1的左右子树深度之差不超过1不代表2的左右子树深度不超过1，所以要计算每个子树的深度</strong></p>
<p><strong>自底向上遍历</strong>，如果子树是平衡二叉树，则返回子树的高度；如果发现子树不是平衡二叉树，则直接停止遍历，这样至多只对每个结点访问一次。</p>
<p>检查每个子树是否是平衡的，若4是平衡的，5是平衡的，则2就是平衡的。</p>
<p>检查1的左子树深度时，dfs(1.L)-&gt; dfs(2.L) -&gt; dfs(4.L)</p>
<p><strong>如果1的左右子树是平衡的，那么2的左右子树一定是平衡的</strong>（因为是先2平衡向上得到1平衡的）</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsBalanced_Solution</span>(<span class="params">self, pRoot</span>):</span>        </span><br><span class="line">        <span class="keyword">return</span> self.check(pRoot) != -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">self, pRoot</span>):</span></span><br><span class="line">        <span class="comment">#-1表示不平衡</span></span><br><span class="line">        <span class="keyword">if</span> pRoot <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        leftdepth = self.check(pRoot.left)</span><br><span class="line">        <span class="keyword">if</span> leftdepth == -<span class="number">1</span>: <span class="comment">#若子树不平衡，直接return -1，返回上一层</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        rightdepth = self.check(pRoot.right)</span><br><span class="line">        <span class="keyword">if</span> rightdepth == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(leftdepth-rightdepth) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(leftdepth,rightdepth) + <span class="number">1</span>    </span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-56数组中数字出现的次数-python</title>
    <url>/jzo56.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<h1 id="题目一">题目一：</h1>
<h2 id="数组中只出现一次的两个数字">数组中只出现一次的两个数字</h2>
<p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<p>要求时间复杂度O(n) ，空间复杂度是O（1）</p>
<h2 id="第一想法">第一想法:</h2>
<p>没思路</p>
<h2 id="剑指offer方法">剑指offer方法：</h2>
<p>异或运算（转为二进制再异或，如2与4异或得110即6）</p>
<p>异或运算的一个性质：任何一个数字异或它自己都等于0.</p>
<p>也就是说，如果我们从头到尾依次异或数组中的每个数字，那么最终的结果刚好是那个只出现一次的数字，因为那些成对出现两次的数字全部在异或中抵消了.</p>
<p>比如（2，3，4，3，2）中，将2与3与4与3与2异或得到4的二进制0100</p>
<p>我们试着把原数组分成两个子数组，使得每个子数组包含一个只出现一次的数字，而其他数字都成对出现两次。如果能够这样拆分成两个数组，那么我们就可以按照前面的办法分别找出两个只出现一次的数字了。</p>
<p><strong>如何将这两个不同的数字分别分到两个子数组里？</strong></p>
<p>从头到尾依次异或数组中的每个数字，最终得到的结果就是两个只出现一次的数字的异或结果，因为其他数字都出现了两次，在异或中全部抵消了。由于这两个数字肯定不一样，那么异或的结果肯定不为0，即这个结果数字的二进制表示中至少有一位为1.我们在结果数字中找到第一个为1的位的位置，记为第n位。现在我们以第n位是不是1为标准把原数组中的数字分成两个子数组，第一个子数组中每个数字的第n位都是1，而第二个子数组中每个数字的第n位都是0.由于我们分组的标准是数字中的某一位是1还是0，那么出现了两次的数字肯定被分配到同一个子数组。因为两个相同的数字的任意一位都是相同的，我们不可能把两个相同的数字分配到两个子数组中去，于是我们已经把原数组分成了两个子数组，每个子数组都包含一个只出现一次的数字，而其他数字都出现了两次。我们已经知道如何在数组中找出唯一一个只出现一次的数字，因此，到此为止所有的问题都已经解决了。（妙啊）</p>
<p>举个例子，假设输入数组{2,4,3,6,3,2,5,5}。当依次对数组中的每个数字进行异或运算之后，得到的结果用二进制表示是0010（4和6的异或结果）.异或得到的结果中的倒数第二位是1，于是我们根据数字的倒数第二位是不是1将该数组分为两个子数组。第一个子数组{2,3,6,3,2}中所有数字的倒数第二位都是1，而第二个子数组{4,5,5}中所有数字的倒数第二位都是0.接下来只要分别对这两个子数组求异或，就能找出第一个子数组中只出现一次的数字是6，而第二个子数组中只出现一次的数字是4</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回[..a,b..] 其中a,b是出现一次的两个数字</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumsAppearOnce</span>(<span class="params">self, aarray</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(aarray) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        resultEOR = <span class="number">0</span> <span class="comment">#存储整个数组异或后的结果</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> elem <span class="keyword">in</span> aarray:</span><br><span class="line">            resultEOR = resultEOR ^ elem <span class="comment">#^是异或运算</span></span><br><span class="line">        </span><br><span class="line">        indexBit = self.FindFirstBit(resultEOR)<span class="comment">#找到异或结果最右边是1的位置下标</span></span><br><span class="line">        res1=res2=<span class="number">0</span></span><br><span class="line">        <span class="comment">#分成两个子数组</span></span><br><span class="line">        <span class="keyword">for</span> elem <span class="keyword">in</span> aarray:</span><br><span class="line">            <span class="keyword">if</span> self.IsBit(elem, indexBit):</span><br><span class="line">                res1 = res1^elem</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res2 = res2^elem</span><br><span class="line">        <span class="keyword">return</span> [res1,res2]</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindFirstBit</span>(<span class="params">self,num</span>):</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        用于在整数num的二进制表示中找到最右边是1的位的下标</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        indexBit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> num &amp; <span class="number">1</span> == <span class="number">0</span>: <span class="comment">#与1与运算为0说明最右边一位是1</span></span><br><span class="line">            num = num &gt;&gt; <span class="number">1</span> <span class="comment">#num右移一位，num可以是负数吗？</span></span><br><span class="line">            indexBit += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> indexBit</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsBit</span>(<span class="params">self,num,indexBit</span>):</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        用于判断在num的二进制表示中从右往左的indexBit位是否为1</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        num = num &gt;&gt; indexBit <span class="comment">#将num右移indexBit位后与1做与运算</span></span><br><span class="line">        <span class="keyword">return</span> num &amp; <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h1 id="题目二">题目二：</h1>
<h2 id="数组中唯一只出现一次的数字">数组中唯一只出现一次的数字</h2>
<p>在一个数组中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字</p>
<h2 id="剑指offer方法-1">剑指offer方法：</h2>
<p>我们还是可以沿用位运算的思路。如果一个数字出现三次，那么它的二进制表示的每一位（0或者1）也出现三次。如果把所有出现三次的数字的二进制表示的每一位都分别加起来，那么每一位的和都能被3整除。</p>
<p>我们把数组中所有数字的二进制表示的每一位都加起来。如果某一位的和不能被3整除，那么那个只出现一次的数字二进制表示中这一位是1.如果某一位的和能被3整除，说明那个数字的二进制表示中这一位是0.</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumsAppearOnce</span>(<span class="params">self, aarray</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> aarray <span class="keyword">or</span> <span class="built_in">len</span>(aarray) &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        bitSumlist = [<span class="number">0</span>]*<span class="number">32</span> </span><br><span class="line">        <span class="comment">#用一个长度为32的辅助数组存储二进制表示的每一位的和</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> elem <span class="keyword">in</span> aarray:</span><br><span class="line">            <span class="comment">#计算二进制每一位的和</span></span><br><span class="line">            bitMask = <span class="number">1</span> <span class="comment">#?</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">                bit = elem &amp; bitMask </span><br><span class="line">                <span class="keyword">if</span> bit != <span class="number">0</span>: <span class="comment">#说明elem的二进制表示从右往左的第bitMask位是1</span></span><br><span class="line">                    bitSumlist[i] += <span class="number">1</span></span><br><span class="line">                bitMask = bitMask &lt;&lt; <span class="number">1</span></span><br><span class="line">                <span class="comment">#不断将bitMask左移去与elem的二进制做与运算</span></span><br><span class="line">        </span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="comment">#假设aarray是【2，3，2，2】则bitSumlist=[30个0, 4, 1]</span></span><br><span class="line">        <span class="comment">#将二进制转换成10进制</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> bitSumlist[i] % <span class="number">3</span> != <span class="number">0</span>:</span><br><span class="line">                res = res + (<span class="number">1</span>&lt;&lt;(<span class="number">31</span>-i)) <span class="comment">#1&lt;&lt;N相当于2^N</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">Solution().FindNumsAppearOnce([<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>])</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-57和为s的数字-python</title>
    <url>/jzo57.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<h1 id="题目一">题目一：</h1>
<h2 id="和为s的数字">和为s的数字</h2>
<p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出任意一对</p>
<h2 id="第一想法">第一想法:</h2>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">    <span class="keyword">if</span> S-i <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">        retturn i, S-i</span><br></pre></td></tr></tbody></table></figure>
<h2 id="剑指offer方法">剑指offer方法：</h2>
<p>利用数组是排序的信息</p>
<p>先在数组中选择两个数字，一个在开头，一个在结尾，</p>
<p>如果它们的和等于输入的s，那么我们就找到了要找的两个数字。</p>
<p>如果和小于s？我们希望两个数字的和再大一点。由于数组已经排好序了，选择较小的数字后面的数字。因为排在后面的数字要大一些，那么两个数字的和也要大一些，就有可能等于输入的数字s了。</p>
<p>同样，当两个数字的和大于s的时候，可以选择较大数字前面的数字，因为排在数组前面的数字要小一些。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumbersWithSum</span>(<span class="params">self, array, tsum</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> array <span class="keyword">or</span> <span class="built_in">len</span>(array) &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        length = <span class="built_in">len</span>(array)</span><br><span class="line">        start,end = <span class="number">0</span>, length-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> start &lt; end:</span><br><span class="line">            <span class="keyword">if</span> tsum == array[start] + array[end]:</span><br><span class="line">                <span class="keyword">return</span> array[start],array[end]</span><br><span class="line">            <span class="keyword">elif</span> tsum &gt; array[start]+array[end]:</span><br><span class="line">                <span class="comment">#我们希望数字小一些</span></span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">Solution().FindNumbersWithSum([<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>],<span class="number">15</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>牛客网要求返回乘积最小的两个数，其实是一样的，因为两个数越接近它们的乘积越大。</p>
<p>我们从两边开始找，找到的第一个就是乘积最小的。</p>
<h1 id="题目二">题目二：</h1>
<h2 id="和为s的连续正数序列">和为s的连续正数序列</h2>
<p>输入一个正数s，打印出所有和为s的连续正数序列（至少含有两个数）。例如，输入15，由于1+2+3+45=4+5+6=7+8=15，所以打印出3个连续序列1<sub>5、4</sub>6和7~8</p>
<h2 id="剑指offer方法-1">剑指offer方法：</h2>
<p>有了解决前面问题的经验，我们也考虑用两个数small和big分别表示序列的最小值和最大值。</p>
<p>首先把small初始化为1，big初始化为2.</p>
<p>如果从small到big的序列的和大于s，则从序列中去掉较小的值，也就是增大small的值。</p>
<p>如果从smal到big的序列的和小于s，则可以增大big，让这个序列包含更多的数字。因为这个序列至少要有两个数字，我们一直增加small到 $ (1+s) / 2 $ 为止。（只要两个数组成序列，那只能是s的一半附近）</p>
<p>以求和为9的所有连续序列为例，我们先把small初始化为1，big初始化为2.此时介于small和big之间的序列是{1,2}，序列的和为3，小于9，所以我们下一步要让序列包含更多的数字。我们把big增加1变成3，此时序列为{1,2,3}。由于序列的和是6，仍然小于9，我们接下来再增加big变成4，介于 small和big之间的序列也随之变成{1,2,3,4}。由于序列的和10大于9，我们要删去序列中的一些数字，于是我们增加 small变成2，此时得到的序列是{2,3,4}，序列的和正好是9.我们找到了第一个和为9的连续序列，把它打印出来。接下来我们再增加big，重复前面的过程，可以找到第二个和为9的连续序列{4,5}。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindContinuousSequence</span>(<span class="params">self, tsum</span>):</span></span><br><span class="line">        <span class="keyword">if</span> tsum &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        small,big,cursum = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">        middle = (tsum+<span class="number">1</span>)&gt;&gt;<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> small &lt; middle:</span><br><span class="line">            <span class="keyword">if</span> tsum == cursum:</span><br><span class="line">                res.append([i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(small,big+<span class="number">1</span>)])</span><br><span class="line">            <span class="keyword">while</span> cursum &gt; tsum <span class="keyword">and</span> small &lt; middle:</span><br><span class="line">                <span class="comment">#我们希望数字小一些，增加small</span></span><br><span class="line">                cursum -= small</span><br><span class="line">                small += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> tsum == cursum:</span><br><span class="line">                    res.append([i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(small,big+<span class="number">1</span>)])</span><br><span class="line">            big += <span class="number">1</span></span><br><span class="line">            cursum += big</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">Solution().FindContinuousSequence(<span class="number">3</span>)</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-58翻转字符串-python</title>
    <url>/jzo58.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<h1 id="题目一">题目一：</h1>
<h2 id="翻转单词顺序">翻转单词顺序</h2>
<p>输输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串"Iama student."，则输出" 'student.aamI"。</p>
<h2 id="第一想法">第一想法:</h2>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseSentence</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        s = s.split(<span class="string">' '</span>)</span><br><span class="line">        sreversed = <span class="string">" "</span>.join(s[::-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> sreversed</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="剑指offer方法">剑指offer方法：</h2>
<p>第一步翻转句子中所有的字符。比如翻转" I am a student."中所有的字符得到" .tneduts a ma I"，此时不但翻转了句子中单词的顺序，连单词内的字符顺序也被翻转了。</p>
<p>第二步再翻转每个单词中字符的顺序，就得到了" 'student. a am I"。这正是符合题目要求的输出。</p>
<p>在英语句子中，单词被空格符号分隔，可以通过扫描空格来确定每个单词的起始和终止位置。指针Begin指向单词的第一个字符，而指针pEnd指向单词的最后一个字符。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseSentence</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> <span class="built_in">len</span>(s) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        pBegin,pEnd = <span class="number">0</span>,<span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line">        s = <span class="built_in">list</span>(s)</span><br><span class="line">        self.Reverse(s,pBegin,pEnd) <span class="comment">#反转整个句子</span></span><br><span class="line"></span><br><span class="line">        pBegin,pEnd = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> pEnd&lt;<span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">if</span> s[pBegin] == <span class="string">' '</span>:</span><br><span class="line">                pBegin += <span class="number">1</span></span><br><span class="line">                pEnd += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> s[pEnd] == <span class="string">' '</span>:<span class="comment">#end指向单词结尾，翻转单词</span></span><br><span class="line">                pEnd -= <span class="number">1</span> <span class="comment">#不翻转空格</span></span><br><span class="line">                self.Reverse(s,pBegin,pEnd)</span><br><span class="line">                pEnd += <span class="number">1</span> <span class="comment">#再重定位到空格</span></span><br><span class="line">                pBegin = pEnd</span><br><span class="line">            <span class="keyword">elif</span> pEnd == <span class="built_in">len</span>(s) -<span class="number">1</span>:</span><br><span class="line">                <span class="comment">#最后一个没有空格，也要进行翻转</span></span><br><span class="line">                self.Reverse(s,pBegin,pEnd)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#在单词中的情况</span></span><br><span class="line">                pEnd += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(s)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Reverse</span>(<span class="params">self,s,pBegin,pEnd</span>):</span></span><br><span class="line">        <span class="keyword">while</span> pBegin &lt; pEnd:</span><br><span class="line">            s[pBegin],s[pEnd] = s[pEnd],s[pBegin]</span><br><span class="line">            pBegin += <span class="number">1</span></span><br><span class="line">            pEnd -= <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h1 id="题目二">题目二：</h1>
<h2 id="左旋转字符串">左旋转字符串</h2>
<p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。</p>
<p>比如，输入字符串" abcdefg"和数字2，该函数将返回左旋转两位得到的结果" cdefgab'</p>
<h2 id="第一想法-1">第一想法：</h2>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LeftRotateString</span>(<span class="params">self, s, n</span>):</span></span><br><span class="line">        <span class="keyword">return</span> s[n:]+s[:n]</span><br></pre></td></tr></tbody></table></figure>
<h2 id="剑指offer方法-1">剑指offer方法：</h2>
<p>可以从解决第一个问题的思路中找到启发，<strong>3次Reverse操作</strong></p>
<p>在第一个问题中，如果输入的字符串之中只有两个单词，比如" hello world"，那么翻转这个句子中的单词顺序就得到了" world hello"。比较这两个字符串，我们是不是可以把" world hello”看成把原始字符串" hello world"的前面若干个字符转移到后面？也就是说这两个问题是非常相似的，我们同样可以通过翻转字符串的办法来解决第二个问题。</p>
<p>以" abcdefg"为例，我们可以把它分为两部分ab 和 cdefg。由于想把它的前两个字符移到后面，我们就把前两个字符分到第一部分，把后面的所有字符分到第二部分。我们先分别翻转这两部分，于是就得到" bagfedc"。接下来翻转整个字符串，得到的" cdefgab"刚好就是把原始字符串左旋转两位的结果。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LeftRotateString</span>(<span class="params">self, s, n</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> n&gt;<span class="built_in">len</span>(s) <span class="keyword">or</span> n&lt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span> <span class="keyword">or</span> n == <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s)&gt;<span class="number">0</span> <span class="keyword">and</span> <span class="number">0</span>&lt;n&lt;<span class="built_in">len</span>(s):</span><br><span class="line">            <span class="comment">#先分成两部分，分别翻转</span></span><br><span class="line">            start1,end1 = <span class="number">0</span>, n-<span class="number">1</span></span><br><span class="line">            start2,end2 = n,<span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line">            s = <span class="built_in">list</span>(s)</span><br><span class="line">            self.reverse(s,start1,end1)</span><br><span class="line">            self.reverse(s,start2,end2)</span><br><span class="line">            <span class="comment">#再翻转整个句子</span></span><br><span class="line">            self.reverse(s,start1,end2)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span>.join(s)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">self, data, start, end</span>):</span></span><br><span class="line">        <span class="keyword">while</span> start &lt; end:</span><br><span class="line">            data[start], data[end] = data[end], data[start]</span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">            end -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Solution().LeftRotateString(<span class="string">"abcdefg"</span>,<span class="number">7</span>)</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-59队列的最大值-python</title>
    <url>/jzo59.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<h1 id="题目一">题目一：</h1>
<h2 id="滑动窗口的最大值">滑动窗口的最大值</h2>
<p>给定一个数组和滑动窗口的大小，请找出所有滑动窗口里的最大值。 例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，它们的最大值分别为{4,4,6,6,6,5}。</p>
<h2 id="第一想法">第一想法:</h2>
<p>扫描每个滑动窗口的所有数字，并找出其中的最大值,时间复杂度为O(n*size)</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxInWindows</span>(<span class="params">self, num, size</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> num <span class="keyword">or</span> size &lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(num)-size+<span class="number">1</span>):</span><br><span class="line">            res.append(<span class="built_in">max</span>(num[i:i+size]))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="剑指offer方法">剑指offer方法：</h2>
<p>利用<strong>两端开口的队列</strong>，时间复杂度O（n）</p>
<p>我们并不把滑动窗口的每个数值都存入队列，而是只把有可能成为滑动窗口最大值的数值存入一个两端开口的队列。</p>
<p>以输入数组{2,3,4,2,6,2,5,1}为例</p>
<p>第一个数字是2，把它存入队列,队列是【2】。第二个数字是3，由于它比前个数字2大，因此2不可能成为滑动窗口中的最大值。先把2从队列里删除，再把3存入队列，【3】。此时队列中只有一个数字3.针对第三个数字4的步骤类似，最终在队列中只剩下一个数字4，【4】.此时滑动窗口中已经有3个数字，而它的最大值4位于队列的头部。</p>
<p>接下来处理第四个数字2.2比队列中的数字4小。当4滑出窗口之后，2还是有可能成为滑动窗口中的最大值，因此把2存入队列的尾部【4，2】。</p>
<p>第五个数字是6.由于它比队列中已有的两个数字4和2都大，因此这时4和2已经不可能成为滑动窗口中的最大值了。先把4和2从队列中删除，再把数字6存入队列，【6】。这时候最大值6仍然位于队列的头部。 第六个数字是2.由于它比队列中已有的数字6小，所以把2也存入队列的尾部【6，2】。此时队列中有两个数字，其中最大值6位于队列的头部。 第七个数字是5.在队列中已有的两个数字6和2里，2小于5，因此2不可能是一个滑动窗口的最大值，可以把它从队列的尾部删除。删除数字2之后，再把数字5存入队列【6，5】。此时队列里剩下两个数字6和5，其中位于队列头部的是最大值6。 数组最后一个数字是1，把1存入队列的尾部。注意到位于队列头部的数字6是数组的第五个数字，此时的滑动窗口己经不包括这个数字了，因此应该把数字6从队列中删除。</p>
<p>那么怎么知道滑动窗口是否包括一个数字（怎么知道一个数字是否在滑动窗口外了呢）？ <strong>应该在队列里存入数字在数组里的下标，而不是数值</strong>。<strong>当一个数字的下标与当前处理的数字的下标之差大于或者等于滑动窗口的大小时，这个数字已经从窗口中滑出，可以从队列中删除了</strong>。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxInWindows</span>(<span class="params">self, num, size</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> num <span class="keyword">or</span> size&lt;=<span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(num)&lt;size:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        deque = [] <span class="comment">#双向队列,存储下标</span></span><br><span class="line">        <span class="comment">#队首表示当前滑动窗口最大值，将候选值放入队尾</span></span><br><span class="line">        <span class="comment">#比队尾元素小就加入，比它大就删除队尾元素并加入</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#先处理第一个滑动窗口</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            <span class="keyword">while</span> deque <span class="keyword">and</span> num[i] &gt; num[deque[-<span class="number">1</span>]]:</span><br><span class="line">                deque.pop() <span class="comment">#删除队尾元素下标</span></span><br><span class="line">            deque.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size,<span class="built_in">len</span>(num)):</span><br><span class="line">            res.append(num[deque[<span class="number">0</span>]])</span><br><span class="line">            <span class="keyword">while</span> deque <span class="keyword">and</span> num[i] &gt; num[deque[-<span class="number">1</span>]]:</span><br><span class="line">                deque.pop()</span><br><span class="line">            <span class="keyword">while</span> deque <span class="keyword">and</span> deque[<span class="number">0</span>] &lt;= i-size:</span><br><span class="line">                <span class="comment">#队首元素在滑动窗口外了</span></span><br><span class="line">                deque.pop(<span class="number">0</span>)</span><br><span class="line">            deque.append(i)</span><br><span class="line">        res.append(num[deque[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong>deque</strong>是一个两端开口的队列，用来保存有可能是滑动窗口最大值的数字的下标。在存入一个数字的下标之前，首先要判断队列里已有数字是否小于待存入的数字。</p>
<p>如果已有的数字小于待存入的数字，那么已有的数字不可能是滑动窗口的最大值，因此它们将会被依次从队列的尾部删除。同时，如果队列头部的数字已经从滑动窗口里滑出，那么滑出的数字也需要从队列的头部删除。由于队列的头部和尾部都有可能删除数字，这也是需要两端开口的队列的原因。</p>
<h1 id="题目二">题目二：</h1>
<h2 id="队列的最大值">队列的最大值</h2>
<p>请定义一个队列并实现函数max得到队列里的最大值，要求函数pushback和 popfront的时间复杂度都是O（1）。</p>
<h2 id="剑指offer方法-1">剑指offer方法：</h2>
<p>滑动窗口可以看成一个队列，因此上题的解法可以用来实现带max函数的队列。</p>
<p><a href="https://github.com/BluesChang/Algorithms/blob/master/剑指Offer/59-2-队列的最大值.py">https://github.com/BluesChang/Algorithms/blob/master/%E5%89%91%E6%8C%87Offer/59-2-%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC.py</a></p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-5替换空格-python</title>
    <url>/jzo5.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p>开辟一个新字符串 还是在原有字符串上进行操作. 在原字符串上进行操作，从前往后处理，有的字符串要重复移动多次。 书上说可以考虑从后往前复制，减少移动次数。 由于python的str不可变，要将其转为list，导致按书上思路来速度并不占优势</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">replaceSpace3</span>(<span class="params">s</span>):</span> <span class="comment">#速度最快</span></span><br><span class="line">    <span class="keyword">return</span> s.replace(<span class="string">' '</span>, <span class="string">'%20'</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<details>
<summary>书上的思路</summary> <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">replaceSpace1</span>(<span class="params">s</span>):</span><span class="comment">#书上的思路，要转list不如方法二快</span></span><br><span class="line">    s=<span class="built_in">list</span>(s) <span class="comment">#转为list，因为str不可变</span></span><br><span class="line">    <span class="comment">#先遍历一次计算出空格数量，得到替换后的总长度</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> char == <span class="string">' '</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    n1 = <span class="built_in">len</span>(s)</span><br><span class="line">    n2 = n1 + i*<span class="number">2</span> <span class="comment">#替换后的总长度</span></span><br><span class="line">    s += [<span class="literal">None</span>]*i*<span class="number">2</span> <span class="comment">#扩大容量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#从后往前处理</span></span><br><span class="line">    p1 = n1-<span class="number">1</span> <span class="comment">#p1指向原字符串末尾字符</span></span><br><span class="line">    p2 = n2-<span class="number">1</span> <span class="comment">#p2指向替换空格后字符串末尾字符</span></span><br><span class="line">    <span class="keyword">while</span> p1 &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> s[p1] != <span class="string">' '</span>:</span><br><span class="line">            s[p2] = s[p1]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            s[p2] = <span class="string">'0'</span></span><br><span class="line">            p2 -= <span class="number">1</span></span><br><span class="line">            s[p2] = <span class="string">'2'</span></span><br><span class="line">            p2 -=<span class="number">1</span></span><br><span class="line">            s[p2] = <span class="string">'%'</span></span><br><span class="line">    </span><br><span class="line">        p1 -= <span class="number">1</span></span><br><span class="line">        p2 -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(s) <span class="comment">#list转为str</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">replaceSpace2</span>(<span class="params">s</span>):</span><span class="comment">#速度快于1</span></span><br><span class="line">    s=<span class="built_in">list</span>(s) <span class="comment">#转为list，因为str不可变</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">' '</span>:</span><br><span class="line">            s[i] = <span class="string">'%20'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(s) <span class="comment">#list转为str</span></span><br></pre></td></tr></tbody></table></figure>
</details>
<details>
<summary>第一个版本</summary> <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="string">"""开辟新空间"""</span></span><br><span class="line">    <span class="comment"># temp=""</span></span><br><span class="line">    <span class="comment"># for i in s:</span></span><br><span class="line">    <span class="comment">#     if i == ' ':</span></span><br><span class="line">    <span class="comment">#         temp += "%20"</span></span><br><span class="line">    <span class="comment">#     else:</span></span><br><span class="line">    <span class="comment">#         temp += i</span></span><br><span class="line">    <span class="comment"># s=temp</span></span><br><span class="line">    <span class="string">"""在原字符串上操作"""</span></span><br><span class="line">    n=<span class="built_in">len</span>(s)</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> char== <span class="string">' '</span>:</span><br><span class="line">           <span class="comment"># for j in range(i+1, n): #每进行一次替换空格后内容都要往后移动2个位置</span></span><br><span class="line">                <span class="comment"># s[j] = s[j+2] #报错，因为str是不可变数据类型</span></span><br><span class="line">            s = s[:i] + <span class="string">"%20"</span> + s[i+<span class="number">1</span>:]</span><br><span class="line">            i += <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></tbody></table></figure>
</details>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-60n个骰子的点数-python</title>
    <url>/jzo60.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<h1 id="section"></h1>
<h2 id="题目描述">题目描述</h2>
<p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[[1, 0.17], [2, 0.17], [3, 0.17], [4, 0.17], [5, 0.17], [6, 0.17]]</span><br><span class="line">解释：掷一次骰子，向上的数字和可能为1,2,3,4,5,6，出现的概率均为 0.17。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：[[2,0.03],[3,0.06],[4,0.08],[5,0.11],[6,0.14],[7,0.17],[8,0.14],[9,0.11],[10,0.08],[11,0.06],[12,0.03]]</span><br><span class="line">解释：掷两次骰子，向上的数字和可能在[2,12]，出现的概率是不同的。</span><br></pre></td></tr></tbody></table></figure>
<h2 id="剑指offer方法">剑指offer方法：</h2>
<p><strong>动态规划</strong></p>
<p>n个骰子的点数和的最小值是n，最大值是6n,所有可能出现的情况为$6^n $ ，我们要做的是求点数之和出现的概率，计算</p>
<p><span class="math display">\[ \frac{count(sum=n)}{6^n}  ,..., \frac{count(sum=6n)}{6^n} \]</span></p>
<p>现在我们考虑如何统计每个点数出现的次数。要想求出n个骰子的点数和，可以先把n个骰子分为两堆：第一堆只有一个：另一堆有n-1个。 单独的那一个有可能出现1<sub>6的点数。我们需要计算1</sub>6的每一种点数与剩下的n-1个骰子来计算点数之和。</p>
<p>动态规划</p>
<p>状态标识<strong>dp【n】【sum】</strong>，表示投掷完<strong>n</strong>个骰子后，点数之和<strong>sum</strong>出现的所有情况的次数，</p>
<p><span class="math display">\[ dp[n][sum]  = dp[n-1][sum-1] +dp[n-1][sum-2]+ ... + dp[n-1][sum-6] \]</span></p>
<p>单单看第n枚骰子，它的点数可能为 1, 2, 3, 4, 5, 6.因此投掷完 n 枚骰子后点数sum出现的次数，可以由投掷完n-1 枚骰子后，对应点数 sum-1, sum-2 ,...,sum−6 出现的次数之和转化过来。</p>
<p>初始状态位，<span class="math inline">\(dp[1][1] = dp[1][2]=...=dp[1][6]=1\)</span></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_probability</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="keyword">if</span> n&lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        rows,cols = n+<span class="number">1</span>,<span class="number">6</span>*n+<span class="number">1</span>  <span class="comment">#保留0个骰子情况</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(cols)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(rows)] </span><br><span class="line">        <span class="comment">#1个骰子时的初始值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">7</span>):</span><br><span class="line">            dp[<span class="number">1</span>][i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>): <span class="comment">#2到n个骰子时</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,<span class="number">6</span>*i+<span class="number">1</span>):<span class="comment">#可能出现的点数之和</span></span><br><span class="line">                <span class="keyword">for</span> cur <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> j-cur&lt;=<span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    dp[i][j] += dp[i-<span class="number">1</span>][j-cur]</span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        allcount = <span class="built_in">pow</span>(<span class="number">6</span>,n)*<span class="number">1.0</span> <span class="comment">#所有情况出现的次数,转成float</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n,<span class="number">6</span>*n+<span class="number">1</span>):</span><br><span class="line">            res.append(dp[n][i]/allcount)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">Solution().print_probability(<span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="空间优化">空间优化</h3>
<p>每个阶段的状态都只和它前一阶段的状态有关，因此我们不需要用额外的一维来保存所有阶段。</p>
<p>f【2】【9】=f【1】【8】+f【1】【7】+f【1】【6】+。。。+f【1】【3】</p>
<p>f【2】【5】=f【1】【4】+f【1】【3】+f【1】【2】+f【1】【1】</p>
<p>f【2】【4】=f【1】【3】+f【1】【2】+f【1】【1】</p>
<p>简化成</p>
<p>f【sum】=f【sum-1】+f【sum-2】+ 。。。+f【sum-6】</p>
<p>用一维数组来保存一个阶段的状态，然后对下一个阶段可能出现的点数 j从大到小遍历，实现一个阶段到下一阶段的转换。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_probability</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="keyword">if</span> n&lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        cols = <span class="number">6</span>*n+<span class="number">1</span>  <span class="comment">#保留0个骰子情况</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(cols)] </span><br><span class="line">        <span class="comment">#1个骰子时的初始值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">7</span>):</span><br><span class="line">            dp[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):<span class="comment">#2到n个骰子时</span></span><br><span class="line">            <span class="comment"># for j in range(i,6*i+1,1):#可能出现的点数之和</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>*i,i-<span class="number">1</span>,-<span class="number">1</span>):<span class="comment">#注意这里要从后往前算，</span></span><br><span class="line">            <span class="comment">#如果从前往后算，计算do【3】使用的dp【2】是当前骰子的次数，不是n-1个骰子的次数</span></span><br><span class="line">                dp[j] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> cur <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> j-cur&lt;=<span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    dp[j] += dp[j-cur]</span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        allcount = <span class="built_in">pow</span>(<span class="number">6</span>,n)*<span class="number">1.0</span> <span class="comment">#所有情况出现的次数,转成float</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n,<span class="number">6</span>*n+<span class="number">1</span>):</span><br><span class="line">            res.append(dp[i]/allcount)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>
<p>Re： https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/solution/nge-tou-zi-de-dian-shu-dong-tai-gui-hua-ji-qi-yo-3/</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-61扑克牌中的顺子-python</title>
    <url>/jzo61.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<h2 id="题目描述">题目描述</h2>
<p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2~10为数字本身，A为1，J为11，Q为12，K为13，而大、小王可以看成任意数字。</p>
<h2 id="剑指offer方法">剑指offer方法：</h2>
<p>就是判断一个数组是不是连续的</p>
<p>将大王小王用0表示，我们分析怎样判断5个数字是不是连续的，最直观的方法是把数组排序。值得注意的是，由于0可以当成任意数字，我们可以用0去补满数组中的空缺。如果排序之后的数组不是连续的，即相邻的两个数字相隔若干个数字，那么只要我们有足够的0可以补满这两个数字的空缺，这个数组实际上还是连续的。举个例子，数组排序之后为{0,1,3,4,5}，在1和3之间空缺了一个2，刚好我们有一个0，也就是我们可以把它当成2去填补这个空缺。</p>
<p>因此，我们需要做3件事情：</p>
<p>首先把数组排序：</p>
<p>其次统计数组中0的个数；</p>
<p>最后统计排序之后的数组中相邻数字之间的空缺总数。</p>
<p>如果空缺的总数小于或者等于0的个数，那么这个数组就是连续的：反之则不连续</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsContinuous</span>(<span class="params">self, numbers</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers <span class="keyword">or</span> <span class="built_in">len</span>(numbers)&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment">#1.排序</span></span><br><span class="line">        nums = <span class="built_in">sorted</span>(numbers)</span><br><span class="line">        <span class="comment">#2 统计数组中0的个数</span></span><br><span class="line">        num_of_zero = nums.count(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">#3统计排序之后的数组中相邻数字之间的空缺总数</span></span><br><span class="line">        num_of_gap = <span class="number">0</span></span><br><span class="line">        small = num_of_zero <span class="comment">#让下标指向起始位置</span></span><br><span class="line">        big = small +<span class="number">1</span> <span class="comment"># big指向small后一位</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> big &lt; <span class="built_in">len</span>(numbers):</span><br><span class="line">            <span class="keyword">if</span> nums[small] == nums[big]:</span><br><span class="line">                <span class="comment">#有两张相同的数字不可能连续</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            num_of_gap += nums[big]-nums[small] -<span class="number">1</span></span><br><span class="line">            small += <span class="number">1</span></span><br><span class="line">            big += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span> <span class="keyword">if</span> num_of_gap &gt; num_of_zero <span class="keyword">else</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">Solution().IsContinuous([<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>])</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-62圆圈中最后剩下的数字-python</title>
    <url>/jzo62.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<h2 id="题目描述">题目描述</h2>
<p>0,1，…n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p>
<h2 id="第一想法">第一想法：</h2>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">        nlist = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n) ]</span><br><span class="line">        print(nlist)</span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(nlist)&gt;<span class="number">1</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count % m == <span class="number">0</span>:</span><br><span class="line">                nlist.pop(<span class="string">''</span>)</span><br><span class="line"><span class="comment"># 如何让链表变成环        </span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="剑指offer方法一">剑指offer方法一：</h2>
<p>约瑟夫环Josephuse问题</p>
<p>用环形链表模拟环</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = value</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LastRemaining_Solution</span>(<span class="params">self, n, m</span>):</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">0</span> <span class="keyword">or</span> m&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="comment">#构造环形链表</span></span><br><span class="line">        phead = cur = Node(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            newnode = Node(i)</span><br><span class="line">            cur.<span class="built_in">next</span> = newnode</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        cur.<span class="built_in">next</span> = phead <span class="comment">#构成环</span></span><br><span class="line">        </span><br><span class="line">        cur = phead</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">id</span>(cur.<span class="built_in">next</span>) != <span class="built_in">id</span>(cur):<span class="comment">#注意：通过id来判断是不是只剩下一个</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m-<span class="number">1</span>):</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="comment">#删除第m个结点</span></span><br><span class="line">            pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur = pre.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> cur.val</span><br><span class="line"></span><br><span class="line">Solution().LastRemaining_Solution(<span class="number">5</span>,<span class="number">3</span>)</span><br></pre></td></tr></tbody></table></figure>
<p><strong>缺点</strong></p>
<p>许多结点重复遍历，而且需要额哇id辅助链表</p>
<h2 id="剑指offer方法二">剑指offer方法二：</h2>
<p>利用约瑟夫环的公式</p>
<p><span class="math display">\[F （ n , m） = 0 \]</span> n=1</p>
<p><span class="math display">\[F （ n , m） = (f(n-1,m) + m) \% n\]</span> n&gt; 1</p>
<p><span class="math inline">\(F (n , m )\)</span> 表示n个人报数，每报到m时杀掉的那个人，最终胜利者的编号</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LastRemaining_Solution</span>(<span class="params">self, n, m</span>):</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">0</span> <span class="keyword">or</span> m&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        last = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            last = (last + m)%i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> last</span><br><span class="line">        </span><br><span class="line">Solution().LastRemaining_Solution(<span class="number">5</span>,<span class="number">3</span>)</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-63股票的最大利润-python</title>
    <url>/jzo63.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<h2 id="题目描述">题目描述</h2>
<p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？例如，一只股票在某些时间节点的价格为{9,11,8,5,7,12,16,14}。如果我们能在价格为5的时候买入并在价格为16时卖出，则能收获最大的利润11。</p>
<h2 id="第一想法">第一想法：</h2>
<p>max(list) - min(list)</p>
<p>不行，要考虑时间，如果【16，11，4，10】最大利润是6</p>
<h2 id="剑指offer方法">剑指offer方法：</h2>
<p>我们不难想到用蛮力法来解决这个问题，也就是找出数组中所有的数对，并逐一求出它们的差值。该算法的时间复杂度是<span class="math inline">\(O（n^2）\)</span> .</p>
<p>我们也可以换一种思路。我们先定义函数 <strong>diff(i)</strong> 为当卖出价为数组中第 <strong>i</strong>个数字时可能获得的最大利润。显然，在卖出价固定时，买入价越低获得的利润越大。也就是说，如果在扫描到数组中的第i个数字时，只要我们能够<strong>记住之前的 i-1个数字中的最小值</strong>，就能算出在当前价位卖出时可能得到的最大利润。基于这种思路的代码如下：`</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MaxDiff</span>(<span class="params">self, numbers</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers <span class="keyword">or</span> <span class="built_in">len</span>(numbers) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        minnum = numbers[<span class="number">0</span>]</span><br><span class="line">        maxDiff = numbers[<span class="number">1</span>] - minnum</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(numbers)):</span><br><span class="line">            <span class="keyword">if</span> minnum &gt; numbers[i-<span class="number">1</span>]:</span><br><span class="line">                minnum = numbers[i-<span class="number">1</span>]</span><br><span class="line">            curdiff = numbers[i] - minnum</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">if</span> curdiff &gt; maxDiff:</span><br><span class="line">                maxDiff = curdiff</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxDiff</span><br><span class="line">        </span><br><span class="line">Solution().MaxDiff([<span class="number">16</span>,<span class="number">11</span>,<span class="number">4</span>,<span class="number">10</span>])</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-64求1+2+n-python</title>
    <url>/jzo64.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<h2 id="题目描述">题目描述</h2>
<p>求1+2+…+n，要求不能使用乘除法、for、 while if else、 switch、 eae等关键字及条件判断语句（A?B:C)。</p>
<h2 id="第一想法">第一想法：</h2>
<p>等差数列求和公式</p>
<h2 id="剑指offer方法">剑指offer方法：</h2>
<p>利用逻辑运算符的短路效应</p>
<p>RE:https://leetcode-cn.com/problems/qiu-12n-lcof/solution/mian-shi-ti-64-qiu-1-2-nluo-ji-fu-duan-lu-qing-xi-/</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">常见的逻辑运算符有三种，即 “与 &amp;&amp; ”，“或 ∣∣ ”，“非 ! ” ；而其有重要的短路效应，如下所示：</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(A &amp;&amp; B)  // 若 A 为 false ，则 B 的判断不会执行（即短路），直接判定 A &amp;&amp; B 为 false</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(A || B) // 若 A 为 true ，则 B 的判断不会执行（即短路），直接判定 A || B 为 true</span><br><span class="line">本题需要实现 “当 n = 1n=<span class="number">1</span> 时终止递归” 的需求，可通过短路效应实现。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n &gt; <span class="number">1</span> &amp;&amp; sumNums(n - <span class="number">1</span>) // 当 n = <span class="number">1</span> 时 n &gt; <span class="number">1</span> 不成立 ，此时 “短路” ，终止后续递归</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-65不用加减乘除做加法-python</title>
    <url>/jzo65.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<h2 id="题目描述">题目描述</h2>
<p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p>
<h2 id="剑指offer方法">剑指offer方法：</h2>
<p>利用位运算，转为二进制做加法</p>
<p>首先我们分析是如何做十进制加法的，比如是如何得出5+17=22这个结果的。实际上，我们可以分成三步进行：第一步只做各位相加不进位，此时相加的结果是12（个位数5和7相加不要进位是2，十位数0和1相加结果是1）：第二步做进位，5+7中有进位，进位的值是10第三步把前面两个结果加起来，12+10的结果是22，刚好5+17=22。</p>
<p>求两数之和四则运算都不能用，那还能用什么？对数字做运算，除四则运算之外，也就只剩下<strong>位运算</strong>了。位运算是针对二进制的，我们就以二进制再来分析一下前面的“三步走”策略对二进制是不是也适用。</p>
<p>5的二进制是101,17的二进制是10001.我们还是试着把计算分成三步：第一步各位相加但不计进位，得到的结果是10100（最后一位两个数都是1，相加的结果是二进制的10.这一步不计进位，因此结果仍然是0） 第二步记下进位，在这个例子中只在最后一位相加时产生一个进位，结果是二进制的10：第三步把前两步的结果相加，得到的结果是10110，转换成十进制正好是22.由此可见“三步走”策略对二进制也是适用的。</p>
<p>（二进制相加不算加法吗？）</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">C++ 思路</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Add</span>(<span class="params">self, num1, num2</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">while</span> num2: <span class="comment">#while是为了防止多次进位</span></span><br><span class="line">            <span class="comment">#第一步</span></span><br><span class="line">            <span class="built_in">sum</span> = num1 ^ num2 <span class="comment">#异或相同为0，相异为1</span></span><br><span class="line">            <span class="comment">#第二步</span></span><br><span class="line">            carry = (num1 &amp; num2) &lt;&lt;<span class="number">1</span> <span class="comment">#将进位向左移</span></span><br><span class="line">            <span class="comment">#第三步</span></span><br><span class="line">            num1 = <span class="built_in">sum</span></span><br><span class="line">            num2 = carry</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> num1</span><br></pre></td></tr></tbody></table></figure>
<p><strong>注意python没有无符号右移操作，所以需要越界检查</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Add</span>(<span class="params">self, num1, num2</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">while</span> num2: <span class="comment">#while是为了防止多次进位</span></span><br><span class="line">            <span class="comment">#第一步</span></span><br><span class="line">            <span class="built_in">sum</span> = (num1 ^ num2) &amp; <span class="number">0xffffffff</span><span class="comment">#异或相同为0，相异为1</span></span><br><span class="line">            <span class="comment">#第二步</span></span><br><span class="line">            carry = ((num1 &amp; num2) &lt;&lt;<span class="number">1</span>)&amp; <span class="number">0xffffffff</span> <span class="comment">#将进位向左移</span></span><br><span class="line">            <span class="comment">#第三步</span></span><br><span class="line">            num1 = <span class="built_in">sum</span></span><br><span class="line">            num2 = carry</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> num1 &lt;= <span class="number">0x7fffffff</span>:</span><br><span class="line">            result = num1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result = ~(num1^<span class="number">0xffffffff</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></tbody></table></figure>
<h2 id="拓展">拓展</h2>
<h3 id="不用新变量交换两个变量的值">不用新变量，交换两个变量的值</h3>
<p>①基于加减法 ②基于异或</p>
<p>a=a+b a=a^b</p>
<p>b=a-b b=a^b</p>
<p>a=a-b a=a^b</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-66构建乘积数组-python</title>
    <url>/jzo66.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p>注意两个list a,b b=a 改变b的值也会改变a的值</p>
<p>找规律 <img src="http://qn.sbaban.com/blog/20191203/LDk02NUr65X9.png?imageslim" alt="mark"></p>
<p>先算B[i]的一部分： 对角线左边Bleft[i] = Bleft[i-1] ×A[i-1] 再算整体的： B[i] = Bleft[i] × A[i+1] ×..×A[n-1]</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span>(<span class="params">self, A</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        B = [<span class="number">1</span>]*<span class="built_in">len</span>(A) <span class="comment">#因为对角线元素为1，所以初始化为1</span></span><br><span class="line">        n = <span class="built_in">len</span>(A)</span><br><span class="line">        <span class="comment">#计算对角线左边的乘积</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            B[i] = B[i-<span class="number">1</span>]*A[i-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment">#计算对角线右边的乘积,倒着算A的连乘方便些</span></span><br><span class="line">        temp = <span class="number">1</span><span class="comment"># 保存对角线右边A[i+1]*..*A[n-1]的乘积</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            temp *= A[i+<span class="number">1</span>]</span><br><span class="line">            B[i] = B[i]*temp</span><br><span class="line">        <span class="keyword">return</span> B</span><br></pre></td></tr></tbody></table></figure>
<p><strong>第一个版本</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cheng</span>(<span class="params">low,high,A</span>):</span></span><br><span class="line">    <span class="keyword">if</span> high&lt;low:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> low&gt;high:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    temp=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(low, high+<span class="number">1</span>):</span><br><span class="line">        temp *= A[i]</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply</span>(<span class="params"> A</span>):</span></span><br><span class="line">    B = [<span class="number">0</span>]*<span class="built_in">len</span>(A)</span><br><span class="line">    n = <span class="built_in">len</span>(A)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        B[i]= cheng(<span class="number">0</span>, i-<span class="number">1</span>,A)*cheng(i+<span class="number">1</span>, n-<span class="number">1</span>,A)</span><br><span class="line">    <span class="keyword">return</span> B</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-67把字符串转成整数-python</title>
    <url>/jzo67.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<h2 id="题目描述">题目描述</h2>
<p>请你写一个函数StrToInt，实现把字符串转换成整数这个功能。当然，不能使用atoi或者其他类似的库函数。</p>
<h2 id="剑指offer方法">剑指offer方法:</h2>
<p>主要是要做好各种情况出错处理</p>
<p>利用<strong>ord（）</strong>将char转为int</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">StrToInt</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> <span class="built_in">len</span>(s)&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        length = <span class="built_in">len</span>(s)</span><br><span class="line">        sign = <span class="number">1</span> <span class="comment">#表示正负</span></span><br><span class="line">        <span class="keyword">if</span> s[index] == <span class="string">'+'</span>:</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> s[index] == <span class="string">'-'</span>:</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">            sign = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index,<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] &lt; <span class="string">'0'</span> <span class="keyword">or</span> s[i] &gt; <span class="string">'9'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            result += (<span class="built_in">ord</span>(s[i])-<span class="built_in">ord</span>(<span class="string">'0'</span>))*(<span class="built_in">pow</span>(<span class="number">10</span>,length-<span class="number">1</span>-i))</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        max_int = (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span></span><br><span class="line">        result = result*sign</span><br><span class="line">        <span class="keyword">if</span> result &gt; max_int:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> result &lt; -max_int-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">Solution().StrToInt(<span class="string">"-12d3"</span>)</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-6从尾到头打印链表-python</title>
    <url>/jz20191205l.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p>最初思路：将每个节点的值保存到一个list中，返回list[::-1]</p>
<p>书上的思路：</p>
<p>method1：先进后出，用栈实现。</p>
<p>method2：递归</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span>(<span class="params">self, listNode</span>)#最初思路</span></span><br><span class="line"><span class="function">        # <span class="title">listNode</span>是头结点</span></span><br><span class="line">        myarrary = []</span><br><span class="line">        <span class="keyword">while</span> listNode != <span class="literal">None</span>:</span><br><span class="line">            myarrary.append(listNode.val)</span><br><span class="line">            listNode = listNode.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> myarray[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span>(<span class="params">self, listNode</span>)#栈</span></span><br><span class="line"><span class="function">        # <span class="title">listNode</span>是头结点</span></span><br><span class="line">        myarrary = []</span><br><span class="line">        <span class="keyword">while</span> listNode != <span class="literal">None</span>:</span><br><span class="line">            myarrary.append(listNode.val)</span><br><span class="line">            listNode = listNode.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> myarrary:</span><br><span class="line">            print(myarrary.pop())</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span>(<span class="params">self, listNode</span>):</span><span class="comment">#递归</span></span><br><span class="line">        <span class="comment"># listNode是头结点</span></span><br><span class="line">        <span class="keyword">if</span> listNode:</span><br><span class="line">            <span class="keyword">if</span> listNode.<span class="built_in">next</span>:</span><br><span class="line">                self.printListFromTailToHead(listNode.<span class="built_in">next</span>)</span><br><span class="line">                <span class="built_in">print</span> listNode.val</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-7重建二叉树-python</title>
    <url>/jzerchashu.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p>先根据先序遍历的第一位确定根节点， 确定根节点后，中序遍历中根节点左边的是左子树，右边的是右子树。</p>
<p>对于左子树重复此操作，根据左子树的先序遍历的第一个元素为左子树的根节点，再看中序遍历。。。。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reConstructBinaryTree</span>(<span class="params">self, pre, tin</span>):</span></span><br><span class="line">    <span class="comment">#pre表示前序遍历的序列，tin表示中序遍历的序列</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pre <span class="keyword">or</span> <span class="keyword">not</span> tin:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    root = TreeNode(pre[<span class="number">0</span>]) <span class="comment">#前序遍历的第一个表示root结点</span></span><br><span class="line">    rootIndex = tin.index(pre[<span class="number">0</span>])<span class="comment">#root在中序遍历序列中的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#根据中序遍历，处理左子树,切片表示在前序和中序中的左子树</span></span><br><span class="line">    root.left = self.reConstructBinaryTree(pre[<span class="number">1</span>:rootIndex+<span class="number">1</span>], tin[<span class="number">0</span>:rootIndex])</span><br><span class="line">    <span class="comment">#根据中序遍历，处理右子树,切片表示在前序和中序中的右子树</span></span><br><span class="line">    root.right= self.reConstructBinaryTree(pre[rootIndex+<span class="number">1</span>:], tin[rootIndex+<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></tbody></table></figure>
<p>注意 a=[1,2,3] print(a[4:4]) out:[]</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-8二叉树的下一个结点-python</title>
    <url>/jz20191227.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p>一开始没懂题目什么意思。就是给二叉树的一个结点A，这个结点除了左右孩子指针还有个父节点指针，求二叉树中序遍历后A节点的下一个结点，返回它。</p>
<p>最初想法：</p>
<p>复原这棵二叉树，求出此二叉树的中序遍历，得到A的下一个结点的元素值，但不知道怎么返回这个结点。</p>
<p>看了别人的代码，是在中序遍历过程中将每个节点保存到一个list中。</p>
<p>(我想的是记录value值比较value，但无法处理值相同的情况，没想到可以保存节点类型到list中)。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeLinkNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNext</span>(<span class="params">self, pNode</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment">#找到根节点</span></span><br><span class="line">        myroot= pNode</span><br><span class="line">        <span class="keyword">while</span> myroot.<span class="built_in">next</span>:</span><br><span class="line">            myroot = myroot.<span class="built_in">next</span></span><br><span class="line">        self.nodeList = [] <span class="comment">#存储中序遍历的节点</span></span><br><span class="line">        self.inorder(myroot)</span><br><span class="line"></span><br><span class="line">        myIndex = self.nodeList.index(pNode)+<span class="number">1</span> <span class="comment">#下一个节点的索引</span></span><br><span class="line">        <span class="keyword">if</span> myIndex != <span class="built_in">len</span>(self.nodeList):</span><br><span class="line">            <span class="keyword">return</span> self.nodeList[myIndex]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">self, rootNode</span>):</span></span><br><span class="line">        <span class="comment"># 中序遍历</span></span><br><span class="line">        <span class="keyword">if</span> rootNode <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.inorder(rootNode.left)</span><br><span class="line">        self.nodeList.append(rootNode)</span><br><span class="line">        self.inorder(rootNode.right)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>method2：直接由这个结点推出中序遍历中下一个结点</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">			a</span><br><span class="line">	b				c</span><br><span class="line">d		e		d		e</span><br><span class="line">xx h i x x  x x #x表示None</span><br></pre></td></tr></tbody></table></figure>
<p>分两种情况，设给的结点为A，一是A有孩子，二是A没有孩子。</p>
<p>中序遍历中A的下一个结点一定不在A的左子树里，所以在A的右子树里找。 若A只有一个右孩子，那A的下一个结点就是它。（如b的下一个节点） 若A的右孩子B有左孩子，那A的下一个结点就是B的最左边的孩子。</p>
<p>即在A的右子树里找最左边的结点。</p>
<p>还有一种情况是A没有孩子，基于此也有两种情况： 若A是其父节点的左孩子，那A的下一个结点就是其父结点；（如d的下一个节点） 若A是其父节点的右孩子，找A父亲的父结点的...的父结点C，直到C是C的父结点的左孩子。若找不到这样的C，那说明A是尾结点（中序遍历最后一个位置）（如i的下一个节点）</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeLinkNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNext</span>(<span class="params">self, pNode</span>):</span></span><br><span class="line">        <span class="comment"># test</span></span><br><span class="line">        <span class="keyword">if</span>  pNode == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> pNode.right:<span class="comment">#如果有右子树</span></span><br><span class="line">            pNode = pNode.right</span><br><span class="line">            <span class="keyword">if</span> pNode.left:<span class="comment">#有左子树</span></span><br><span class="line">                <span class="keyword">while</span> pNode.left: <span class="comment">#一直向左找左叶子结点</span></span><br><span class="line">                    pNode = pNode.left</span><br><span class="line">                <span class="keyword">return</span> pNode</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> pNode</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> pNode.<span class="built_in">next</span>:<span class="comment">#没有右孩子，有父节点，节点是h或i的情况</span></span><br><span class="line">                <span class="keyword">while</span> pNode.<span class="built_in">next</span>:</span><br><span class="line">                    temp =pNode</span><br><span class="line">                    pNode = pNode.<span class="built_in">next</span></span><br><span class="line">                    <span class="keyword">if</span> pNode.left == temp:</span><br><span class="line">                        <span class="keyword">return</span> pNode</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span> <span class="comment">#找不到这样的节点，说明是右下角的叶子结点</span></span><br><span class="line">        <span class="keyword">else</span>:<span class="comment">#pNode是根结点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-9用两个栈实现队列-python</title>
    <url>/jzqueue1230.html</url>
    <content><![CDATA[<p><strong><font size="5">《剑指offer》python实现系列，<a href="https://sbaban.com/jzomulu.html">全目录</a></font></strong></p>
<p>栈是先进后出，队列是先进先出。</p>
<figure>
<img src="http://qn.sbaban.com/blog/20191230/smTNkdpylMUA.png?imageslim" alt="图源剑指offer"><figcaption>图源剑指offer</figcaption>
</figure>
<p>stack1为abc，stack2为空栈</p>
<p>当删除元素时，把stack1的元素压入stack2。</p>
<p>比如删除栈底的a，将stack1的元素从栈顶依次压入stack2，stack1为空，stack2自底向上为cba，然后删除stack2的栈顶元素a，这时如图（b）所示。若队列继续删除元素，依旧将stack2的栈顶元素弹出，这时如图（c）所示。</p>
<p>当插入元素d时，保证stack1里为空，直接往stack1里插。</p>
<p>删除从stack2里删。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stack1 = []</span><br><span class="line">        self.stack2 = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.stack1.append(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.stack2) != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.stack2.pop()</span><br><span class="line">        <span class="comment">#将stack1的元素压入stack2</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(self.stack1)&gt;<span class="number">0</span>:</span><br><span class="line">            popelem = self.stack1.pop() <span class="comment">#弹出stack1的栈顶元素</span></span><br><span class="line">            self.stack2.append(popelem)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.stack2) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># stack2不为空</span></span><br><span class="line">        <span class="keyword">return</span> self.stack2.pop()</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>删除链表中重复的结点</title>
    <url>/jz20191207.html</url>
    <content><![CDATA[<p><strong>注意</strong>：</p>
<p>书上有个如何在o(1)情况下删除结点的问题</p>
<hr>
<p>最初思路： 使用一个额外的list记录出现的元素，遍历，再遇到相同的就删除。 有个问题：如何删除第一次出现的元素？ 先遍历一遍，用list保存所有元素； 再遍历一遍，如果在list里出现次数大于1，就删除。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplication</span>(<span class="params">self, pHead</span>):</span></span><br><span class="line">        <span class="keyword">if</span> pHead == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> pHead</span><br><span class="line">        temp = [] <span class="comment">#保存所有的元素</span></span><br><span class="line">        p = pHead</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> p != <span class="literal">None</span>:</span><br><span class="line">            temp.append(p.val)</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        p = pHead</span><br><span class="line">        <span class="keyword">while</span> p != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> temp.count(p.val) &gt; <span class="number">1</span>: <span class="comment">#是重复元素</span></span><br><span class="line">                pHead = self.delNode(pHead,p)</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> pHead</span><br><span class="line">          </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delNode</span>(<span class="params">self, pHead, pnode</span>):</span></span><br><span class="line">        <span class="keyword">if</span> pHead == pnode:<span class="comment">#删除头结点</span></span><br><span class="line">            <span class="keyword">return</span> pHead.<span class="built_in">next</span></span><br><span class="line">        p = pHead</span><br><span class="line">        <span class="keyword">if</span> p.<span class="built_in">next</span> != pnode:</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        p.<span class="built_in">next</span> = p.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> pHead</span><br></pre></td></tr></tbody></table></figure>
<p>以上的代码没注意到是排序的数组</p>
<p>不使用辅助list</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplication</span>(<span class="params">self, pHead</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pHead == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> pHead</span><br><span class="line">        p = pHead</span><br><span class="line">        first =ListNode(-<span class="number">1</span>)</span><br><span class="line">        first.<span class="built_in">next</span> = p <span class="comment">#</span></span><br><span class="line">        pre = first <span class="comment">#pre是当前结点的前一个位置</span></span><br><span class="line">        <span class="comment"># 如果phead是重复结点</span></span><br><span class="line">        <span class="keyword">while</span> p != <span class="literal">None</span> <span class="keyword">and</span> p.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> p.val == p.<span class="built_in">next</span>.val:</span><br><span class="line">                tempval = p.val</span><br><span class="line">                <span class="keyword">while</span> p <span class="keyword">and</span> p.val == tempval:</span><br><span class="line">                    p = p.<span class="built_in">next</span></span><br><span class="line">                pre.<span class="built_in">next</span> = p <span class="comment">#直接跳过重复的结点</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = p</span><br><span class="line">                p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> first.<span class="built_in">next</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>字符流中第一个不重复的字符</title>
    <url>/jz20191205char.html</url>
    <content><![CDATA[<p>统计每个字符出现的次数，还得记录字符的顺序 比如google method1：可以暴力解决，对g，遍历字符串。。。 method2：遍历时把遇到的重复元素从字符串中去掉，最后剩下的字符串就是出现一次的。操作有点啰嗦 method3：扫描两次，第一次记录出现的次数，第二次查看出现的次数，找到第一个出现次数为一次的</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.s = <span class="string">''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstAppearingOnce</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.s:</span><br><span class="line">            <span class="keyword">if</span> self.s.count(i) == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span>(<span class="params">self, char</span>):</span></span><br><span class="line">        self.s += char</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<details>
<summary>method3</summary> <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.s = <span class="string">''</span></span><br><span class="line">        self.num = [<span class="number">0</span>]*<span class="number">256</span> <span class="comment">#一共有255个字符</span></span><br><span class="line">        <span class="comment">#记录每个字符出现的次数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstAppearingOnce</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> self.s:</span><br><span class="line">                <span class="keyword">if</span> self.num[<span class="built_in">ord</span>(char)] == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> char</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span>(<span class="params">self, char</span>):</span></span><br><span class="line">        self.s += char</span><br><span class="line">        self.num[<span class="built_in">ord</span>(char)] += <span class="number">1</span> <span class="comment">#ord（）返回对应的ASCII值</span></span><br></pre></td></tr></tbody></table></figure>
</details>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>python学习</title>
    <url>/pylearning.html</url>
    <content><![CDATA[<h2 id="list">list</h2>
<h3 id="list转string">list转string</h3>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">b = [<span class="string">'B'</span>,<span class="string">'#'</span>]</span><br><span class="line">strb = <span class="string">""</span>.join(b)<span class="comment">#b还是list</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="int转lsit">int转lsit</h3>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">x = <span class="number">12258</span></span><br><span class="line">xlist = [<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">str</span>(x)]</span><br><span class="line">或</span><br><span class="line">xlist = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">str</span>(x)))<span class="comment">#若无外面的list，则返回&lt;map object</span></span><br><span class="line"></span><br><span class="line">xlist <span class="comment">#[1, 2, 2, 5, 8]</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="list做函数参数">list做函数参数</h3>
<p>list做函数参数会改变原lsit 的值,将某个列表（比如这里的list）作为参数传入某个函数 。其传递的是list所在的真实地址。所有修改也是对list直接的修改。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xx</span>():</span></span><br><span class="line">    x=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">    print(x) <span class="comment">#123</span></span><br><span class="line">    usex(x)</span><br><span class="line">    print(x)<span class="comment">#1234</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">usex</span>(<span class="params">x</span>):</span></span><br><span class="line">    x.append(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">xx()</span><br></pre></td></tr></tbody></table></figure>
<h2 id="string">string</h2>
<h3 id="删除某字符">删除某字符</h3>
<h4 id="replace">replace</h4>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">x = <span class="string">"abcdab"</span></span><br><span class="line">x= x.replace(<span class="string">'a'</span>,<span class="string">''</span>,<span class="number">1</span>) <span class="comment">#最后一个参数指定替换的次数</span></span><br><span class="line">print(x)</span><br></pre></td></tr></tbody></table></figure>
<h4 id="转成list-remove">转成list remove</h4>
<h3 id="去除数字">去除数字</h3>
<h4 id="filter">filter</h4>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#只保留字母</span></span><br><span class="line">newstr = <span class="string">''</span>.join(<span class="built_in">filter</span>(<span class="built_in">str</span>,isalpha, mystr)) <span class="comment">#注意filter里的函数不用写括号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#只保留数字</span></span><br><span class="line">newstr = <span class="string">''</span>.join(<span class="built_in">filter</span>(<span class="built_in">str</span>,isdigit, mystr)) <span class="comment">#注意filter里的函数不用写括号</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="按长度排序">按长度排序</h3>
<p>见sort部分</p>
<h2 id="位运算">位运算</h2>
<h3 id="与运算">与运算 &amp;</h3>
<p><strong>n与1做位与运算判断n的奇偶性</strong>，（n不论正负，n&amp;1==1,n是奇数, <strong>但n必须是整数</strong>）</p>
<h3 id="位移运算">位移运算</h3>
<p>n必修是整数</p>
<p><strong>n&gt;&gt;1位右移运算来表示n除以2</strong>，（4&gt;&gt;1=2, 5&gt;&gt;1=2）</p>
<p><strong>n&lt;&lt;1位左移运算来表示n乘以2</strong>，（*4&gt;&gt;1=2）</p>
<h3 id="异或运算">异或运算</h3>
<p>待补充</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">8</span> &amp; <span class="number">1</span> = <span class="number">0</span></span><br><span class="line">-<span class="number">3</span> &amp; <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">0.2</span> &amp; <span class="number">1</span>报错</span><br><span class="line">print((<span class="number">20</span>) &gt;&gt; <span class="number">1</span>) <span class="number">10</span></span><br><span class="line">print((-<span class="number">20</span>) &gt;&gt; <span class="number">1</span>) -<span class="number">10</span></span><br><span class="line">print((<span class="number">20</span>) &lt;&lt; <span class="number">1</span>) <span class="number">40</span></span><br><span class="line">print((-<span class="number">20</span>) &lt;&lt; <span class="number">1</span>) -<span class="number">40</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="可变对象">可变对象</h2>
<p>list和dict是可变对象</p>
<p>其对象的内容是可以变化的。当对象的内容发生变化时，变量的对象引用是不会变化的。换句话说，做参数时传的是地址</p>
<p>传可变对象进去，就是传引用，比如 list 传不可变对象进去，就是传值，比如 string 注意：对可变对象进行赋值，会产生新对象，而不是修改旧对象。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dd</span>(<span class="params">x</span>):</span></span><br><span class="line">    x=[<span class="number">1</span>,<span class="number">2</span>] <span class="comment">#对list赋值，不改变原list</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dd2</span>(<span class="params">x</span>):</span></span><br><span class="line">    x.append(<span class="number">33</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dd3</span>(<span class="params">x</span>):</span></span><br><span class="line">    x[<span class="number">0</span>]=<span class="number">100</span> <span class="comment">#对list[index]赋值，改变原list</span></span><br><span class="line">x = [<span class="number">22</span>,<span class="number">44</span>]</span><br><span class="line">dd(x)</span><br><span class="line">print(x) <span class="comment">#[22,44]</span></span><br><span class="line">dd2(x)</span><br><span class="line">print(x)<span class="comment">#[22,44,33]</span></span><br><span class="line">dd3(x)</span><br><span class="line">print(x)<span class="comment">#[100, 44, 33]</span></span><br><span class="line">============================</span><br><span class="line">a=[<span class="number">3</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tt</span>(<span class="params">a</span>):</span></span><br><span class="line">    a[<span class="number">0</span>]=<span class="number">6</span></span><br><span class="line">tt(a)</span><br><span class="line">print(a) <span class="comment">#[6]</span></span><br><span class="line">===</span><br><span class="line">a=<span class="number">3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tt</span>(<span class="params">a</span>):</span></span><br><span class="line">    a=<span class="number">6</span> <span class="comment">#若未进行赋值，可当作全局变量</span></span><br><span class="line">tt(a)</span><br><span class="line">print(a) <span class="comment">#3</span></span><br><span class="line">====</span><br><span class="line">a=[<span class="number">3</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tt</span>():</span></span><br><span class="line">    a[<span class="number">0</span>]=<span class="number">111</span></span><br><span class="line">tt()</span><br><span class="line">print(a) <span class="comment">#[111]</span></span><br><span class="line">==============================</span><br><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">b=[]</span><br><span class="line">b.append(a)</span><br><span class="line">a.pop()</span><br><span class="line">print(b) <span class="comment">#[[1,2,3]] #a改变b也会 改变</span></span><br><span class="line">=====</span><br><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">b=a.copy()<span class="comment">#浅拷贝</span></span><br><span class="line">a.pop()<span class="comment">#[1,2,3]</span></span><br><span class="line">b <span class="comment">#[1,2,3,4]</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="浅拷贝深拷贝">浅拷贝深拷贝</h3>
<p>https://www.runoob.com/w3cnote/python-understanding-dict-copy-shallow-or-deep.html</p>
<h4 id="gloabl">gloabl</h4>
<p>https://www.cnblogs.com/summer-cool/p/3884595.html</p>
<h2 id="装饰器">装饰器</h2>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">首先，明白python中万物皆对象，注意两种调用函数的方法</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    result = x + y</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">output = cal(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">或者</span><br><span class="line">calculate = cal</span><br><span class="line">output = calculate(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uselogging</span>(<span class="params">func</span>):</span></span><br><span class="line">   print(<span class="string">"{} is running"</span>.<span class="built_in">format</span>(func.__name__))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span></span><br><span class="line">    print(<span class="string">"i am bar"</span>)</span><br><span class="line"></span><br><span class="line">uselogging(bar)<span class="comment">#只调用了uselogging函数，而未调用bar函数</span></span><br><span class="line">-----</span><br><span class="line">bar <span class="keyword">is</span> running</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uselogging</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">"{} is running"</span>.<span class="built_in">format</span>(func.__name__))</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs) <span class="comment">#注意func后面有()，wrapper执行func()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper <span class="comment">#uselogging 返回wrapper对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span></span><br><span class="line">    print(<span class="string">"i am bar"</span>)</span><br><span class="line"></span><br><span class="line">bar2 = uselogging(bar)</span><br><span class="line"><span class="comment">#uselogging 返回wrapper对象给bar2，这个bar2可以是任意名字</span></span><br><span class="line">bar2()</span><br><span class="line"><span class="comment">#bar2()即wrapper(),而wrapper()做的是print并执行bar()</span></span><br><span class="line">-----</span><br><span class="line">bar <span class="keyword">is</span> running</span><br><span class="line">i am bar</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">为减少语句，现在对上一程序加入@语法糖</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uselogging</span>(<span class="params">func</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">"{} is running"</span>.<span class="built_in">format</span>(func.__name__))</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs) <span class="comment">#wrapper执行func()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper <span class="comment">#uselogging 返回wrapper对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@uselogging </span><span class="comment">#@是装饰器语法糖，可以省去bar=uselogging(bar)这一句话</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span></span><br><span class="line">    print(<span class="string">"i am bar"</span>)</span><br><span class="line"></span><br><span class="line">bar()</span><br><span class="line">-----</span><br><span class="line">bar <span class="keyword">is</span> running</span><br><span class="line">i am bar</span><br></pre></td></tr></tbody></table></figure>
<h2 id="classmethod"><span class="citation" data-cites="classmethod">@classmethod</span></h2>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    bar = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func1</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">'foo'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func2</span>(<span class="params">cls</span>):</span> <span class="comment">#第一个参数指的是类A本身。名字可任意，这里是cls</span></span><br><span class="line">        print(<span class="string">'func2'</span>)</span><br><span class="line">        print(cls.bar)</span><br><span class="line">        cls().func1()  <span class="comment"># 调用 foo 方法</span></span><br><span class="line"></span><br><span class="line">A.func2()  <span class="comment"># 不需要实例化</span></span><br><span class="line">-----</span><br><span class="line">func2</span><br><span class="line"><span class="number">1</span></span><br><span class="line">foo</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, title1</span>):</span></span><br><span class="line">        self.title = title1</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">cls, title2</span>):</span></span><br><span class="line">        book = cls(title1=title2)<span class="comment">#相当于Book（title1=title2）</span></span><br><span class="line">        <span class="keyword">return</span> book</span><br><span class="line"></span><br><span class="line">book1 = Book(<span class="string">"python"</span>) <span class="comment">#普通的实例化方法</span></span><br><span class="line">book2 = Book.create(<span class="string">"python and django"</span>)</span><br><span class="line">print(book1.title)</span><br><span class="line">print(book2.title)</span><br><span class="line">-----</span><br><span class="line">python</span><br><span class="line">python <span class="keyword">and</span> django</span><br></pre></td></tr></tbody></table></figure>
<h2 id="staticmethod"><span class="citation" data-cites="staticmethod">@staticmethod</span></h2>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">class C(object):</span><br><span class="line">    @staticmethod</span><br><span class="line">    def f():</span><br><span class="line">        print('runoob');</span><br><span class="line"> </span><br><span class="line">C.f();          # 静态方法无需实例化</span><br><span class="line">cobj = C()</span><br><span class="line">cobj.f()        # 也可以实例化后调用</span><br></pre></td></tr></tbody></table></figure>
<h2 id="map">map</h2>
<p><strong>map()</strong> 会根据提供的函数对指定序列做映射。</p>
<p>第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">map(function, iterable, ...)</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="function"><span class="keyword">def</span> <span class="title">square</span>(<span class="params">x</span>) :</span>            <span class="comment"># 计算平方数</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">map</span>(square, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])   <span class="comment"># 计算列表各个元素的平方</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">map</span>(<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])  <span class="comment"># 使用 lambda 匿名函数</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 提供了两个列表，对相同位置的列表数据进行相加</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">map</span>(<span class="keyword">lambda</span> x, y: x + y, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>])</span><br><span class="line">[<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">19</span>]</span><br></pre></td></tr></tbody></table></figure>
<h2 id="zip">zip</h2>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">a= [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">zipped = <span class="built_in">list</span>(<span class="built_in">zip</span>(a,b))</span><br><span class="line">print(zipped) <span class="comment">#[(1, 4), (2, 5), (3, 6)]</span></span><br><span class="line"></span><br><span class="line">a= [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]<span class="comment">#二维数组</span></span><br><span class="line">zipped = <span class="built_in">list</span>(<span class="built_in">zip</span>(*a))</span><br><span class="line">print(zipped) <span class="comment">#[(1, 4), (2, 5), (3, 6)]</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="lambada表达式">lambada表达式</h2>
<p>又称为匿名函数，格式为 lambda 参数列表：函数体</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">g = <span class="keyword">lambda</span> x:x+<span class="number">1</span></span><br><span class="line"><span class="comment"># 可这样认为,lambda作为一个表达式，定义了一个匿名函数，上例的代码x为入口参数，x+1为函数体</span></span><br><span class="line">print(g(<span class="number">1</span>))</span><br><span class="line">----</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="comment"># 写成函数形式：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x+<span class="number">1</span></span><br><span class="line">print(g(<span class="number">1</span>))</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; foo = [2, 18, 9, 22, 17, 24, 8, 12, 27]</span><br><span class="line">&gt;&gt;&gt; print filter(lambda x: x % 3 == 0, foo)</span><br><span class="line">[18, 9, 24, 12, 27]</span><br></pre></td></tr></tbody></table></figure>
<h2 id="sort">sort</h2>
<p>按长度排序</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">myList = [<span class="string">'青海省'</span>,<span class="string">'内蒙古自治区'</span>,<span class="string">'西藏自治区'</span>,<span class="string">'新疆维吾尔自治区'</span>,<span class="string">'广西壮族自治区'</span>]  </span><br><span class="line">myList.sort(key = <span class="keyword">lambda</span> i:<span class="built_in">len</span>(i),reverse=<span class="literal">True</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment">#sorted</span></span><br><span class="line">sorrtlist= <span class="built_in">sorted</span>(mylist,key=<span class="keyword">lambda</span> i:<span class="built_in">len</span>(i))</span><br></pre></td></tr></tbody></table></figure>
<p>dict按value排序</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">sorted_dict = <span class="built_in">sorted</span>(keyword_dict.items(), key=<span class="keyword">lambda</span> item: item[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">print(sorted_dict)<span class="comment">#[(key1, value1), (key2, value2)]</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="list-1">*list</h2>
<p>列表元组的解包，去除最外层的括号</p>
<p>首先定义一个函数</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">def myfun(a, b):</span><br><span class="line">    print(a + b)</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">n=[1,2]</span><br><span class="line">print(*n)</span><br><span class="line">out:1 2</span><br><span class="line">&gt;&gt;&gt; myfun(*n)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; m = (1, 2)</span><br><span class="line">&gt;&gt;&gt; myfun(*m)</span><br><span class="line">3</span><br></pre></td></tr></tbody></table></figure>
<h2 id="函数作为函数参数">函数作为函数参数</h2>
<p>提高扩展性</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mysum</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mysub</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a-b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">x,y,myfunc</span>):</span></span><br><span class="line">    result = myfunc(x,y)</span><br><span class="line">    print(x,y,result)</span><br><span class="line"></span><br><span class="line">test(<span class="number">10</span>,<span class="number">20</span>,mysum) <span class="comment"># 10 20 30</span></span><br><span class="line">test(<span class="number">10</span>,<span class="number">20</span>,mysub) <span class="comment"># 10 20 -10</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="一个星号两个星号的参数">一个星号，两个星号的参数</h2>
<p>1.带一个星号（*）参数的函数传入的参数存储为一个元组（tuple）</p>
<p>2.带两个星号（*）参数的函数传入的参数则存储为一个字典（dict），并且再调用是采取a=1,b=2,c=3的形式</p>
<p>3.传入的参数个数不定，所以当与普通参数一同使用时，必须把带星号的参数放在最后。</p>
<figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function_with_one_star</span>(<span class="params">*d</span>):</span></span><br><span class="line">    print(d, <span class="built_in">type</span>(d))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function_with_two_stars</span>(<span class="params">**d</span>):</span></span><br><span class="line">    print(d, <span class="built_in">type</span>(d))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面定义了两个函数，分别用了带一个星号和两个星号的参数：</span></span><br><span class="line">function_with_one_star(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">function_with_two_stars(a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>)</span><br><span class="line">-----</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) &lt;<span class="class"><span class="keyword">class</span> '<span class="title">tuple</span>'&gt;</span></span><br><span class="line">{'a': 1, 'b': 2, 'c': 3} &lt;class 'dict'&gt;https://blog.csdn.net/weixin_41896508/article/details/80771817&gt; </span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>Re:</p>
<p><a href="https://blog.csdn.net/weixin_41896508/article/details/80771817" class="uri">https://blog.csdn.net/weixin_41896508/article/details/80771817</a></p>
</blockquote>
<h2 id="文件操作">文件操作</h2>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">"1.txt"</span>, <span class="string">'r'</span>) <span class="keyword">as</span> REL: <span class="comment">#读取1.txt</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'3ary的entname及其des.txt'</span>,<span class="string">'w'</span>) <span class="keyword">as</span> JFname: <span class="comment">#将结果写入此文件</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> REL:</span><br><span class="line">            line = line.split(<span class="string">'\t'</span>)</span><br><span class="line">            entname= line[<span class="number">1</span>]</span><br><span class="line">            entdes = line[<span class="number">2</span>]</span><br><span class="line">            <span class="comment"># print(line)</span></span><br><span class="line">            <span class="keyword">if</span> entname <span class="keyword">in</span> aryof3ent:</span><br><span class="line">                JFname.writelines([line[<span class="number">1</span>], <span class="string">'\t'</span>, line[<span class="number">2</span>], <span class="string">'\n'</span>])</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<blockquote>

</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ STL 用法整理</title>
    <url>/stl0606.html</url>
    <content><![CDATA[<h1 id="vector">vector</h1>
<p>vector元素可以相同</p>
<p>##vector初始化</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;obj;<span class="comment">//创建一个向量存储容器 int</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++) <span class="comment">// push_back(elem)在数组最后添加数据 </span></span><br><span class="line">  {</span><br><span class="line">      obj.push_back(i);</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; obj[i] &lt;&lt; <span class="string">","</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">veca</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>;    <span class="comment">// 初始化了10个值为1的元素</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="输出vector元素">输出vector元素</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; A[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;train;<span class="comment">//pair有两个成员，一是first，二是second</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; train.size(); i++)</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; train[i].first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="添加插入vector元素">添加插入vector元素</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">vecA.pushback(vlaue)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="vector合并">vector合并</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">vec2.insert(vec2.end(),vec1.begin(),vec1.end());</span><br><span class="line"><span class="comment">//void insert (iterator position, InputIterator first, InputIterator last);</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="排序">排序</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">sort(vecA.begin(),vecA.end());</span><br></pre></td></tr></tbody></table></figure>
<h2 id="二维数组">二维数组</h2>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//得到一个5行3列的数组</span><br><span class="line">//由vector实现的二维数组，可以通过resize()的形式改变行、列值</span><br><span class="line"></span><br><span class="line">int i,j;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; array(5);</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt; array.size(); i++)</span><br><span class="line">    array[i].resize(3);</span><br><span class="line"></span><br><span class="line">for(i = 0; i &lt; array.size(); i++)</span><br><span class="line">   for (j = 0; j &lt; array[0].size();j++)</span><br><span class="line">     // array[i][j] = (i+1)*(j+1);</span><br><span class="line">       array[i] .push_back( (i+1)*(j+1));//注意使用push_back而不是=赋值，使用=容易越界。</span><br></pre></td></tr></tbody></table></figure>
<h2 id="查找元素是否存在">查找元素是否存在</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vStr;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> nRet = <span class="built_in">std</span>::count(vStr.begin(), vStr.end(), <span class="string">"xiaochun"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断vector中是否有 "xiaochun" 这个元素</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(find(nums2.begin(),nums2.end(),*it)!=nums2.end())<span class="comment">//包含此元素</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="判断vecotr相等">判断vecotr相等</h2>
<p>如果是vector。直接用==，【1，2，3】与【2，1，3】不相等</p>
<p>如果是armo::uvec用approx_equal（）</p>
<pre><code>    if (approx_equal(uvec1, uvec2, "absdiff", 0))
        cout &lt;&lt; "相等";</code></pre>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; uvec1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">	uvec1.push_back(i * <span class="number">10</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; uvec2;</span><br><span class="line">uvec2.push_back(<span class="number">0</span>);	uvec2.push_back(<span class="number">10</span>);	uvec2.push_back(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; uvec2[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (uvec1 == uvec2)		<span class="built_in">cout</span> &lt;&lt; <span class="string">"xiangdneg"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"buxiangdeng"</span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="uvec">uvec</h3>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">uvec uvec2 = zeros&lt;uvec&gt;(<span class="number">3</span>);</span><br><span class="line">uvec2[<span class="number">0</span>] = <span class="number">200</span>;</span><br><span class="line">uvec2[<span class="number">1</span>] = <span class="number">100</span>;</span><br><span class="line">uvec2[<span class="number">2</span>] = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; uvec2[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">====</span><br><span class="line"><span class="number">200</span> <span class="number">100</span> <span class="number">300</span></span><br><span class="line">   </span><br></pre></td></tr></tbody></table></figure>
<h1 id="set">set</h1>
<p>set不能返回第i各元素；</p>
<p>set之间的赋值是独立的，set1=set2，改变set1不影响set2；</p>
<h2 id="判断相等">判断相等</h2>
<p><strong>注意：</strong> set会自动将元素按从小到大排序。python3中也是如此</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; test1;</span><br><span class="line">test1.insert(<span class="number">5</span>);	test1.insert(<span class="number">3</span>);# test1为<span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; test2;</span><br><span class="line">test2.insert(<span class="number">3</span>);	test2.insert(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (test1 == test2)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"test1=test2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">===</span><br><span class="line">test1=test2</span><br><span class="line"></span><br><span class="line">#<span class="built_in">unordered_set</span>也依旧相等</span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; test1;</span><br><span class="line">test1.insert(<span class="number">5</span>);	test1.insert(<span class="number">3</span>);#test1为<span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; test2;</span><br><span class="line">test2.insert(<span class="number">3</span>);	test2.insert(<span class="number">5</span>);</span><br><span class="line">====</span><br><span class="line">test1=test2</span><br></pre></td></tr></tbody></table></figure>
<h2 id="判断是否是子集">判断是否是子集</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">A.insert(<span class="number">2</span>); A.insert(<span class="number">3</span>); A.insert(<span class="number">4</span>); </span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; B;<span class="comment">//replaced set</span></span><br><span class="line">B.insert(<span class="number">3</span>); B.insert(<span class="number">2</span>); B.insert(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (includes(A.begin(), A.end(), B.begin(), B.end()))</span><br><span class="line">{<span class="comment">//若B是A的子集</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"B是A的子集"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"B不是A的子集"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="删除元素">删除元素</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">	<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; test;</span><br><span class="line">	test.insert(<span class="number">5</span>);	test.insert(<span class="number">3</span>);	test.insert(<span class="number">1</span>);</span><br><span class="line">	test.insert(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = test.begin(); it != test.end(); it++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"==="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	test.erase(<span class="number">20</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = test.begin(); it != test.end(); it++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">===============</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">===</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="输出set元素">输出set元素</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = mediator_split.begin(); it != mediator_split.end(); it++)</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></tbody></table></figure>
<h1 id="map">map</h1>
<p>map.count(Key)返回值为1或者0，1返回存在，0返回不存在，返回的是布尔类型的值，因为在map类型中所有的数据的Key值都是不同的，所以被count的数要么存在1次，要么不存在</p>
<h2 id="添加数据">添加数据</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;a;</span><br><span class="line"></span><br><span class="line">a.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">3</span>));<span class="comment">//注意insert要插入pair对</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>]=<span class="number">2</span>;a[<span class="number">1</span>]=<span class="number">3</span>;<span class="comment">//使用数组方式添加数据</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span> &lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;a;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; slength; i++)  </span><br><span class="line">{  a[s[i]] += <span class="number">1</span>;  } </span><br></pre></td></tr></tbody></table></figure>
<h2 id="输出map元素">输出map元素</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = entities2index.begin(); it != entities2index.end(); it++)</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">":"</span> &lt;&lt; it-&gt;second;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it : entities2index)</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; it.first &lt;&lt; <span class="string">":"</span> &lt;&lt; it.second &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="map二维数组">map二维数组</h2>
<p>​```C+++ map&lt;int, map&lt;int, int&gt;&gt; a; a[1][1] = 1; a[1][2] = 2; a[2][1] = 3;</p>
<p>for (auto i = a.begin(); i != a.end(); i++){ for (map&lt;int, int&gt;::iterator j = (i-&gt;second).begin(); j != (i-&gt;second).end(); j++){ cout &lt;&lt; j-&gt;second &lt;&lt; ends; } cout &lt;&lt; endl; } </p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"># 字符</span><br><span class="line"></span><br><span class="line">## isalpha()</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">若不是字母，返回0。</span><br><span class="line">若为英文字母，返回非0（小写字母为2，大写字母为1）。</span><br></pre></td></tr></tbody></table></figure><p></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/linux.html</url>
    <content><![CDATA[<h1 id="文件相关">文件相关</h1>
<h2 id="查看文件大小">查看文件大小</h2>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">ls -lh <span class="comment">#不能查看文件夹 </span></span><br><span class="line">du -sh <span class="comment">#当前目录总大小 </span></span><br><span class="line">du -sh * <span class="comment">#当前目录每个文件大小 </span></span><br><span class="line">df -hl <span class="comment">#剩余空间大小</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="查看文件修改时间">查看文件修改时间</h2>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">stat</span> 1.txt</span><br></pre></td></tr></tbody></table></figure>
<h2 id="查看文件个数">查看文件个数</h2>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 统计某文件夹下文件的个数 </span></span><br><span class="line">ls -l |grep <span class="string">"^-"</span>|wc -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计某文件夹下目录的个数 </span></span><br><span class="line">ls -l |grep <span class="string">"^ｄ"</span>|wc -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计文件夹下文件的个数，包括子文件夹里的 </span></span><br><span class="line">ls -lR|grep <span class="string">"^-"</span>|wc -l</span><br></pre></td></tr></tbody></table></figure>
<h1 id="conda">conda</h1>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">conda env list <span class="comment">#查看所有环境</span></span><br><span class="line">conda activate py3 <span class="comment">#进入py3环境</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="find">find</h1>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">find path -name <span class="string">"filename"</span></span><br><span class="line"></span><br><span class="line">find ./dir1 ./dir2 -name <span class="string">"abc*"</span> <span class="comment">#同时在多个目录下查找</span></span><br><span class="line"></span><br><span class="line">find path -<span class="built_in">type</span> d -name <span class="string">"filename"</span>    <span class="comment">#查找文件夹</span></span><br><span class="line"></span><br><span class="line">find path -<span class="built_in">type</span> f -name <span class="string">"filename"</span>    <span class="comment">#查找文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># =======高级查找=======</span></span><br><span class="line"></span><br><span class="line">find path ！ -name <span class="string">"filename"</span>    <span class="comment">#反向查找文件</span></span><br><span class="line"></span><br><span class="line">find path -name <span class="string">"filename"</span> -o -name <span class="string">"filename"</span>    <span class="comment">#或 查找文件</span></span><br><span class="line"></span><br><span class="line">find . -name <span class="string">"[A-Z]*"</span> <span class="comment">#查找当前目录及子目录内以大写字母开头的文件</span></span><br><span class="line"></span><br><span class="line">find . -iname <span class="string">"[A-Z]*"</span> <span class="comment">#忽略大小写iname</span></span><br><span class="line"></span><br><span class="line">find ./neg/ -name <span class="number">12</span>[<span class="number">0</span>-<span class="number">9</span>][<span class="number">0</span>-<span class="number">9</span>][<span class="number">8</span>-<span class="number">9</span>]*.txt|wc -l <span class="comment">#统计查找到的12***文件个数</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="timeout">timeout</h1>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">timeout s/m/h ./<span class="built_in">test</span> <span class="comment"># s,m,h分别表示秒，分，小时。 test是要运行的程序,运行完会自动停止</span></span><br><span class="line">timeout 1h ./<span class="built_in">test</span> <span class="comment"># 运行test程序1小时</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="scp">scp</h1>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">scp -r local_folder remote_username@remote_ip:remote_folder</span><br></pre></td></tr></tbody></table></figure>
<h1 id="cpu相关">CPU相关</h1>
<h2 id="tasket">tasket</h2>
<ul>
<li>1查看进程在哪个cpu上</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">tasket -p PID #PID为进程号，可以先用top看下</span><br></pre></td></tr></tbody></table></figure>
<p>以我的程序（xmr）为例，返回：ffffffff</p>
<p>显示结果f表示二进制的1111，每一个1表示一个CPU，说明这个进程运行在32个CPU上。</p>
<ul>
<li><p>2指定进程运行在某CPU上</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">taskset -pc 运行的cpu pid #指定的cpu知识列表，如0，5，9-11</span><br></pre></td></tr></tbody></table></figure>
<p>将我的程序指定到0-25个cpu上</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">xx@xx$taskset -pc 0-25 4079361</span><br><span class="line">===</span><br><span class="line">pid 4079361's current affinity list: 0-31</span><br><span class="line">pid 4079361's new affinity list: 0-25</span><br><span class="line">(虽然输出真非常，但用htop查看了下还是给我占满了)</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>python数据结构与算法</title>
    <url>/pys19.html</url>
    <content><![CDATA[<h2 id="线性表">线性表</h2>
<p>线性表包括顺序表和链表</p>
<h3 id="顺序表">顺序表</h3>
<h3 id="链表">链表</h3>
<p>注意特殊情况的处理（只有一个node，删除第一个node，删除最后一个node）</p>
<h4 id="单链表">单链表</h4>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, elem</span>):</span></span><br><span class="line">        self.elem = elem</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkList</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, node = <span class="literal">None</span></span>):</span> <span class="comment">#默认参数是None</span></span><br><span class="line">        self.__head = node <span class="comment">#头指针 属于没有头结点的类型，直接指向第一个元素的值（head中就有elem）</span></span><br><span class="line">        <span class="comment"># 双下划线表示私有属性</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__head == <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span>(<span class="params">self</span>):</span></span><br><span class="line">        cur = self.__head <span class="comment">#current当前结点</span></span><br><span class="line">        count  = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travel</span>(<span class="params">self</span>):</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            print(cur.elem, end=<span class="string">" "</span>)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span>(<span class="params">self, elem</span>):</span><span class="comment">#尾部插入元素 尾插法</span></span><br><span class="line">        newnode = Node(elem)</span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            self.__head = newnode</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self.__head</span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = newnode</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, elem</span>):</span> <span class="comment">#头部插入元素，头插法</span></span><br><span class="line">        newnode = Node(elem)</span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            self.__head = newnode</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            newnode.<span class="built_in">next</span> = self.__head</span><br><span class="line">            self.__head = newnode</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, pos, elem</span>):</span></span><br><span class="line">        <span class="comment">#第一个数据的pos为0，insert(2,10)：插入后位置2的数据变成了10</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt;= <span class="number">0</span>: <span class="comment">#看作头插法</span></span><br><span class="line">            self.add(elem)</span><br><span class="line">        <span class="keyword">elif</span> pos &gt; self.length():</span><br><span class="line">            self.append(elem)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            newnode = Node(elem)</span><br><span class="line">            cur = self.__head</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> count != pos - <span class="number">1</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            newnode.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = newnode</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, elem</span>):</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.elem == elem:</span><br><span class="line">                <span class="keyword">if</span> cur == self.__head: <span class="comment">#若是头结点要特殊处理</span></span><br><span class="line">                    self.__head = cur.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pre.<span class="built_in">next</span> =cur.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur</span><br><span class="line">                cur =cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">self, elem</span>):</span></span><br><span class="line">        <span class="comment">#看elem是否存在</span></span><br><span class="line">        cur =self.__head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.elem == elem:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ll = SingleLinkList()</span><br><span class="line">ll.add(<span class="number">22</span>)</span><br><span class="line">ll.append(<span class="number">33</span>)</span><br><span class="line">print(<span class="string">"dd"</span>)</span><br><span class="line">ll.remove(<span class="number">22</span>)</span><br><span class="line">ll.travel()</span><br></pre></td></tr></tbody></table></figure>
<h4 id="双向链表">双向链表</h4>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, elem</span>):</span></span><br><span class="line">        self.elem = elem</span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkList</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, node=<span class="literal">None</span></span>):</span>  <span class="comment"># 默认参数是None</span></span><br><span class="line">       self.__head = node  <span class="comment"># 头指针 属于没有头结点的类型，直接指向第一个元素的值</span></span><br><span class="line">       <span class="comment"># 双下划线表示私有属性</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__head == <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span>(<span class="params">self</span>):</span></span><br><span class="line">        cur = self.__head  <span class="comment"># current当前结点</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travel</span>(<span class="params">self</span>):</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            print(cur.elem, end=<span class="string">" "</span>)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span>(<span class="params">self, elem</span>):</span>  <span class="comment"># 尾部插入元素 尾插法</span></span><br><span class="line">        newnode = Node(elem)</span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            self.__head = newnode</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self.__head</span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = newnode</span><br><span class="line">            newnode.prev = cur</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, elem</span>):</span>  <span class="comment"># 头部插入元素，头插法</span></span><br><span class="line">        newnode = Node(elem)</span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            self.__head = newnode</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            newnode.<span class="built_in">next</span> = self.__head</span><br><span class="line">            self.__head.prev = newnode</span><br><span class="line">            self.__head = newnode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, pos, elem</span>):</span></span><br><span class="line">        <span class="comment"># 第一个数据的pos为0，insert(2,10)：插入后位置2的数据变成了10</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt;= <span class="number">0</span>:</span><br><span class="line">            self.add(elem)</span><br><span class="line">        <span class="keyword">elif</span> pos &gt;= self.length():</span><br><span class="line">            self.append(elem)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            newnode = Node(elem)</span><br><span class="line">            cur = self.__head</span><br><span class="line">            count =<span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> count &lt; pos:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            cur.prev.<span class="built_in">next</span> = newnode</span><br><span class="line">            newnode.prev = cur.prev</span><br><span class="line">            newnode.<span class="built_in">next</span> = cur</span><br><span class="line">            cur.prev = newnode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, elem</span>):</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.elem == elem:</span><br><span class="line">                <span class="keyword">if</span> cur == self.__head:</span><br><span class="line">                    self.__head = cur.<span class="built_in">next</span></span><br><span class="line">                    <span class="keyword">if</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: <span class="comment"># None结点没有prev</span></span><br><span class="line">                        cur.<span class="built_in">next</span>.prev = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cur.prev.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                    <span class="keyword">if</span> cur.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: <span class="comment"># None结点没有prev</span></span><br><span class="line">                        cur.<span class="built_in">next</span>.prev = cur.prev</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">self, elem</span>):</span></span><br><span class="line">        <span class="comment"># 看elem是否存在</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur =self.__head</span><br><span class="line">            <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> cur.elem == elem:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dl = DoubleLinkList()</span><br><span class="line">dl.append(<span class="number">3</span>)</span><br><span class="line">dl.append(<span class="number">4</span>)</span><br><span class="line">dl.add(<span class="number">2</span>)</span><br><span class="line">dl.travel()</span><br><span class="line">print(dl.check(<span class="number">22</span>))</span><br><span class="line">dl.remove(<span class="number">2</span>)</span><br><span class="line">dl.travel()</span><br></pre></td></tr></tbody></table></figure>
<h4 id="单向循环链表">单向循环链表</h4>
<p>链表的最后一个node的next域不再为None，而是指向链表的首元结点。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, elem</span>):</span></span><br><span class="line">        self.elem = elem</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCycleLinkList</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, node=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.__head = node</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            node.<span class="built_in">next</span> = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__head <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span>(<span class="params">self</span>):</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> != self.__head:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travel</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> != self.__head:</span><br><span class="line">            print(cur.elem, end=<span class="string">" "</span>)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="comment">#退出循环，最后一个结点未print，需print下</span></span><br><span class="line">        print(cur.elem, end=<span class="string">" "</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, elem</span>):</span><span class="comment">#头插法</span></span><br><span class="line">        newnode = Node(elem)</span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            self.__head = newnode</span><br><span class="line">            self.__head.<span class="built_in">next</span> = newnode</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self.__head</span><br><span class="line">            newnode.<span class="built_in">next</span> = cur</span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> != self.__head: <span class="comment">#退出循环后，cur指向尾结点</span></span><br><span class="line">                cur =cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = newnode</span><br><span class="line">            self.__head = newnode</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span>(<span class="params">self, elem</span>):</span></span><br><span class="line">        newnode = Node(elem)</span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            self.__head = newnode</span><br><span class="line">            self.__head.<span class="built_in">next</span> = newnode</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self.__head</span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> != self.__head:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = newnode</span><br><span class="line">            newnode.<span class="built_in">next</span> = self.__head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, pos, elem</span>):</span></span><br><span class="line">        <span class="keyword">if</span> pos&lt;=<span class="number">0</span>:</span><br><span class="line">            self.add(elem)</span><br><span class="line">        <span class="keyword">elif</span> pos &gt;= self.length():</span><br><span class="line">            self.append(elem)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            newnode = Node(elem)</span><br><span class="line">            count =<span class="number">0</span></span><br><span class="line">            cur = self.__head</span><br><span class="line">            <span class="keyword">while</span> count &lt; pos-<span class="number">1</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            newnode.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = newnode</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">self, elem</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> != self.__head:</span><br><span class="line">            <span class="keyword">if</span> cur.elem == elem:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 退出循环，最后一个结点未check，需check下</span></span><br><span class="line">        <span class="keyword">if</span> cur.elem == elem:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, elem</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        cur =self.__head</span><br><span class="line">        <span class="keyword">if</span> cur.elem == elem <span class="keyword">and</span> self.length()==<span class="number">1</span>: <span class="comment">#只有一个结点的情况</span></span><br><span class="line">            self.__head = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        pre =<span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> != self.__head:</span><br><span class="line">            <span class="keyword">if</span> cur.elem == elem:</span><br><span class="line">                <span class="keyword">if</span> cur == self.__head: <span class="comment">#头结点的情况</span></span><br><span class="line">                    cur2 = self.__head</span><br><span class="line">                    <span class="comment">#还需改动尾部next</span></span><br><span class="line">                    <span class="keyword">while</span> cur2.<span class="built_in">next</span> != self.__head: <span class="comment">#找尾结点</span></span><br><span class="line">                        cur2 = cur2.<span class="built_in">next</span></span><br><span class="line">                    self.__head = cur.<span class="built_in">next</span></span><br><span class="line">                    cur2.<span class="built_in">next</span> = self.__head</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span> <span class="comment">#完美结点</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> cur.elem == elem: <span class="comment">#尾结点的情况</span></span><br><span class="line">            pre.<span class="built_in">next</span> = self.__head</span><br><span class="line"></span><br><span class="line">scl = SingleCycleLinkList()</span><br><span class="line">scl.add(<span class="number">2</span>)</span><br><span class="line">scl.append(<span class="number">3</span>)</span><br><span class="line">scl.insert(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">scl.travel()</span><br><span class="line">scl.remove(<span class="number">2</span>)</span><br><span class="line">print(<span class="string">"=="</span>)</span><br><span class="line">scl.travel()</span><br></pre></td></tr></tbody></table></figure>
<h3 id="栈">栈</h3>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="comment"># 借助list实现栈，list尾部作为栈顶(list作为顺序表在尾部插入删除是O(1),</span></span><br><span class="line">    <span class="comment"># 而如果用单链表应该将头部作为栈顶才会有较低的时间复杂度)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__list = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">"""弹出栈顶元素"""</span></span><br><span class="line">        <span class="keyword">return</span>(self.__list.pop()) </span><br><span class="line">      <span class="comment">#list.pop(pos),pos默认为-1，删除pos位置的元素并return删除的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">"""返回栈顶元素"""</span></span><br><span class="line">        <span class="keyword">if</span> self.__list:</span><br><span class="line">            <span class="keyword">return</span> self.__list[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, elem</span>):</span></span><br><span class="line">        <span class="string">"""添加新元素到栈顶"""</span></span><br><span class="line">        self.__list.append(elem)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__list == []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.__list)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travel</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.__list:</span><br><span class="line">            print(i, end=<span class="string">" "</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Stack()</span><br><span class="line">s.push(<span class="number">1</span>)</span><br><span class="line">s.push(<span class="number">2</span>)</span><br><span class="line">s.push(<span class="number">3</span>)</span><br><span class="line">s.pop()</span><br><span class="line">s.travel()</span><br></pre></td></tr></tbody></table></figure>
<h3 id="队列">队列</h3>
<h4 id="普通队列">普通队列</h4>
<p>只允许在一段进行插入操作，而另一端进行删除操作的线性表。</p>
<p>允许删除的一段为队头，允许插入的一段为队尾。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="comment"># 借助list实现队列</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__list = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addqueue</span>(<span class="params">self, elem</span>):</span></span><br><span class="line">        <span class="string">"""在队尾添加元素"""</span></span><br><span class="line">        self.__list.append(elem)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">popqueue</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">"""在队头删除元素"""</span></span><br><span class="line">        self.__list.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__list == []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.__list)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travel</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.__list:</span><br><span class="line">            print(i, end=<span class="string">" "</span>)</span><br><span class="line"></span><br><span class="line">s = Queue()</span><br><span class="line">s.addqueue(<span class="number">1</span>)</span><br><span class="line">s.addqueue(<span class="number">2</span>)</span><br><span class="line">s.addqueue(<span class="number">3</span>)</span><br><span class="line">s.travel()</span><br><span class="line">s.popqueue()</span><br><span class="line">s.travel()</span><br></pre></td></tr></tbody></table></figure>
<h4 id="双端队列">双端队列</h4>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deque</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="comment"># 借助list实现队列</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__list = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addFront</span>(<span class="params">self, elem</span>):</span></span><br><span class="line">        <span class="string">"""在头部添加元素"""</span></span><br><span class="line">        self.__list.insert(<span class="number">0</span>, elem)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addRear</span>(<span class="params">self, elem</span>):</span></span><br><span class="line">        <span class="string">"""在队尾添加元素"""</span></span><br><span class="line">        self.__list.append(elem)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">popFront</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">"""在队头删除元素"""</span></span><br><span class="line">        self.__list.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">popRear</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">"""在队尾删除元素"""</span></span><br><span class="line">        self.__list.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__list == []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.__list)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travel</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.__list:</span><br><span class="line">            print(i, end=<span class="string">" "</span>)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="树">树</h2>
<h3 id="二叉树">二叉树</h3>
<h4 id="满二叉树">满二叉树</h4>
<p>从形象来看的话满二叉树是一个绝对的三角形，最后一层全部是叶子节点</p>
<h4 id="完全二叉树">完全二叉树</h4>
<p>从形象上讲它是个缺失的的三角形，但所缺失的部分一定是右下角某个连续的部分，最后那一行可能不是完整的。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, elem</span>):</span></span><br><span class="line">        self.elem = elem</span><br><span class="line">        self.lchild = <span class="literal">None</span>  <span class="comment"># 左节点</span></span><br><span class="line">        self.rchild = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.root = <span class="literal">None</span>  <span class="comment"># 根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">createfromlist</span>(<span class="params">self, root, elemlist, index=<span class="number">0</span></span>):</span></span><br><span class="line">        <span class="comment"># RE:https://blog.csdn.net/lznsay/article/details/78710257</span></span><br><span class="line">        <span class="comment"># 列表中元素按树的广度优先方式顺序排列</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="built_in">len</span>(elemlist):</span><br><span class="line">            <span class="keyword">if</span> elemlist[index] &lt; <span class="number">0</span>:</span><br><span class="line">                root = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root = Node(elemlist[index])</span><br><span class="line">                root.lchild = self.createfromlist(root.lchild, elemlist, <span class="number">2</span> * index + <span class="number">1</span>)</span><br><span class="line">                root.rchild = self.createfromlist(root.rchild, elemlist, <span class="number">2</span> * index + <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allPath</span>(<span class="params">self,root</span>):</span><span class="comment">#模版【推荐】</span></span><br><span class="line">        <span class="comment"># 返回根节点到叶子结点的所有路径，以二维列表形式</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getpath</span>(<span class="params">curpath,root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                <span class="comment"># 结束条件</span></span><br><span class="line">                <span class="keyword">if</span> root.lchild == <span class="literal">None</span> <span class="keyword">and</span> root.rchild == <span class="literal">None</span>:  <span class="comment"># 到了叶子结点</span></span><br><span class="line">                    res.append([self.root.elem]+curpath)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="comment"># for 选择 in 选择列表</span></span><br><span class="line">                <span class="keyword">for</span> node <span class="keyword">in</span> (root.lchild,root.rchild):</span><br><span class="line">                    <span class="keyword">if</span> node: <span class="comment">#左右子树可能为None</span></span><br><span class="line">                        <span class="comment"># 做选择</span></span><br><span class="line">                        curpath.append(node.elem)</span><br><span class="line">                        <span class="comment"># backtrack()</span></span><br><span class="line">                        getpath(curpath.copy(), node)</span><br><span class="line">                        <span class="comment"># 撤销选择</span></span><br><span class="line">                        curpath.pop()</span><br><span class="line"></span><br><span class="line">        res = [] <span class="comment">#记录所有路径</span></span><br><span class="line">        getpath(curpath=[], root=root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allPath3</span>(<span class="params">self,root</span>):</span></span><br><span class="line">        <span class="comment"># 返回根节点到叶子结点的所有路径，以二维列表形式</span></span><br><span class="line">        <span class="string">"""类似于DFS</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getpath</span>(<span class="params">curpath,root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                curpath.append(root.elem)</span><br><span class="line">                <span class="keyword">if</span> root.lchild == <span class="literal">None</span> <span class="keyword">and</span> root.rchild==<span class="literal">None</span>:<span class="comment">#到了叶子结点</span></span><br><span class="line">                    res.append(curpath)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">for</span> node <span class="keyword">in</span> (root.lchild,root.rchild):</span><br><span class="line">                    getpath(curpath.copy(), node)</span><br><span class="line">                    <span class="comment"># getpath(curpath.copy(), root.lchild)</span></span><br><span class="line">                    <span class="comment"># getpath(curpath.copy(), root.rchild)</span></span><br><span class="line"></span><br><span class="line">        res = [] <span class="comment">#记录所有路径</span></span><br><span class="line">        getpath(curpath=[], root=root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allPath2</span>(<span class="params">self, root</span>):</span><span class="comment">#旧版本</span></span><br><span class="line">        <span class="comment"># 返回根节点到叶子结点的所有路径，以二维列表形式</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        思路，两个list，curpatlist记录树的根节点当前结点的路径;</span></span><br><span class="line"><span class="string">        pathlist记录根节点到叶节点的所有路径。</span></span><br><span class="line"><span class="string">        通过递归形式走到叶子节点，若到了叶节点，则将pathlist.append(curpathlist)</span></span><br><span class="line"><span class="string">        而且curpathlist要pop，返回上一层</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get_paths</span>(<span class="params">root, curpathlist, pathlist</span>):</span></span><br><span class="line">            <span class="comment"># 当前节点，当前路径（树根节点到当前结点的路径），所有的路径结果</span></span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                curpathlist.append(root.elem)</span><br><span class="line"></span><br><span class="line">                left = get_paths(root.lchild, curpathlist, pathlist)</span><br><span class="line">                right = get_paths(root.rchild, curpathlist, pathlist)</span><br><span class="line">                <span class="comment"># 如果到达叶子结点，则将当前结果添加到所有结果列表中；</span></span><br><span class="line">                <span class="keyword">if</span> left == <span class="literal">False</span> <span class="keyword">and</span> right == <span class="literal">False</span>:</span><br><span class="line">                    pathlist.append(curpathlist.copy())  <span class="comment"># 把当前路径加入到结果列表中</span></span><br><span class="line">                    <span class="comment"># 注意要copy下，若不copy，curpathlist.pop会改变pathlist</span></span><br><span class="line">                curpathlist.pop()  <span class="comment"># 返回上一层递归时，弹出路径中的当前结点元素</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        pathlist = []</span><br><span class="line">        get_paths(root, [], pathlist)</span><br><span class="line">        <span class="keyword">return</span> pathlist</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, elem</span>):</span></span><br><span class="line">        <span class="comment"># 按广度优先添加元素</span></span><br><span class="line">        newNode = Node(elem)</span><br><span class="line">        <span class="keyword">if</span> self.root == <span class="literal">None</span>:</span><br><span class="line">            self.root = newNode</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        queue = [self.root]  <span class="comment"># 使用队列实现，先将root加入</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            curNode = queue.pop(<span class="number">0</span>)  <span class="comment"># 获取队首节点</span></span><br><span class="line">            <span class="keyword">if</span> curNode.lchild <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                curNode.lchild = newNode  <span class="comment"># 当前结点没有左孩子，直接加到左孩子上</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                queue.append(curNode.lchild)</span><br><span class="line">            <span class="keyword">if</span> curNode.rchild <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                curNode.rchild = newNode</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                queue.append(curNode.rchild)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">BFS</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 广度优先遍历BFS,用队列实现，</span></span><br><span class="line">        <span class="keyword">if</span> self.root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        queue = [self.root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            curNode = queue.pop(<span class="number">0</span>)  <span class="comment"># 返回队首元素</span></span><br><span class="line">            print(curNode.elem, end=<span class="string">","</span>)</span><br><span class="line">            <span class="keyword">if</span> curNode.lchild:</span><br><span class="line">                queue.append(curNode.lchild)</span><br><span class="line">            <span class="keyword">if</span> curNode.rchild:</span><br><span class="line">                queue.append(curNode.rchild)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">DFS</span>(<span class="params">self, root</span>):</span>  <span class="comment"># 非递归深度优先遍历</span></span><br><span class="line">        <span class="comment"># 用栈实现，先将根入栈，再将根出栈，并将根的右子树，左子树存入栈，</span></span><br><span class="line">        <span class="comment"># 按照栈的先进后出规则来实现深度优先遍历。</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            res = []</span><br><span class="line">            stack = [root]</span><br><span class="line">            <span class="keyword">while</span> stack:</span><br><span class="line">                curnode = stack.pop()  <span class="comment"># 返回栈顶元素</span></span><br><span class="line">                res.append(curnode.elem)</span><br><span class="line">                <span class="keyword">if</span> curnode.rchild:</span><br><span class="line">                    stack.append(curnode.rchild)  <span class="comment"># 先右子树再左子树</span></span><br><span class="line">                <span class="keyword">if</span> curnode.lchild:</span><br><span class="line">                    stack.append(curnode.lchild)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="comment"># 深度优先遍历，先序遍历，根左右</span></span><br><span class="line">        <span class="comment"># 不return</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        print(node.elem, end=<span class="string">" "</span>)</span><br><span class="line">        self.preorder(node.lchild)</span><br><span class="line">        self.preorder(node.rchild)</span><br><span class="line">        <span class="comment"># return 返回值 第一种方法</span></span><br><span class="line">        <span class="comment"># if node is None:</span></span><br><span class="line">        <span class="comment">#    return []</span></span><br><span class="line">        <span class="comment"># res = []</span></span><br><span class="line">        <span class="comment"># res.append(node.elem)</span></span><br><span class="line">        <span class="comment"># res += self.preorder(node.lchild)</span></span><br><span class="line">        <span class="comment"># res += self.preorder(node.rchild)</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line">        <span class="comment"># retrun 第二种方法</span></span><br><span class="line">        <span class="comment"># if node is None:</span></span><br><span class="line">        <span class="comment">#    return []</span></span><br><span class="line">        <span class="comment"># left = self.preorder(node.lchild)</span></span><br><span class="line">        <span class="comment"># right = self.preorder(node.rchild)</span></span><br><span class="line">        <span class="comment"># return [node.elem]+left+right</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="comment"># 中序遍历，左根右</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.inorder(node.lchild)</span><br><span class="line">        print(node.elem, end=<span class="string">" "</span>)</span><br><span class="line">        self.inorder(node.rchild)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorder</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="comment"># 后序遍历，左右根</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.postorder(node.lchild)</span><br><span class="line">        self.postorder(node.rchild)</span><br><span class="line">        print(node.elem, end=<span class="string">" "</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">depth</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="comment"># 讲解二叉树的深度 [解答](https://sbaban.com/jzo55.html)</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        leftdepth = self.depth(node.lchild)</span><br><span class="line">        rightdepth = self.depth(node.rchild)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(leftdepth, rightdepth) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mytree = Tree()</span><br><span class="line"><span class="comment"># for i in range(10):</span></span><br><span class="line"><span class="comment">#    mytree.add(i)</span></span><br><span class="line">mytree.root = mytree.createfromlist(mytree.root, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, -<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line">mytree.BFS()</span><br><span class="line"><span class="comment"># mytree.allPath(mytree.root)</span></span><br><span class="line">mytree.depth(mytree.root)</span><br><span class="line">print(mytree.allPath(mytree.root))</span><br></pre></td></tr></tbody></table></figure>
<p>参考《算法图解》与https://www.bilibili.com/video/av38669550/?p=36</p>
<h3 id="红黑树">红黑树</h3>
<p>二叉查找树的一种。</p>
<p>四个性质：①每个节点不是红色就是黑色。 ②根节点和叶子结点（这里的叶子节点指的是None结点）是黑色</p>
<p>③不能出现连在一起的红色结点。 ④每个红色结点的两个子节点都是黑色。</p>
<p>代码待补充</p>
<h2 id="堆">堆</h2>
<p>堆排序的效率与快排、归并相同，都达到了基于比较的排序算法效率的峰值（时间复杂度为<strong>O(nlogn )</strong> ）</p>
<p>堆排序的空间复杂度是<strong>O(1 )</strong></p>
<p><img src="/pys19/堆.png"></p>
<p>堆需要满足的条件：</p>
<ul>
<li>1.必须是二叉树，且必须是完全二叉树</li>
<li>2.各个父节点必须大于或小于左右结点， 其中最顶层的根结点必须是最大或者最小的.</li>
<li>3.堆中每个节点的子树都是堆树。</li>
</ul>
<p>堆的创建与删除：https://www.bilibili.com/video/av18980178/</p>
<h3 id="heapq模块">heapq模块</h3>
<p>heapq不支持大根堆，在<a href="http://stackoverflow.com/questions/14189540/python-topn-max-heap-use-heapq-or-self-implement">stackoverflow</a>上看到了一个巧妙的实现：用小根堆来进行逻辑操作，在做<code>push</code>的时候，我们把最大数的相反数存进去，那么它的相反数就是最小数，仍然是堆顶元素，在访问堆顶的时候，再对它取反，就获取到了最大数。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">data = [<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#建立堆,有两种方式，heappush()和heapify()。</span></span><br><span class="line"><span class="comment"># heapq.heapify(data) #直接将原列表转为堆,</span></span><br><span class="line">heap = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">  heapq.heappush(heap,i)</span><br><span class="line"><span class="comment"># print(heap) #[0, 2, 1, 5, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#添加新数据</span></span><br><span class="line">heapq.heappush(heap,<span class="number">0.5</span>)</span><br><span class="line"><span class="comment"># print(heap) # [0, 2, 0.5, 5, 9, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#弹出堆顶元素，并return 堆顶</span></span><br><span class="line">heapq.heappop(heap) <span class="comment"># return 0</span></span><br><span class="line">print(heap) <span class="comment"># [0.5, 2, 1, 5, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#heapq.nlargest(n, iterable, key=None)</span></span><br><span class="line"><span class="comment">#返回可迭代对象iterable最大的n个元素（Top-K问题），key与sorted()的key类似</span></span><br><span class="line"><span class="comment">#https://blog.csdn.net/m0_38109046/article/details/86636511?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</span></span><br><span class="line"></span><br><span class="line">heapq.nlargest(<span class="number">3</span>, heap) <span class="comment">#[9, 5, 2]</span></span><br><span class="line">heapq.nlargest(<span class="number">3</span>, heap, key=<span class="keyword">lambda</span> x:x&lt;<span class="number">5</span>)<span class="comment">#[0.5, 2, 1]</span></span><br><span class="line"><span class="comment">#heapq.nsmallest(n, iterable, key=None) </span></span><br><span class="line"><span class="comment">#返回最小的n个元素（Top-K问题）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># heapq.heappushpop(heap, elem) </span></span><br><span class="line"><span class="comment">#先把elem加入到堆中，然后再pop，比heappush()再heappop()要快得多</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#heapq.heapreplace(heap, elem) </span></span><br><span class="line"><span class="comment">#先pop，然后再把elem加入到堆中，比heappop()再heappush()要快得多</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="排序">排序</h2>
<p>排序算法的<strong>稳定性</strong>是指原本有相等键值的记录维持相对词序。</p>
<p>如3 1 3 4 排序后依然是1 3 3 4（两个3的相对位置没有变）</p>
<h3 id="冒泡排序">冒泡排序</h3>
<p>bubble sort，需要进行n-1次冒泡。稳定性：稳定</p>
<p>1比较相邻元素，排序</p>
<p>2对每一对相邻元素同样的操作，</p>
<p>3重复</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span>(<span class="params">mylist</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(mylist)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n-<span class="number">1</span>):<span class="comment">#执行n-1次冒泡</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n-i-<span class="number">1</span>):<span class="comment"># n-i-1次相邻元素比较</span></span><br><span class="line">            <span class="keyword">if</span> mylist[j] &gt; mylist[j+<span class="number">1</span>]:</span><br><span class="line">                mylist[j], mylist[j+<span class="number">1</span>] = mylist[j+<span class="number">1</span>], mylist[j]</span><br><span class="line"></span><br><span class="line">改进：</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span>(<span class="params">mylist</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(mylist)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n-<span class="number">1</span>):<span class="comment">#执行n-1次冒泡</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n-i-<span class="number">1</span>):<span class="comment"># n-i-1次相邻元素比较</span></span><br><span class="line">            <span class="keyword">if</span> mylist[j] &gt; mylist[j+<span class="number">1</span>]:</span><br><span class="line">                mylist[j], mylist[j+<span class="number">1</span>] = mylist[j+<span class="number">1</span>], mylist[j]</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">0</span>: <span class="comment">#说明已经有序了</span></span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="选择排序">选择排序</h3>
<p>遍历未排列的元素中，找出最小值，放入已排序序列。</p>
<p>重复</p>
<p>时间复杂度为<span class="math inline">\(O(n^2)\)</span>，稳定性：不稳定(考虑升序排列，每次选择最大值放在右边)</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">mylist = [<span class="number">10</span>,<span class="number">1</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectSort</span>(<span class="params">mylist</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(mylist)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n-<span class="number">1</span>):<span class="comment">#找n-1次最小值</span></span><br><span class="line">        minIndex = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> mylist[j] &lt; mylist[minIndex]:</span><br><span class="line">                minIndex = j</span><br><span class="line">        mylist[i], mylist[minIndex] = mylist[minIndex], mylist[i]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(selectSort(mylist))</span><br></pre></td></tr></tbody></table></figure>
<h3 id="插入排序">插入排序</h3>
<p>从无序序列中取一个元素，与有序序列中的元素比较插入，（打扑克）.</p>
<p>稳定性：稳定</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertSort</span>(<span class="params">mylist</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(mylist)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">1</span>, n): <span class="comment">#n-1个元素进行比较</span></span><br><span class="line">        j = i</span><br><span class="line">        <span class="keyword">while</span> j &gt; <span class="number">0</span>: <span class="comment">#从右边无序序列中取第一个元素与排好序的序列比较</span></span><br><span class="line">            <span class="keyword">if</span> mylist[j] &lt; mylist[j-<span class="number">1</span>]:</span><br><span class="line">                <span class="comment">#每个元素都与前一个比较：</span></span><br><span class="line">                mylist[j], mylist[j-<span class="number">1</span>] = mylist[j-<span class="number">1</span>], mylist[j]</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="comment">#优化，新元素比已排序的最后一个要大，此元素无需再比较</span></span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="希尔排序">希尔排序</h3>
<p>Shell Sort是插入排序的一种，也叫缩小增量排序。稳定性：不稳定</p>
<p>注意对各个组插入排序的时候，不是先对一个组排序完再对另一个组进行排序，而是轮流对每个组进行插入排序。(77与54排序后，再对31与26排序,再44与93，再55与17.再20与【54，77】排序)</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shellSort</span>(<span class="params">mylist</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(mylist)</span><br><span class="line">    gap = n//<span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap, <span class="built_in">len</span>(mylist)):<span class="comment">#从gap索引处比较，注意是轮流对每个组插入排序</span></span><br><span class="line">            j = i</span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span>: <span class="comment">#小组的插入排序</span></span><br><span class="line">                <span class="keyword">if</span> mylist[j] &lt; mylist[j-gap]:</span><br><span class="line">                    mylist[j], mylist[j-gap] = mylist[j-gap], mylist[j]</span><br><span class="line">                    j -= gap</span><br><span class="line">                <span class="keyword">else</span>: <span class="comment">#</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        gap = gap // <span class="number">2</span> <span class="comment">#一次gap分组的排序完成，继续按gap分组</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="快速排序">快速排序</h3>
<p>采用分而治之策略，时间复杂度为<span class="math inline">\(O(logn)\)</span></p>
<p>首先选择一个元素作为基准，比它小的放左边，比它大的放右边。</p>
<p>同样地对左边的元素们进行此操作，对右边的元素们进行此操作。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">mylist = [<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span>(<span class="params">mylist</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(mylist) &lt; <span class="number">2</span>:<span class="comment">#base case只剩0或1个元素，不用排序</span></span><br><span class="line">        <span class="keyword">return</span> mylist</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        less = []</span><br><span class="line">        greater = []</span><br><span class="line">        base = mylist[<span class="number">0</span>] <span class="comment">#这里选的第一个元素用于比较，实际上应该随机选</span></span><br><span class="line">        <span class="keyword">for</span> elem <span class="keyword">in</span> mylist[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> elem &lt;= base:</span><br><span class="line">                less.append(elem)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                greater.append(elem)</span><br><span class="line">        <span class="keyword">return</span> quickSort(less) + [base] + quickSort(greater)</span><br><span class="line"></span><br><span class="line">print(quickSort(mylist))</span><br></pre></td></tr></tbody></table></figure>
<p>这段代码虽然短小利于理解，但是其效率很低，主要体现在以下方面：</p>
<ul>
<li><p>分组基准的选取过于随便，不一定可以取到列表的中间值</p></li>
<li><p>空间复杂度大，使用了两个列表（less和greater），而且每次选取进行比较时需要遍历整个序列。</p></li>
<li><p>若序列长度过于小(比如只有几个元素)，快排效率就不如插入排序了。</p></li>
<li><p>递归影响性能，最好进行优化。</p></li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">下面用Python写一个C风格的快排(这里可以体会到快排的精髓)：</span><br><span class="line">mylist = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">mylist,low,high</span>):</span></span><br><span class="line">    <span class="comment">#选择mylist[low]元素作为分界点，low和high是mylist的下标</span></span><br><span class="line">    <span class="comment">#此函数将比分界点小的放左边，比分界点大的放右边，</span></span><br><span class="line">    <span class="comment">#返回分界点的位置索引low</span></span><br><span class="line">    midValue = mylist[low]</span><br><span class="line">    <span class="keyword">while</span> low&lt;high:<span class="comment">#high左移和low右移交替进行</span></span><br><span class="line">        <span class="keyword">while</span> low&lt;high <span class="keyword">and</span> mylist[high]&gt;= midValue: </span><br><span class="line">            <span class="comment">#mylist[high]&gt;midvalue,high就一直左移</span></span><br><span class="line">            high -= <span class="number">1</span></span><br><span class="line">        mylist[low] = mylist[high]<span class="comment">#high处元素小于midValue，赋给low所在位置,赋值后high处的元素就没意义了</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> low&lt;high <span class="keyword">and</span> mylist[low] &lt; midValue: <span class="comment">#low一直右移</span></span><br><span class="line">            low += <span class="number">1</span></span><br><span class="line">        mylist[high] = mylist[low] <span class="comment"># 赋给high所在位置，</span></span><br><span class="line"></span><br><span class="line">    mylist[low] = midValue</span><br><span class="line">    <span class="keyword">return</span> low <span class="comment">#返回分界点索引</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span>(<span class="params">mylist, low, high</span>):</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :param mylist:</span></span><br><span class="line"><span class="string">    :param low:第一个元素下标</span></span><br><span class="line"><span class="string">    :param high: 最后一个元素下标</span></span><br><span class="line"><span class="string">    :return: none</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> low &lt; high:</span><br><span class="line">        middleIndex = partition(mylist,low,high)</span><br><span class="line"></span><br><span class="line">        quicksort(mylist, low, middleIndex-<span class="number">1</span>) <span class="comment">#递归处理前半段</span></span><br><span class="line">        <span class="comment"># 注意不能用切片，即quicksort( mylist[:low])</span></span><br><span class="line">        <span class="comment"># 因为mylist[;low]和mylist的id不同，更改mylist[:low]不能改变mylist，要传递完整的list</span></span><br><span class="line">        quicksort(mylist, middleIndex+<span class="number">1</span>, high) <span class="comment">#递归处理后半段</span></span><br><span class="line">    <span class="keyword">return</span> mylist</span><br></pre></td></tr></tbody></table></figure>
<h3 id="归并排序">归并排序</h3>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">mylist = [<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span>(<span class="params">mylist</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(mylist)</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> mylist</span><br><span class="line">    mid = n // <span class="number">2</span></span><br><span class="line">    <span class="comment"># 分别对左右两个list进行处理，分别返回两个排序对list</span></span><br><span class="line">    left = mergeSort(mylist[:mid])</span><br><span class="line">    right = mergeSort(mylist[mid:])</span><br><span class="line">    <span class="comment"># 对排序好的两个列表合并，产生一个新的排序好的列表</span></span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">left, right</span>):</span></span><br><span class="line">    <span class="comment">#合并两个有序的list</span></span><br><span class="line">    result = []</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(right):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt; right[j]:</span><br><span class="line">            result.append(left[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    result += left[i:]</span><br><span class="line">    result += right[j:]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">print(mergeSort(mylist))</span><br></pre></td></tr></tbody></table></figure>
<h2 id="查找">查找</h2>
<h3 id="二分查找">二分查找</h3>
<p>输入必须是<strong>有序</strong>的元素列表，时间复杂度为<span class="math inline">\(O(logn)\)</span>。</p>
<p>对于包含n个元素的列表，二分查找最多需要<span class="math inline">\(log_2 ^n\)</span>步。</p>
<p>比较中间的值，比中间值小，在左边元素里查找，大了就在右边找。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">mylist = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">mylist, item</span>):</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :param mylist: 有序列表</span></span><br><span class="line"><span class="string">    :param item: 要查找的元素</span></span><br><span class="line"><span class="string">    :return: 返回其位置</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = <span class="built_in">len</span>(mylist) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = <span class="built_in">int</span>((low + high) / <span class="number">2</span>)</span><br><span class="line">        guess = mylist[mid]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> guess == item:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> guess &lt; item:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">print(binary_search(mylist,<span class="number">3</span>))</span><br></pre></td></tr></tbody></table></figure>
<p>递归版本</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#错误代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">mylist, item</span>):</span></span><br><span class="line"></span><br><span class="line">    mid = <span class="built_in">int</span>(<span class="built_in">len</span>(mylist)/<span class="number">2</span>)</span><br><span class="line">    print(mid)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> item &lt; mylist[mid]:</span><br><span class="line">        binary_search(mylist[:mid], item)</span><br><span class="line">    <span class="keyword">elif</span> item &gt; mylist[mid]:</span><br><span class="line">        binary_search(mylist[mid+<span class="number">1</span>:], item)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span><span class="comment"># 不能用递归，这里并不会结束，而是会返回递归的上一次继续执行binarySerach</span></span><br><span class="line"><span class="comment">#这句话是我之前分析的错误原因，now发现问题了。   </span></span><br><span class="line"><span class="comment">#问题的原因在于if和else里没加return，返回不到之前的层。</span></span><br><span class="line">改正：</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span>(<span class="params">mylist, item</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(mylist) &gt; <span class="number">0</span>:</span><br><span class="line">        mid = <span class="built_in">int</span>(<span class="built_in">len</span>(mylist)/<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> item &lt; mylist[mid]:</span><br><span class="line">            <span class="keyword">return</span> binarySearch(mylist[:mid], item)</span><br><span class="line">        <span class="keyword">elif</span> item &gt; mylist[mid]:</span><br><span class="line">            <span class="keyword">return</span> binarySearch(mylist[mid+<span class="number">1</span>:], item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span>    </span><br></pre></td></tr></tbody></table></figure>
<h2 id="递归">递归</h2>
<p>每个递归函数都有两部分：基线条件（base case）和递归条件（recursive case）。递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己，从而避免形成无限循环。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span>(<span class="params">i</span>):</span><span class="comment">#倒计时</span></span><br><span class="line">    <span class="built_in">print</span> i</span><br><span class="line">    <span class="keyword">if</span> i &lt;= <span class="number">0</span>: <span class="comment">#base case</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        countdown(i-<span class="number">1</span>) <span class="comment">#recursive case</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="哈希表">哈希表</h2>
<p>哈希函数是这样的函数，即无论你给它什么数据，它都还你一个数字，即将不同的输入映射到不同的数字。</p>
<p>python的字典dict {}就是哈希表的实现</p>
<h4 id="冲突">冲突</h4>
<p>不同的键key映射到了相同的位置</p>
<p>解决方法：</p>
<p>如果两个键映射到了同一个位置，就在这个位置存储一个链表。</p>
<p>比如apples和avocadado映射到了同一位置，可在这个位置存储一个链表。</p>
<p>填装因子(包含的元素数/空间总数)越低，发生冲突的可能性越小，散列表的性能越高。一个不错的经验规则是：一旦填装因子大于0.7，就调整散列表的长度。</p>
<h2 id="图">图</h2>
<h3 id="所有路径">所有路径</h3>
<p>类似于深度优先遍历</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#有关树型的遍历问题都可用回溯模版【建议】https://sbaban.com/myfuncs.html</span></span><br><span class="line">graph = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[],[<span class="number">5</span>],[<span class="number">5</span>],[]]</span><br><span class="line"><span class="comment">#表示的路径是0-1/2,1-3/4,2-None,3-5,4-5,5-None</span></span><br><span class="line">res = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">curpath, root</span>):</span></span><br><span class="line">    <span class="comment"># 结束条件</span></span><br><span class="line">    <span class="keyword">if</span> graph[root] == []:</span><br><span class="line">        res.append([<span class="number">0</span>]+curpath)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment">#for 选择 in 选择列表</span></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> graph[root]:</span><br><span class="line">        <span class="comment">#做选择</span></span><br><span class="line">        curpath.append(node)</span><br><span class="line">        <span class="comment">#backtrack()</span></span><br><span class="line">        dfs(curpath.copy(),node)</span><br><span class="line">        <span class="comment">#撤销选择</span></span><br><span class="line">        curpath.pop()</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dfs([], root=<span class="number">0</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment">#[[0, 1, 3, 5], [0, 1, 4, 5], [0, 2]]</span></span><br><span class="line"></span><br><span class="line">=======================================</span><br><span class="line"></span><br><span class="line">graph = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[],[<span class="number">5</span>],[<span class="number">5</span>],[]]</span><br><span class="line"><span class="comment">#表示的路径是0-1/2,1-3/4,2-None,3-5,4-5,5-None</span></span><br><span class="line">res = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">curpath, root</span>):</span></span><br><span class="line">    curpath.append(root)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(graph[root]) == <span class="number">0</span>:</span><br><span class="line">        res.append(curpath)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> graph[root]:</span><br><span class="line">        dfs(curpath.copy(), node)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dfs([], root=<span class="number">0</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment">#[[0, 1, 3, 5], [0, 1, 4, 5], [0, 2]]</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="广度优先深度优先">广度优先深度优先</h3>
<p>breadtf-first search(BFS)主要解决两类问题：</p>
<p>第一类问题：从节点A出发，有前往节点B的路径吗？</p>
<p>第二类问题：从节点A出发，前往节点B的哪条路径最短(这里的最短不是指最快，而是指段数最少)</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">graph = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[],[<span class="number">5</span>],[<span class="number">5</span>],[]]</span><br><span class="line"><span class="comment">#表示的路径是0-1/2,1-3/4,2-None,3-5,4-5,5-None</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BFS</span>(<span class="params">root</span>):</span></span><br><span class="line">    queue = [root] <span class="comment">#将root放入队列</span></span><br><span class="line">    res = [] <span class="comment">#存储所有访问的节点</span></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        curnode = queue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> curnode <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">            res.append(curnode)</span><br><span class="line">            queue.extend(graph[curnode])<span class="comment">#注意是extend，因为下一个节点不只有一个</span></span><br><span class="line">            <span class="comment">#或者用for</span></span><br><span class="line">            <span class="comment">#for notsearchNode in graph[curnode]:</span></span><br><span class="line">            <span class="comment">#    queue.append(notsearchNode)</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">BFS(root=<span class="number">0</span>)</span><br><span class="line">[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">-----------------------------------</span><br><span class="line"><span class="comment">#DFS非递归实现</span></span><br><span class="line">graph = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[],[<span class="number">5</span>],[<span class="number">5</span>],[]]</span><br><span class="line"><span class="comment">#表示的路径是0-1/2,1-3/4,2-None,3-5,4-5,5-None</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DFS</span>(<span class="params">root</span>):</span></span><br><span class="line">    stack = [root] <span class="comment">#将root放入队列</span></span><br><span class="line">    res = [] <span class="comment">#存储所有访问的节点</span></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        curnode = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> curnode <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">            res.append(curnode)</span><br><span class="line">            stack.extend(graph[curnode][::-<span class="number">1</span>])<span class="comment">#注意加个【：：-1】</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">DFS(root = <span class="number">0</span>)</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#===DFS递归实现</span></span><br><span class="line"><span class="comment">#模版方法，【推荐】</span></span><br><span class="line">graph = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[],[<span class="number">5</span>],[<span class="number">5</span>],[]]</span><br><span class="line">vistied = []  <span class="comment">#必须在函数外建立一个列表存储已经访问的节点</span></span><br><span class="line">res = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DFS</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="comment"># 结束条件</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">not</span> <span class="keyword">in</span> vistied:</span><br><span class="line">        vistied.append(root)</span><br><span class="line">        res.append(root)</span><br><span class="line">    <span class="comment">#for 选择 in 选择列表</span></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> graph[root]:</span><br><span class="line">        <span class="comment">#做选择</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#backtrack()</span></span><br><span class="line">        DFS(node)</span><br><span class="line">        <span class="comment">#撤销选择</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">===============</span><br><span class="line">graph = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[],[<span class="number">5</span>],[<span class="number">5</span>],[]]</span><br><span class="line">vistied = []  <span class="comment">#必须在函数外建立一个列表存储已经访问的节点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DFS</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root == []:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">not</span> <span class="keyword">in</span> vistied:</span><br><span class="line">        vistied.append(root)</span><br><span class="line">        res.append(root)</span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> graph[root]:</span><br><span class="line">            res += DFS(node)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">print(DFS(<span class="number">0</span>))</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 有向图中以广度优先搜索找以m结尾的人</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用dict创建有向图</span></span><br><span class="line">graph = {}</span><br><span class="line">graph[<span class="string">"you"</span>] = [<span class="string">"alice"</span>, <span class="string">"bob"</span>, <span class="string">"claire"</span>]</span><br><span class="line">graph[<span class="string">"bob"</span>] = [<span class="string">"anuj"</span>, <span class="string">"peggy"</span>]</span><br><span class="line">graph[<span class="string">"alice"</span>] = [<span class="string">"peggy"</span>]</span><br><span class="line">graph[<span class="string">"claire"</span>] = [<span class="string">"thom"</span>, <span class="string">"jonny"</span>]</span><br><span class="line">graph[<span class="string">"anuj"</span>] = []</span><br><span class="line">graph[<span class="string">"peggy"</span>] = []</span><br><span class="line">graph[<span class="string">"thom"</span>] = []</span><br><span class="line">graph[<span class="string">"jonny"</span>] = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPerson</span>(<span class="params">name</span>):</span><span class="comment">#检测是否是要找的人</span></span><br><span class="line">    <span class="keyword">return</span> name[-<span class="number">1</span>] == <span class="string">'m'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span>():</span></span><br><span class="line">    search_queue = [<span class="string">"you"</span>]  <span class="comment"># 创建一个队列,将图的第一层加入队列</span></span><br><span class="line">    searched = []</span><br><span class="line">    <span class="comment"># 记录已经找过的人，节省时间，同时避免陷入死循环(a朋友里有b，b朋友里有a)</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> search_queue:  <span class="comment"># 搜索队列不为空</span></span><br><span class="line">        person = search_queue.pop(<span class="number">0</span>)  <span class="comment"># 取出队列的第一个（根结点）</span></span><br><span class="line">        <span class="keyword">if</span> person <span class="keyword">not</span> <span class="keyword">in</span> searched:</span><br><span class="line">            res.append(person)</span><br><span class="line">            <span class="keyword">if</span> isPerson(person):</span><br><span class="line">                print(<span class="string">"find "</span>)</span><br><span class="line">                print(res)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 若不是，将此人的朋友(第二层图)加入到队列后，继续搜索队列中的第一层图。</span></span><br><span class="line">                search_queue.extend(graph[person] )</span><br><span class="line">                searched.append(person)</span><br><span class="line">    print(<span class="string">"not find"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">search()</span><br></pre></td></tr></tbody></table></figure>
<h3 id="迪杰斯特拉">迪杰斯特拉</h3>
<p>可应用于有向无向有环无环图，不能用于有负权边的图（对于负权边最短路径，可用贝尔曼福德算法（Bellman-Ford）。</p>
<ol type="1">
<li>找出“最便宜”的节点，即可在最短时间内到达的节点。</li>
<li>对于剩下的结点，检查在该节点基础上是否有前往它们的更短路径，如果有，就更新其开销。</li>
<li>重复这个过程，直到对图中的每个节点都这样做了。</li>
<li>计算最终路径。</li>
</ol>
<p>以下图为例</p>
<p><img src="/pys19/迪杰斯特拉.png"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">graph = {}</span><br><span class="line">graph [<span class="string">'start'</span>]= {}</span><br><span class="line">graph[<span class="string">'start'</span>][<span class="string">'a'</span>] = <span class="number">6</span></span><br><span class="line">graph[<span class="string">'start'</span>][<span class="string">'b'</span>] = <span class="number">2</span></span><br><span class="line">graph [<span class="string">'b'</span>]= {}</span><br><span class="line">graph[<span class="string">'b'</span>][<span class="string">'a'</span>] = <span class="number">3</span></span><br><span class="line">graph[<span class="string">'b'</span>][<span class="string">'end'</span>] = <span class="number">5</span></span><br><span class="line">graph[<span class="string">'a'</span>] = {}</span><br><span class="line">graph[<span class="string">'a'</span>][<span class="string">'end'</span>] = <span class="number">1</span></span><br><span class="line">graph[<span class="string">'end'</span>] = {}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建cost表，cost指从起点到该点的cost</span></span><br><span class="line">infinity = <span class="built_in">float</span>(<span class="string">"inf"</span>) <span class="comment">#表示无穷大</span></span><br><span class="line">costs ={}</span><br><span class="line">costs[<span class="string">'a'</span>] = <span class="number">6</span>  <span class="comment">#起点到a的cost为6</span></span><br><span class="line">costs[<span class="string">'b'</span>] = <span class="number">2</span></span><br><span class="line">costs[<span class="string">'end'</span>] = infinity</span><br><span class="line"></span><br><span class="line"><span class="comment">#存储父节点的哈希表</span></span><br><span class="line">parents = {}</span><br><span class="line">parents[<span class="string">'a'</span>] = <span class="string">"start"</span></span><br><span class="line">parents[<span class="string">'b'</span>] = <span class="string">"start"</span></span><br><span class="line">parents[<span class="string">'end'</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">processed = [] <span class="comment">#记录已处理过的结点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_lowest_cost_node</span>(<span class="params">costs</span>):</span></span><br><span class="line">    <span class="comment">#在costs中找cost最小的</span></span><br><span class="line">    lowest_cost = infinity</span><br><span class="line">    lowest_cost_node = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> costs:</span><br><span class="line">        <span class="keyword">if</span> costs[node] &lt; lowest_cost <span class="keyword">and</span> node <span class="keyword">not</span> <span class="keyword">in</span> processed:</span><br><span class="line">            lowest_cost = costs[node]</span><br><span class="line">            lowest_cost_node = node</span><br><span class="line">    <span class="keyword">return</span> lowest_cost_node</span><br><span class="line"></span><br><span class="line">node = find_lowest_cost_node(costs) <span class="comment">#在未处理的nodes中找cost最小的</span></span><br><span class="line"><span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    cost = costs[node] <span class="comment">#起点到该node 的cost</span></span><br><span class="line">    neighbors = graph[node] <span class="comment">#该node 的下一站结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#在该node基础上，更新前往剩余nodes的更小的cost</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> neighbors.keys(): <span class="comment">#对该node的每个neighbor，n是neigbor</span></span><br><span class="line">        newcost = cost + graph[node][n]</span><br><span class="line">        <span class="keyword">if</span> newcost &lt; costs[n]:</span><br><span class="line">            costs[n] = newcost</span><br><span class="line">            parents[n] = node</span><br><span class="line">    processed.append(node)</span><br><span class="line">    node = find_lowest_cost_node(costs)</span><br><span class="line"></span><br><span class="line">print(costs[end]) <span class="comment">#到end的最短路径</span></span><br><span class="line"><span class="comment">#倒序输出最短路径</span></span><br><span class="line">node = <span class="string">'end'</span></span><br><span class="line">print(node)</span><br><span class="line"><span class="keyword">while</span> parents[node] != <span class="string">'start'</span>:</span><br><span class="line">    node = parents[node]</span><br><span class="line">    print(node)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="贪心算法">贪心算法</h2>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#选择最少的广播台覆盖所有的8个州</span></span><br><span class="line"><span class="comment">#使用贪心算法，每次选择覆盖州最多的广播台</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要被覆盖的州，即还未覆盖的州</span></span><br><span class="line">states_needed = <span class="built_in">set</span>([<span class="string">"mt"</span>, <span class="string">"wa"</span>, <span class="string">"or"</span>, <span class="string">"id"</span>, <span class="string">"nv"</span>, <span class="string">"ut"</span>,<span class="string">"ca"</span>, <span class="string">"az"</span>])</span><br><span class="line"><span class="comment"># 广播台清单</span></span><br><span class="line">stations = {}</span><br><span class="line">stations[<span class="string">"kone"</span>] = <span class="built_in">set</span>([<span class="string">"id"</span>, <span class="string">"nv"</span>, <span class="string">"ut"</span>])</span><br><span class="line">stations[<span class="string">"ktwo"</span>] = <span class="built_in">set</span>([<span class="string">"wa"</span>, <span class="string">"id"</span>, <span class="string">"mt"</span>])</span><br><span class="line">stations[<span class="string">"kthree"</span>] = <span class="built_in">set</span>([<span class="string">"or"</span>, <span class="string">"nv"</span>, <span class="string">"ca"</span>])</span><br><span class="line">stations[<span class="string">"kfour"</span>] = <span class="built_in">set</span>([<span class="string">"nv"</span>, <span class="string">"ut"</span>])</span><br><span class="line">stations[<span class="string">"kfive"</span>] = <span class="built_in">set</span>([<span class="string">"ca"</span>, <span class="string">"az"</span>])</span><br><span class="line"><span class="comment">#最终选择的广播台</span></span><br><span class="line">final_stations = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> states_needed: <span class="comment">#只要未覆盖完</span></span><br><span class="line">    best_station = <span class="literal">None</span></span><br><span class="line">    states_covered = <span class="built_in">set</span>() <span class="comment">#存储已经覆盖的州</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#每次取覆盖最多的州的广播台</span></span><br><span class="line">    <span class="keyword">for</span> station, states_for_station <span class="keyword">in</span> stations.items():</span><br><span class="line">        covered = states_for_station &amp; states_needed <span class="comment">#该广播台能覆盖的州</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(covered) &gt; <span class="built_in">len</span>(states_covered):</span><br><span class="line">            states_covered = covered</span><br><span class="line">            best_station = station</span><br><span class="line"></span><br><span class="line">    states_needed = states_needed - states_covered <span class="comment"># 从要覆盖的州中减去已经覆盖过的</span></span><br><span class="line">    print(<span class="string">'states_needed:'</span>, states_needed)</span><br><span class="line"></span><br><span class="line">    final_stations.add(best_station)</span><br><span class="line"></span><br><span class="line">print(final_stations)</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>PTransE：Modeling Relation Paths for Representation Learning of Knowledge Bases笔记</title>
    <url>/ptranse.html</url>
    <content><![CDATA[<p>创新：考虑了关系路径信息增强知识表示学习</p>
<h2 id="introduction">Introduction</h2>
<p>TransE 及其扩展模型往往只考虑了实体之间的直接关系，但事实上，知识图谱中的实体之间的多步关系路径也蕴含了丰富的语义信息。</p>
<p>比如(小明,出生地，山东)，(山东,位于，中国)隐含了实体小明和实体中国之间的nationalaity关系。</p>
<p>为突破现有 TransE 等模型孤立学习每个三元组的局限性，考虑关系路径的知识表示学习方法，以 TransE 作为基础进行扩展，提出 Path-based TransE（PTransE）模型，将知识图谱中的关系路径融入到知识表示学习模型中。</p>
<p><img src="/ptranse/image1.png"></p>
<p>PTransE模型的两个主要挑战</p>
<p>1是关系路径置信度</p>
<p>并不是所有的关系路径都是可靠且对知识表示学习是有意义的。比如（小明，朋友，小刚）（小刚，职业，医生）。事实上这条路径并没有反映头实体 h 和尾实体 t 之间的语义关系。一个人的职业可能跟他的朋友的职业完全无关。因此，我们的模型可能不能直接考虑所有的路径。</p>
<p>2是关系路径的表示</p>
<p>为了在知识表示学习模型中考虑关系路径，我们需要将关系路径同样表示为低维稠密向量。也就是说 PTransE 模型需要建立关系路径的向量表示，参与从头实体到尾实体的关系推理过程。这是典型的组合语义问题，需要对路径上所有关系的向量进行语义组合产生路径向量。</p>
<h2 id="our-model">our model</h2>
<p>PTtransE对每个三元组，能量函数为</p>
<p><span class="math display">\[G(h,r,t) = E(h,r,t) + E(h,P,t) \]</span></p>
<p>$E(h,r,t) = $ ||<strong>h</strong>+<strong>r</strong>-<strong>t</strong>||与TransE模型一样</p>
<p><span class="math inline">\(E（h,P,t） = \frac{1}{Z}\sum_{p \in P(h,t)}R(p|h,t)E(h,p,t)\)</span></p>
<p>其中，p是关系路径，<span class="math inline">\(R(p|h,t)\)</span>表示实体对(h,t)之间的关系路径p的可靠性。</p>
<p><span class="math inline">\(Z=\sum_{p \in P(h,t)}R(p|h,t)\)</span>是归一化因子，<span class="math inline">\(E(h,p,t)\)</span>表示关系路径下实体对的能量。</p>
<h3 id="关系路径的置信度">2.2 关系路径的置信度</h3>
<p>对于关系路径的置信度，提出基于路径约束的资源分配算法PCRA，其基本思想是：假设存在一定数量的资源，从头部实体 h 流出，且将沿着给定路径 p 流动，<strong>用最终流向尾部实体 t 的资源数量来衡量路径 p 作为 h 和 t 之间连接路径的可靠性。</strong></p>
<p>流向实体m的资源被定义为：</p>
<p><img src="/ptranse/image2.png"></p>
<p>举个例子</p>
<p><img src="/ptranse/image3.png"></p>
<p>尾实体获得的资源大小代表了其可以从头实体获取到的信息大小。使用尾实体资源<span class="math inline">\(R_p(t)\)</span>来衡量路径p对实体（h，t）的置信度，即<span class="math inline">\(R（p|h,t） = R_p(t)\)</span></p>
<h3 id="关系路径的表示">2.3 关系路径的表示</h3>
<p><img src="/ptranse/image4.png"></p>
<p>关系路径的语义很大程度上依赖于它所涉及的关系。因此，通过路径上涉及的所有关系的表示的语义组合来构建路径表示是合理的。如图所示，路径表示<strong>p</strong> 由 BorninCity，CityInState 和 StateInCountry 的表示组合而成。</p>
<p>具体来说，对于一个关系路径$ p = (r1, . . .,rl)<span class="math inline">\(，我们定义一个语义组合操作 ◦ 并获得关系路径表示\)</span> p = r1 ◦ . . . ◦ rl $。我们尝试了三种不同的方法得到关系路径的 表示：相加，相乘，循环神经网络。</p>
<p>对于一个多步关系路径三元组 (h, p, t)，我们可以简单参考 TransE 的来定义其 能量函数：<span class="math inline">\(E(h, p, t) = ||h + p − t||\)</span></p>
<p><span class="math inline">\(E(h,p,t) = || p-(t-h ) || = ||p-r||\)</span></p>
<p>该能量函数在关系路径 p 和关系 r 一致时拥有较低的分数，不需要考虑实体的向 量信息。</p>
<p>最终目标函数</p>
<p><img src="/ptranse/image5.png"></p>
<h3 id="其他重要细节">其他重要细节</h3>
<p><strong>添加反向关系</strong></p>
<p>PCRA只考虑了一个方向，我们也需要反向关系，而反向关系在现有知识图谱中很可能不存在。</p>
<p>因此，我们对于知识图谱中的每一个关系添加一个反向关系，也就是，对于每一个关系事实三元组 (h,r, t)，我们向知识图谱中添加其对应的反向三元组 (t,<span class="math inline">\(r^{-1}\)</span>, h)。</p>
<p><strong>关系路径选择约束</strong></p>
<p>为了提高计算效率，本章节中我们将路径长度限制在最多 3 步，并仅考虑那些置信度分值大于 0.01 的关系路径.</p>
<p>Re：</p>
<p>http://nlp.csai.tsinghua.edu.cn/~lzy/thesis/2019_linyankai.pdf</p>
<p>https://www.jianshu.com/p/c3ace92cd6ef</p>
<p>测试的时候，先根据||h+r-t||计算baseloss，根据loss排序，选出500个候选实体对</p>
<p>再利用h与t之间的存在路径集合P的每条路径p与r ||p-r||再根据loss排序</p>
]]></content>
      <categories>
        <category>论文笔记</category>
      </categories>
      <tags>
        <tag>知识表示</tag>
        <tag>关系路径</tag>
        <tag>embedding</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>文本编辑器折腾记录</title>
    <url>/wenben.html</url>
    <content><![CDATA[<p>记录下mac下的文本编辑器使用体验，写代码就用IDE啊！</p>
<p>要求：</p>
<ul>
<li><p>1选中文本，相同内容高亮显示；</p></li>
<li><p>2代码折叠</p></li>
</ul>
<p>结论：sublime配合插件</p>
<h2 id="vscode">vscode</h2>
<p>我在mac下卡死两次了，感觉跟codeHelper和Electron进程有关系。放弃了</p>
<h2 id="coteditor">coteditor</h2>
<p>不支持代码折叠；</p>
<p>默认情况下多个文件在多个窗口，而不是一个窗口。（没看过设置不知道能不能改）</p>
<h2 id="sublime">sublime</h2>
<p>本来用vscode的，结果vscode遇到卡死问题，又得回来捣鼓sublime</p>
<h4 id="高亮显示">高亮显示</h4>
<p>默认是个框，一点也不高亮。</p>
<p>1.首先安装好Package Control，这部分网上资料很多不赘述了。</p>
<p>安装插件：<a href="https://github.com/SublimeText/WordHighlight">WordHilight</a> 安装方法不赘述了。</p>
<p>不过默认配色是注释的颜色，而我的颜色主题是Mariana，注释是灰色的也不太高亮。按如下步骤改下颜色。</p>
<p>2.修改颜色</p>
<p>快捷键command + shift + P：输入Package Resource Viewer:Open Resoource.</p>
<p>再输入Color Scheme -Default</p>
<p>选择Mariana.sublime-color-scheme(根据自己主题选择)</p>
<p>（<font color="blue">看网上的主题配置文件都有个.tmTheme文件，我就没找到</font>，我改的是这个。）</p>
<p>可以看到有很多颜色配置，使用的是HSL配色。</p>
<p><img src="/wenben/颜色.png"></p>
<p>当然，这里可以直接修改注释的颜色，搜索“comment”查看"foreground"的值。比如下图我的comment的颜色用的是blue6，这里就可以修改blue6的值</p>
<p><img src="/wenben/comment.png"></p>
<p>我选择新建一个配色，“hanghighlight”是我自己添加的高亮颜色-绿色，可以自己在网上找颜色转换之类的获取HSL配色。直接复制Comment的配置，将foreground改为hanghighlight，wordhighlight是我起的名字。</p>
<p><img src="/wenben/wordhighlight.png"></p>
<p>（<strong>同理，在这里可以修改注释、String、数字等颜色</strong>）</p>
<p>3.配置WordHilight插件</p>
<p>Preferences → Package Settings → WordHilight → Settings - User:</p>
<p>插入以下代码，其他可选见WordHilight的github地址。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">   <span class="string">"draw_outlined"</span>: false,</span><br><span class="line">   <span class="string">"color_scope_name"</span>: <span class="string">"wordhighlight"</span>,<span class="comment"># wordhighlight就是上文的name值</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>4 最终效果</p>
<p>鼠标选中“unordered_map”后， 其他相同内容会变成乐色高亮显示</p>
<p><img src="/wenben/效果.png"></p>
<p>有问题可以在邮箱在评论区留言。</p>
]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>折腾</tag>
      </tags>
  </entry>
  <entry>
    <title>Word问题汇总</title>
    <url>/office365.html</url>
    <content><![CDATA[<h1 id="word">word</h1>
<ul>
<li><p>内容不能顶格</p>
<p>段落→特殊格式设置为无</p></li>
<li><p>目录 参考文献 列表 10对不齐</p></li>
</ul>
]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>折腾</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏体验记录</title>
    <url>/game.html</url>
    <content><![CDATA[<p>我期待的RPG：</p>
<p>更换装备后就能改变人物形象，而不是只能靠时装改变。</p>
<p>支持装备交易</p>
<h1 id="网游">网游</h1>
<h2 id="流放之路">流放之路</h2>
<ul>
<li>类似暗黑破坏神的刷刷刷装备游戏
<ul>
<li>更换装备后，人物形象发生改变，但是装备普遍太难看了，传奇装备的外观也像破烂货， 而且人物有点小也没有展示人物的界面，装备高度同质化，不认真看还以为没换过。换句话说，不是很好的体验到的装备养成带来的成就感。</li>
<li>支持装备交易</li>
</ul></li>
<li>弃坑原因：
<ul>
<li>①刷刷刷，有点无聊。</li>
<li>②没时间，时间长了心中有愧</li>
<li>③装备做的不够好，作为一款刷装备的游戏，装备可以做的更威武帅气一点，有点区分度（锤子都一个样，法杖就更不必说了，都是一根小短棍，也就能区分出不同类型的武器，是单手剑还是巨剑，是剑还是锤子）</li>
<li>交易价格很低，要想有点收益还不如搬砖来得快，</li>
</ul></li>
</ul>
<h1 id="手游">手游</h1>
<h2 id="摩尔庄园">摩尔庄园</h2>
<p>感觉像个半成品，好多没有做，依然摆脱不了诱导充值的手游通病。消费我的情怀。</p>
<p>【首冲六元、七天签到、98元继续领取、限时福利礼包、十连抽……】（不愧是雷霆游戏）</p>
<p>再说一个跑图问题，</p>
<p>1进了地图没有小地图，地图又做的比较大，根本不知道NPC在哪里，只能瞎转悠。</p>
<p>2场景交互问题，不太容易知道这个房屋能不能进，这点有点伤（在页游上鼠标会变成手型）。</p>
<h1 id="单机">单机</h1>
<h2 id="gta5">GTA5</h2>
<ul>
<li>吸引我的地方
<ul>
<li>GTA系列的开放</li>
<li>开车挺爽，当成极品飞车玩</li>
</ul></li>
<li>弃坑原因：
<ul>
<li>任务同质化，射击体验非常不好，不好瞄准；</li>
<li>玩的有点空虚</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>折腾</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/regular.html</url>
    <content><![CDATA[<h2 id="section"></h2>
<ul>
<li><code>^</code>匹配输入字符串的起始位置</li>
<li><code>$</code>匹配输入字符串的结束位置</li>
<li><code>+</code>匹配一个或多个</li>
<li><code>*</code>匹配零个或多个</li>
<li>若要匹配这些特殊字符用<code>\+</code>,<code>\*</code>,<code>\$</code></li>
</ul>
<p>匹配换行符 (linux/mac上是, windows 上是)</p>
<ul>
<li><p>括号</p>
<ul>
<li><a href="#section"></a> 定义匹配的字符范围，Eg [0-9]匹配数字</li>
<li>{}匹配的长度。<code>\s{3}</code>匹配3个空格，<code>\s{1,3}</code>匹配1~3个空格</li>
</ul></li>
</ul>
<p>Re:</p>
<p><a href="https://www.runoob.com/regexp/regexp-syntax.html">菜鸟教程</a></p>
<p>https://toutiao.io/posts/8to2il/preview</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>我眼中的股票基金</title>
    <url>/mymoney.html</url>
    <content><![CDATA[<h1>背景：</h1>
<p>我的理财方面的意识是从《穷爸爸富爸爸》这本书启蒙的，后续又看了《小狗钱钱》。较为专业的理财方面的知识主要是雪球系列丛书 ，例如《傻瓜式投资》《定投十年财务自由》《指数基金投资指南》，但实际上还是不知道买什么，什么时候买，什么时候卖。还有一本教记账的《下班后赚更多》。</p>
<p>总的来说，对我影响最大的且实际可行书籍的是《穷爸爸富爸爸》《傻瓜式投资》《下班后赚更多》</p>
<h1>想法：</h1>
<ul>
<li>
<p>1.日常生活做好理财意识，考虑这钱值不值得花，同时做好记账。</p>
</li>
<li>
<p>2.专业的理财知识（各种指数、波动）不必强求，毕竟咱本身不是专业的，也不感兴趣，也没时间不能像专业人士每天几个小时研究这些，不如强化自己的主业。</p>
</li>
</ul>
<h1>实际：</h1>
<p>目前我是在<strong>支付宝和蛋卷上买基金，在Excel上记账</strong>。</p>
<p>支付宝凭着感觉（主要是看看基金经理以往的表现）每周不定额定投，亏了的基金就放着不管（或者根据以往表现考虑是否加仓），收益率超过一定数就卖（我是15%），卖了以后就不知道买什么，依然凭着感觉选，现在竟然还没有亏的基金也是很神奇。</p>
<p>蛋卷基金跟着一些“大V”跟投，emm感觉收益更我自己在支付宝上选的差不多。</p>
<p>记账是选的Excel，一般一个星期记一次，或者空闲没事干就记录下，不太明白为什么大多数人是在APP上记账的。我感觉在电脑Excel上记，在手机上翻看微信和支付宝的账单很方便啊；另一方面，想查看什么类别，进行什么操作都可以自己决定并通过Excel实现。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>我眼中的读书</title>
    <url>/mybook.html</url>
    <content><![CDATA[<p>这里的读书指的是课外书，且不包括当下新书、网文，大部分是经历时间检验的名著。</p>
<p>自进入大学以来到今天为止（2021.6.2）读了百余本书，最近越来越读不下去了，最近答辩完了没事干，索性记录下自己的心路历程吧。</p>
<p>关于读书的类别：一开始我是读文学小说类，后面读励志鸡汤类，再后面就是工具实用类。</p>
<p>关于读书的设备：一开始kindle，现在是微信读书（免费还是很香的，没有的书就去找PDF）</p>
<p>当上大学时，在知乎上看到过一个问题是“读书读了就忘，那读书还有什么意义？”，有人回答道：“我吃了很多饭，但大部分已经不记得吃的什么了，但我知道我吃过的饭都变成了构成为身体的血肉，想来读书也是如此，成为我精神的血肉。”当初看到这个回答，犹如醍醐灌顶。</p>
<p>对于小说类书籍，我一直有个问题，同样都是小说为什么有的是名著，有的就只能是网文。虽然有的读起来很精彩，但读完感觉并没有收获什么。有的名气很大，但我感觉就是垃圾。读完后只能出去装个杯说看过《百年孤独》？</p>
<p>我读这些名著类小说有什么意义呢，从中能体会到主人公的艰辛、成长的不易？那我萧炎“三十年河东，三十年河西，莫欺少年穷”又怎么说；从中反映了当时的社会现实？那要是特意分析一篇网文，同样能整出花来，Eg“不要让时代的悲哀成为你的悲哀”。</p>
<p>（P.S.俄罗斯名著中的角色名是真复杂真拗口，同一个人还有好几个不同的名字，Eg高尔基的三部曲）小说类名著里唯一一篇对我有真正影响的便是<strong>《平凡的世界》</strong>，我读了两遍（让我读两遍的课外书绝对不超过10本），每当我遇到重大困难，我总是会想起孙少平、孙少安两兄弟在为生活而奋斗，对苦难的乐观精神。其他的即使是我觉得五星好评的书籍也渐渐忘却，内容缺记不大清了。像《傲慢与偏见》《飘》《杀死一只知更鸟》。</p>
<p>所以，最近我一直都没有再读小说类名著，转而追求实用。包括时间管理、学习方法、健康养生……要说有没有用？有用，有多大？也不是那种能让人焕然一新、脱胎换骨的。另外，这种书实际读起来是比较枯燥的，静不下心来，在执行过程中大部分观点也难以坚持，谁都知道早睡早起身体好，但事实上emm。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
